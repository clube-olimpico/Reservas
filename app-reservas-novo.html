<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Clube Olímpico - Sistema de Reservas</title>

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	
	<link rel="manifest" href="manifest.json">
    
    <meta name="theme-color" content="#4CAF50">
    <meta name="mobile-web-app-capable" content="yes">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Reservas">

    <link rel="apple-touch-icon" href="novo-logo-6.png">

    <link rel="icon" href="novo-logo-6.png" type="image/png">
	
	<!-- Configurações para evitar cache -->
    <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="expires" content="0">
	
	<link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">


<style> 

/* Estilos globais */ 
body {
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 0;
    /* Adicionado para dar espaço para o Cabeçalho Novo + Abas */
    padding-top: 100px; 
    background-color: #f4f4f4; 
}

#loginScreen {
    box-sizing: border-box;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #ffffff;
    padding: 20px;
    
    /* --- NOVAS LINHAS --- */
    border-radius: 15px; /* Cantos arredondados, valor pode ser ajustado */
    /* Adicionamos top e transform para animar a subida e descida */
    transition: background-color 0.4s ease, box-shadow 0.4s ease, top 0.4s ease, transform 0.4s ease;
	box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15); /* Sombra suave: 0 horizontal, 4px vertical, 20px de desfoque, cor preta com 15% de opacidade */
    /* --- FIM DAS NOVAS LINHAS --- */

    width: 95%;
    max-width: 350px;
    text-align: center; 
    z-index: 1000;
}

/* Cabeçalho da tela de login */
#loginHeader {
    margin-bottom: 30px;  
}

#loginHeader h1 {
    font-size: 32px; 
    color: #333;
    margin: 0;
}

#loginHeader h2 {
    font-size: 24px;
    color: #555;
    margin: 10px 0;
}

#loginHeader h3 {
    font-size: 24px;
    color: #777;
    margin: 40px 0;
}

.input-group {
    display: flex;
    align-items: center; /* Alinha os elementos verticalmente */
    gap: 10px;
    width: 100%;
}

.label-acesso {
    white-space: nowrap; /* Impede que o texto do label quebre em várias linhas */
    font-weight: bold;
}


.acesso-wrapper {
    position: relative; /* Permite posicionamento absoluto do botão */
    display: flex;
    align-items: center;
    gap: 5px;
    width: 100%; /* Ocupa toda a largura disponível */
}


/* Campo de entrada de senha */
.acesso-wrapper input {
    width: 280%;
    padding-right: 150px; /* Espaço para o botão à direita */
	padding: 12px 16px; /* Padding vertical e horizontal */
    box-sizing: border-box;
	height: 35px; /* Altura menor */
}

/* Botão de alternar senha */
#toggleSenha {
    position: right; /* Posicionamento absoluto dentro do container */
    top: 50%; /* Centraliza verticalmente */
    right: 100px; /* Ajuste este valor para mover o botão mais para a esquerda */
    transform: translateY(-50%); /* Centraliza verticalmente */
    background: none;
    border: none;
    cursor: pointer;
    font-size: 18px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
	max-width: 10%;
}


    /* Título */
    #loginScreen h2 {
        margin-bottom: 20px;
        font-size: 24px;
        color: #333; 
    }

    /* Dropdown de seleção de jogadores */
	/* ADICIONADO: Força a altura exata (fica igual no Android/iPhone) */
    /* Dropdown de seleção de jogadores - Com Setinha Customizada */
    #jogadorSelect {
        width: 100%;
        height: 35px;
        padding: 5px 10px;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 5px;
        margin-bottom: 20px;
        background-color: #ffffff;
        
        /* Limpa o estilo nativo (remove a seta feia/antiga) */
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;

        /* --- DESENHA A NOVA SETINHA --- */
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007CB2%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        /* Posiciona a seta à direita */
        background-position: right 10px top 50%;
        /* Define o tamanho da seta */
        background-size: 12px auto;
        
        /* Adiciona espaço extra à direita para o texto não ficar em cima da seta */
        padding-right: 30px;  
    }

    /* Botão de entrar */
    #loginScreen button {
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 20px;
        font-size: 16px;
        border-radius: 5px;
        cursor: pointer;
        width: 100%;
		margin-top: 20px; /* Adiciona espaço entre o último campo e o botão */
    }

    #loginScreen button:hover {
        background-color: #45a049;
    }
	

	/* Efeito de clique (feedback tátil) no botão de login */
	#loginScreen button:active {
		transform: scale(0.98);
		transition: transform 0.1s ease;
	}
	/* ----------------------------------------------------*/

    /* Conteúdo principal (inicialmente oculto) */
    #mainContent {
        display: none;
        text-align: center;
    }

    /* Mensagem de boas-vindas */
    #nomeJogador {
        font-weight: bold;
        color: #4CAF50;
    }

    /* Botão de sair */
    #mainContent button {
        background-color: #f44336;
        color: white;
        border: none;
        padding: 10px 20px;
        font-size: 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
    }

    #mainContent button:hover {
        background-color: #d32f2f;
    }


/* Contêiner principal do formulário */
/* --- FORMULÁRIO MODERNO (MODAL CENTRALIZADO) --- */
.form-container {
    position: fixed;
    /* O SEGREDO: top e left em 50% colocam o ponto de ancoragem no MEIO da tela */
    top: 50% !important; 
    left: 50% !important;
    
    /* O transform centraliza o elemento nele mesmo */
    transform: translate(-50%, -50%) scale(0.9); 
    
    width: 90%;
    max-width: 400px; /* Largura ideal para celular */
    background-color: #ffffff;
    border-radius: 15px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
    
    z-index: 9005; /* ALTERADO DE 2000 PARA 9005 (Para vencer a tabela 9000) */
    padding: 10px 20px 20px 20px; /* Topo: 10px, Dir: 20px, Baixo: 20px, Esq: 20px */
    box-sizing: border-box;
    
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28), visibility 0.3s;
}

.form-container.visible {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1); 
    margin: 0 !important; /* Removemos margens antigas que causavam o erro */
}

/* Backgroup Escuro */
.form-backdrop {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(3px);
    z-index: 9004; /* ALTERADO DE 1999 PARA 9004 */
    display: none;
}
.form-backdrop.visible {
    display: block;
}

/* Cabeçalho do Modal de Agendamento */
.form-header {
    position: relative; /* Importante: cria o limite para o botão X */
    display: flex;
    justify-content: center; /* Centraliza o título */
    align-items: center;
    width: 100%; /* Garante que o cabeçalho ocupe toda a largura */
    
    margin-top: -5px; 
    margin-bottom: 20px; 
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}

.form-header h3 {
    margin: 0;
    font-size: 1.4rem;
    color: #333;
    font-weight: bold;
    text-align: center;
    width: 100%; /* Garante alinhamento */
}

/* Botão X de fechar do formulário */
.close-form-btn {
    position: absolute !important;
    right: 0 !important;
    top: 50% !important;
    transform: translateY(-60%) !important;
    
    /* --- Estilos Visuais --- */
    width: auto !important;
    height: auto !important;
    background: transparent !important;
    background-color: transparent !important;
    box-shadow: none !important;
    border: none !important;
    margin: 0 !important;
    padding: 0 5px !important;
    
    font-size: 32px !important;
    font-weight: bold !important;
    
    /* --- MUDANÇA DE COR AQUI --- */
    color: #dc3545 !important; /* Vermelho padrão do sistema */
    /* -------------------------- */

    cursor: pointer !important;
    line-height: 1 !important;
    z-index: 9006 !important; /* ALTERADO DE 2002 PARA 9006 */
}

.close-form-btn:hover {
    /* Fica um vermelho mais escuro ao passar o mouse */
    color: #a71d2a !important; 
    
    background-color: transparent !important;
    transform: translateY(-60%) scale(1.1) !important;
}


/* Ajustes do Cabeçalho no Modo Escuro */
body.dark-mode .form-header h3 {
    color: #f1f1f1;
}
body.dark-mode .form-header {
    border-bottom-color: #444;
}
body.dark-mode .close-form-btn:hover {
    color: #fff !important;
}


/* --- ALINHAMENTO DOS CAMPOS (FLEXBOX) --- */
.form-container .form-row {
    display: flex;
    align-items: center;
    width: 100%;
    justify-content: space-between;
    margin-bottom: 12px;
}

/* Labels com largura fixa para alinhar tudo */
.form-container label {
    flex: 0 0 80px; 
    margin-right: 10px;
    white-space: nowrap;
    text-align: left;
    font-size: 1rem;
}

/* Inputs ocupam o resto da linha */
.form-container input,
.form-container select {
    flex: 1; 
    width: auto !important;
    min-width: 0;
    height: 38px;
    box-sizing: border-box;
}

/* Ajuste específico para a linha do Jogador (+ botão) */
.form-container .jogadores-container .form-row {
    display: flex; align-items: center;
}
.form-container .add-jogador {
    flex: 0 0 30px;
    width: 30px !important;
    text-align: center;
    font-size: 24px;
    line-height: 38px;
    margin-left: 5px;
    cursor: pointer;
    color: blue;
}

/* Modo Escuro */
body.dark-mode .form-container { background-color: #2a2a2a; border: 1px solid #444; }
body.dark-mode .close-form-btn { color: #888; }
body.dark-mode input:disabled, body.dark-mode select:disabled {
    background-color: #3a3a3a !important; color: #aaa !important; border-color: #555;
}
/* --- FIM DE FORMULÁRIO MODERNO (MODAL CENTRALIZADO) --- */




/* Configuração das linhas do formulário */
.form-row {
    display: flex;
    align-items: center;
    margin-bottom: 7px;
    flex-wrap: nowrap; /* Mantém label e input na mesma linha */
}

/* Estilização dos labels */
label {
    margin-right: 10px;
    width: 160px; /* Tamanho fixo do label para alinhamento */
    font-size: 1rem;
}

/* Configuração do campo "Nome do Jogador" */
.jogador-input {
    width: 50px; /* Largura fixa para manter consistência */
    box-sizing: border-box; /* Inclui padding e bordas no cálculo da largura */
    margin: 0;
    padding: 5px;
}


/* Ajusta o tamanho do select de jogadores */
    #jogador1 {
		width: 270px !important; /* Força a largura para 270px */
		margin-right: 0 !important; /* Garante que não empurre o botão */
		font-size: 15px !important;
	}
	/* As regras para #jogador2, #jogador3 e #jogador4 foram removidas.
	   Eles agora obedecerão a regra geral de 290px. */
		
	
#botaoAgendar {
    background-color: #4CAF50; /* Cor de fundo verde padrão */
    color: white;
    border: none;
    padding: 8px 12px;       /* Aumenta o tamanho interno para um toque mais fácil */
    font-size: 1.0em;         /* Deixa a fonte um pouco maior */
    font-weight: bold;        /* Texto em negrito para dar destaque */
    border-radius: 8px;       /* Cantos arredondados, consistentes com os campos */
    cursor: pointer;
    width: 100%;
    margin-top: 5px;         /* Espaçamento superior ajustado */
    margin-bottom: 0px;       /* Garante que não haja margem inferior */

    /* Efeitos de profundidade e animação */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
}

/* Efeito ao passar o mouse */
#botaoAgendar:hover {
    background-color: #45a049; /* Verde um pouco mais escuro */
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3); /* Sombra mais pronunciada */
}

/* Efeito ao CLICAR (feedback tátil) */
#botaoAgendar:active {
    transform: scale(0.98); /* Diminui o botão para simular o clique */
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* Sombra diminui junto */ 
}



/* Responsividade: ajuste para dispositivos móveis */
@media (max-width: 600px) {

/* --- AJUSTES MODAL EDIÇÃO (CELULAR) --- */
    .edit-jogador-row select {
        /* Permite que o select encolha e corte o texto */
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        flex-shrink: 1; /* Garante que ele possa encolher */
        white-space: nowrap; /* 
    }

    .edit-status-span {
        width: 75px; /* Reduz de 85px para 75px */
        font-size: 13px; /* Diminui um pouco a fonte do status */
        padding-left: 5px; /* Adiciona um respiro */
        white-space: nowrap; /* Impede que o status quebre linha */
    }
    /* --- FIM DOS AJUSTES --- */

footer {
    color: transparent !important;   /* Mantém o texto "Desenvolvido por..." invisível */
    margin-top: 7px !important;   /* Define um espaço PEQUENO acima da versão (vence o 20px inline) */
    margin-bottom: 0px !important; /* Define um espaço PEQUENO abaixo da versão */
    padding: 0;                      /* Remove qualquer padding interno */
}
footer #VersaoSistema {
    font-size: 0.9rem !important;    /* Mantém a fonte visível (correto) */
    display: block !important;       /* Força a ser um bloco (correto) */
    
    /* --- A MUDANÇA ESTÁ AQUI --- */
    
    width: 100px; /* Define uma largura fixa (suficiente para "v1.7.5") */
    
    /* Centraliza o texto DENTRO da caixa de 100px */
    text-align: center !important; 
    
    /* Centraliza a PRÓPRIA caixa (o bloco) na tela */
    margin-left: auto !important;
    margin-right: auto !important;
    
    /* Remove as margens verticais (vencendo o 70px inline) */
    margin-top: 0 !important;
    margin-bottom: 0 !important;
}

#fab-toggle-form {
    width: 50px !important; /* Força o botão a ter 50px, sobrescrevendo o "width: 100% !important" */
    height: 50px !important; /* Garante a altura para formar o círculo */
}

.motivo-resultado {
    text-align: center;
    font-size: 0.9em;
    font-style: italic;
    color: #666;
    margin-top: 10px;
    margin-bottom: 0;
}
body.dark-mode .motivo-resultado {
    color: #ccc;
}

#wo-controls .form-row {
        flex-wrap: nowrap;
        justify-content: flex-start;
    }
    #wo-controls .form-row label {
        white-space: nowrap;
        font-size: 0.9em;
    }



/* --- CORREÇÃO PARA IPHONE dentro de max-width: 600px */
    
    /* 1. Garante que o container ocupe a largura exata da tela sem vazar */
    .tab-container {
        padding: 0 5px !important;       
        box-sizing: border-box !important; 
        display: flex !important;        
        width: 100% !important;          
        justify-content: space-between !important;
    }

    /* 2. Força os botões a terem tamanhos matematicamente iguais */
    .tab-button {
        flex: 1 !important;              /* Divide o espaço disponível por 3 */
        width: 0 !important;             /* Zera a largura base para o flex funcionar */
        min-width: 0 !important;         /* Permite encolher o texto se necessário */
        
        /* Remove o padding lateral excessivo que causava a quebra no iPhone */
        padding: 4px 0px !important; 
        margin: 0 2px !important;    
        
        font-size: 0.85rem !important;   /* Fonte segura para telas estreitas */
        font-weight: bold !important;
        line-height: 1.1 !important;
        
        /* Centralização vertical e horizontal */
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        text-align: center !important;
        height: 40px !important;
    }
/* --- fim de CORREÇÃO PARA IPHONE dentro de max-width: 600px */


.form-container {
	margin-bottom: 0px;
	padding-top: 15px;    /* NOVO: Diminui o espaço de cima */
    padding-bottom: 15px; /* NOVO: Diminui o espaço de baixo */
	
	padding-left: 0px !important;   /* Reduzimos de 20px para 5px (puxa para a esquerda) */
    padding-right: 20px !important; /* Mantemos 20px na direita (que você disse estar perfeito) */
}

/* --- RESPIRO DOS LABELS (SEM MEXER NOS INPUTS) --- */
    .form-container label {
        padding-left: 20px !important;     /* Empurra o texto para a direita */
        box-sizing: border-box !important; /* O SEGREDO: Mantém a largura total fixa */
    }

table {
    margin-top: 2px !important; /* Reduzimos a margem de 20px para 10px no celular */
}

/* Aumenta o espaço vertical entre as linhas de confronto no modal de INFORMAR resultado */
#modalResultadoDuplas .duplas-match-container {
    margin-bottom: 20px;
}


	#modal-resultado-placar .matchup-row {
    margin-bottom: 13px; /* Aumenta o espaço vertical. Ajuste o valor como desejar. */
}

/* DENTRO de @media (max-width: 600px) */

/* Ajusta o tamanho dos campos de tie-break para ficarem iguais aos de placar no celular */
#modalResultadoDuplas .tiebreak-container input[type="number"] {
    width: 30px !important;
    height: 30px;
    font-size: 1.0em;
    /* O padding e outros estilos serão herdados, mas podemos garantir aqui se necessário */
    padding: 2px 4px;
    box-sizing: border-box;
}

	/* 2. Aumenta o tamanho dos campos de placar e dos números */
	.score-input {
		width: 20px !important; 
		height: 20px;
		font-size: 1.2em;
	}

/* ADICIONE ESTA NOVA REGRA NO LUGAR DA ANTIGA */
#modal-resultado-placar .team-names {
    font-size: 0.85em; /* Reduz o tamanho da fonte para 85% do normal */
	line-height: 1.2;
}

    .matchup-row {
        padding: 0px !important;
    }

	
     th, td {
        display: table-cell;
		vertical-align: middle; /* Mantém o texto alinhado no meio */
		padding: 20px 4px;
        font-size: 18px; /* Opcional: reduz o tamanho da fonte para melhor ajuste */
    }

    .jogador-input {
        width: 100% !important; /* Campo ocupa toda a largura disponível */
        max-width: 175px; /* Limita a largura máxima */
    }
    
	label {
		width: 90px; /* Reduz o label de 160px para 90px */
		margin-right: 5px; /* Reduz a margem */
		flex-shrink: 0; /* Impede que o label encolha */
		font-size: 0.95rem; /* Opcional: leve redução da fonte */
	}
    /* Aumenta a largura dos campos de entrada em dispositivos móveis */
    
	
	
	/* --- CORREÇÃO DEFINITIVA MOBILE (SUBSTITUTO) --- */
	/* --- CORREÇÃO FINAL ALINHAMENTO (FLEXBOX PURO) --- */

    /* 1. Garante que a linha se comporte como elástico */
    .form-container .form-row {
        display: flex !important;
        align-items: center !important;
        width: 100% !important;
    }

    /* 2. Rótulos (Labels): Coluna fixa na esquerda (90px) */
    /* Isso garante que TODOS os campos comecem na mesma linha vertical */
    .form-container label {
        flex: 0 0 90px !important;  
        width: 90px !important;
        min-width: 90px !important;
        margin-right: 5px !important;
        white-space: nowrap !important;
    }

    /* 3. Todos os Campos (Quadra, Dia, Hora e Responsável) */
    /* Truque: width: 0 obriga o navegador a ignorar os 290px e usar o flex */
    .form-container select,
    .form-container input,
    .form-container #jogador1 {
        flex: 1 !important;          /* Ocupe TODO o espaço disponível */
        width: 0 !important;         /* Zera a largura fixa para não dar conflito */
        min-width: 0 !important;
        max-width: none !important;
        box-sizing: border-box !important;
    }

    /* 4. Botão (+): Caixa estreita, Símbolo na direita e SEM PISCAR AZUL */
    /* 4. Botão (+): Transparente, mas com EFEITO DE CLIQUE */
    .form-container .add-jogador {
        flex: 0 0 25px !important;
        width: 25px !important;
        text-align: right !important;
        padding-right: 0 !important;
        margin: 0 !important;
        display: inline-block !important;
        background-color: transparent !important;
        border: none !important;
        
        /* Remove o azul padrão feio */
        -webkit-tap-highlight-color: transparent !important;
        outline: none !important;
        
        /* Prepara o terreno para a animação suave */
        transition: transform 0.1s ease, opacity 0.1s ease !important;
    }

    /* O EFEITO MÁGICO: Quando o dedo toca (Active) */
    .form-container .add-jogador:active {
        background-color: transparent !important; /* Sem fundo */
        opacity: 0.5 !important;        /* O ícone fica meio transparente */
        transform: scale(0.8) !important; /* O ícone encolhe um pouquinho */
    }

    /* Garante que foco/hover não estraguem */
    .form-container .add-jogador:focus,
    .form-container .add-jogador:hover {
        background-color: transparent !important;
        outline: none !important;
        box-shadow: none !important;
    }
	/* --- fim de CORREÇÃO FINAL ALINHAMENTO (FLEXBOX PURO) --- */

    /* 5. Garante botão Confirmar largura total */
    #botaoAgendar {
        width: 100% !important;
        margin-left: 0 !important;
    }
    
    /* 4. Regra do Botão Agendar (Centralização Manual) */
    #botaoAgendar {
        /* Largura = 100% do espaço disponível MENOS os 20px que vamos empurrar */
        width: calc(100% - 20px) !important; 
        
        /* Empurra 20px para a direita. 
           Como já existe 20px de espaço vazio na direita (do container), 
           agora teremos 20px na esquerda também. = CENTRALIZADO! */
        margin-left: 20px !important; 
        
        margin-top: 5px !important;
        margin-bottom: 0px !important;
    }
	
	
	
    
    
	.horario {
        padding: 5px 4px;
        height: 25px;
        line-height: 1;
		font-size: 16px; /* Opcional: reduz o tamanho da fonte para melhor ajuste */
    }
	
	#theme-toggle-button {
		width: 50px !important; /* Força a largura correta, sobrescrevendo a regra geral */
		height: 50px !important; /* Garante a altura para formar o círculo */
	}
	
	/* Aumenta o tamanho dos campos de tie-break especificamente no celular */
    .tiebreak-container input {
        width: 35px !important; 
    }
	
	
}
/* -------------------------------------------- */
/* ------------- fim de 600px ------------------ */
/* -------------------------------------------- */



/* Estilização geral para inputs, selects e botões */
input, select, button {
    /* flex-grow: 1; */ /* REMOVA ESTA LINHA */
    width: 290px;     /* ADICIONE ESTA LARGURA FIXA */
    padding: 5px;
    font-size: 1rem;
}

/* Contêiner de jogadores (campos dinâmicos) */ 
.jogadores-container {
    display: flex;
    flex-direction: column;
    margin-top: 0px;
}

/* Adicione isto para garantir que o Jogador 1 (mesmo habilitado) não mude */
#jogador1, #jogador2, #jogador3, #jogador4 {
    font-size: 14px !important; /* Force o tamanho exato que você deseja */
}

/* Esconde os labels "Jogador:" extras (2, 3, 4) */
.jogadores-container .form-row:not(:first-child) label {
    visibility: hidden;
}


/*******************************/
/* Botão de adicionar jogador */
/*******************************/

.add-jogador {
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    width: 32px !important;
    height: 32px !important;
    flex: 0 0 32px !important;
    border-radius: 50% !important;
    
    /* Cores e Fundo (PC) */
    background-color: #e8f5e9 !important;
    color: #2e7d32 !important;
    border: 1px solid #c8e6c9 !important;
    
    /* Estilo do Símbolo e Efeito 3D */
    font-size: 26px !important;
    font-weight: bold !important;
    line-height: 1 !important;
    /* Sombra que dá volume ao símbolo (+) */
    text-shadow: 0.5px 0.5px 0px rgba(255,255,255,0.8), 1px 1px 2px rgba(0,0,0,0.2) !important;
    
    /* Interação */
    cursor: pointer !important;
    transition: all 0.1s ease-in-out !important;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
    margin-left: 10px !important;
    padding: 0 !important;
    user-select: none !important;
    -webkit-tap-highlight-color: transparent !important;
}

/* Efeito de Clique (PC e Geral) - Simula botão físico afundando */
.add-jogador:active {
    transform: translateY(2px) scale(0.92) !important;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.2) !important;
    text-shadow: none !important; /* Remove o relevo ao "afundar" */
}

/* AJUSTE EXCLUSIVO PARA CELULAR */
@media (max-width: 768px) {
    .add-jogador {
        /* Remove o fundo e borda para eliminar o formato oval */
        background-color: transparent !important;
        border: none !important;
        box-shadow: none !important;
        
        /* Aumenta o símbolo e reforça o efeito 3D no texto */
        font-size: 32px !important;
        text-shadow: 1px 1px 0px #fff, 2px 2px 3px rgba(0,0,0,0.3) !important;
    }
    
    /* Feedback de toque no celular (apenas cor e escala) */
    .add-jogador:active {
        transform: scale(0.85) !important;
        color: #1b5e20 !important;
        text-shadow: 0px 0px 0px transparent !important;
    }
}
/*************************************/
/* fim de Botão de adicionar jogador */
/*************************************/

/* Estilização dos botões */
button {
    background-color: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
    width: 100%;
    padding: 9px;
    margin-top: 1px;
    margin-bottom: -10px;
}

button:hover {
    background-color: #45a049;
}

/* Contêiner para as abas de navegação */
/* Abas fixas no topo (Regra Mestra Consolidada) */
/* Abas fixas no topo (Ajustado para ficar abaixo do Header) */
.tab-container {
    position: fixed;
    top: 45px; /* Desce 60px para não ficar embaixo do novo header */
    left: 0;
    width: 100%;
    height: 55px; 
    z-index: 1100;
    background-color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    padding: 0;
    box-sizing: border-box;
}

/* Configuração para tabelas */
.tabela-container {
    overflow-x: auto; /* Permite rolagem horizontal */
    width: 100%;
    margin-top: -10px;
}

table {
    width: 100%;
    margin-top: 20px;
    border-collapse: collapse;
}

th, td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: center;
    white-space: nowrap; /* Impede a quebra de linha */
    overflow: hidden; /* Evita que o conteúdo transborde */
    text-overflow: ellipsis; /* Adiciona "..." caso o texto seja muito longo */
	height: 10px; /* Ajuste a altura conforme necessário */
	display: table-cell;
}


th {
    background-color: #f2f2f2;
	/* --- BLOQUEIA SELEÇÃO DE TEXTO --- */
    -webkit-user-select: none; /* Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* IE 10+ e Edge */
    user-select: none;         /* Padrão */
    /* -------------------------------- */
}

/* Estilo para cabeçalho */
.header {
    text-align: center;
    font-size: 1.5rem;
    margin-top: 20px;
    margin-bottom: 10px;
    text-indent: 10px; /* Ajuste o valor para o espaçamento desejado */
	/* --- LINHAS ADICIONADAS --- */
    -webkit-user-select: none; /* Para Safari e Chrome no iOS */
    -moz-user-select: none;    /* Para Firefox */
    -ms-user-select: none;     /* Para Internet Explorer/Edge */
    user-select: none;         /* Padrão oficial */
}

/* Classe para aba selecionada */
.selected {
    font-weight: bold;
    background-color: #228B22;
    color: white;
}

/* Transição de opacidade */
.fade-out {
    transition: opacity 0.3s ease-out;
    opacity: 0;
}

/* Estilização dos botões de aba */
.tab-button {
    position: relative;
    background-color: #f1f1f1; /* Cor mais neutra para abas não selecionadas */
    color: #555; /* Texto mais escuro para contraste */
    font-weight: bold;
    border: 2px solid #ccc;
    padding: 8px 20px;
    margin: 5px;
    cursor: pointer;
    border-radius: 50px; /* Deixa o botão arredondado (estilo "pílula") */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Sombra sutil */
    /* Transição suave para todas as propriedades */
    transition: all 0.3s ease;
}

/* Efeito de clique (feedback tátil) */
.tab-button:active {
    transform: scale(0.97); /* Efeito de pressionar */
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* Diminui a sombra */
}

/* Linha inferior do botão selecionado */
.tab-button.selected::after {
    content: none;
}

.tab-button:hover {
    background-color: #e9e9e9;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
}

/* Botão de aba desabilitado */
.tab-button[disabled] {
    cursor: not-allowed;
    background-color: red;
}

.tab-button.selected {
    background-color: #4CAF50; /* Verde principal do clube */
    color: white;
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4); /* Sombra verde para destaque */
}

/* Indicadores de carregamento */
#loading {
    display: block;
    text-align: center;
    font-size: 1.5rem;
}

#content {
    display: none;
}

/* Estilização para tela cheia */
.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: white;
    z-index: 9000; /* ALTERADO DE 9999 PARA 9000 */
    overflow: auto;
}

.fullscreen table {
    width: 100%;
    height: auto;
}



/*****************************************/
/****** Estilos para o Modo Escuro *******/
/*****************************************/

/* ========================================================== */
/* CORREÇÃO DA COR DO BOTÃO '+' NO MODO ESCURO                */
/* ========================================================== */

body.dark-mode .add-jogador {
    color: white; /* Altera a cor do '+' para branco no modo escuro */
}

/* ========================================================== */

body.dark-mode {
    background-color: #121212;
    color: #ffffff;
}

/* Estilo do Card de Login para o MODO ESCURO */
body.dark-mode #loginScreen {
    background-color: #2a2a2a;
    border: 1px solid #444;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
}

/* Adaptação do formulário para o MODO ESCURO */
body.dark-mode .form-container {
    background-color: #2a2a2a;
    border: 1px solid #444;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
}

body.dark-mode #loginScreen {
    background-color: #2a2a2a; /* Um cinza um pouco mais claro que o fundo do body */
    border: 1px solid #444;    /* Uma borda sutil para definir melhor a caixa no escuro */
    color: #f1f1f1;
    /* A sombra original do modo claro é removida aqui e substituída pelo efeito de borda/cor */
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); /* Uma sombra mais escura para dar profundidade no modo escuro */
}

/* Garante que o texto dos labels e títulos fique branco */
body.dark-mode #loginScreen h2,
body.dark-mode #loginScreen .label-acesso {
    color: #f1f1f1;
}

/* Estilo para o título principal "Clube Olímpico" */
body.dark-mode #loginHeader h1 {
    color: #ffc107; /* Amarelo/Laranja para destaque, como em outros lugares */
    text-shadow: 0 0 8px rgba(255, 193, 7, 0.5); /* Adiciona um brilho sutil */
}

/* Estilo para o subtítulo "Quadras de Tênis" */
body.dark-mode #loginHeader h2 {
    color: #ccc; /* Mantém o cinza claro */
}

/* Estilo para o título "Sistema de Reservas" */
body.dark-mode #loginHeader h3 {
    color: #007bff; /* Traz o azul de volta! */
    text-shadow: 0 0 5px rgba(0, 123, 255, 0.5); /* Adiciona um brilho sutil azul */
}


/* Garante que os campos de input e select tenham o estilo escuro correto */
/* O !important é necessário para vencer o style="..." do HTML */
body.dark-mode #loginScreen #jogadorSelect,
body.dark-mode #loginScreen #acesso_user {
    background-color: #333 !important;
    color: #fff !important;
    border: 1px solid #555 !important;
}

/* Garante que o placeholder (texto de ajuda) fique legível no escuro */
body.dark-mode #acesso_user::placeholder {
    color: #bbb !important;
}

body.dark-mode h1,
body.dark-mode h2,
body.dark-mode h3 {
    color: #ffffff;
}

body.dark-mode input,
body.dark-mode select {
    background-color: #333333;
    color: #ffffff;
    border-color: #555555;
}

body.dark-mode .tab-button {
    background-color: #333;
    color: #ccc;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}
body.dark-mode .tab-button:hover {
    background-color: #444;
}

/* Aba SELECIONADA no MODO ESCURO */
body.dark-mode .tab-button.selected {
    background-color: #4CAF50;
    color: white;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.5); /* Sombra verde mais intensa */
}

body.dark-mode .header {
    color: #ffffff;
}

body.dark-mode table,
body.dark-mode th,
body.dark-mode td {
    border-color: #444444;
}

body.dark-mode th {
    background-color: #333333;
	/* --- BLOQUEIA SELEÇÃO DE TEXTO --- */
    -webkit-user-select: none; /* Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* IE 10+ e Edge */
    user-select: none;         /* Padrão */
    /* -------------------------------- */
}

/* Cor específica para #f2f2f2 no modo escuro */
body.dark-mode .f2f2f2-dark,
body.dark-mode [style*="background-color: rgb(242, 242, 242)"],
body.dark-mode [style*="background-color: #f2f2f2"] {
    background-color: #555555 !important;
}

#theme-toggle-button {
    position: fixed; /* Posição fixa em relação à janela do navegador */
    bottom: 20px;    /* 20 pixels da parte inferior */
    right: 20px;     /* 20 pixels da parte direita */
    width: 50px;     /* Largura do botão */
    height: 50px;    /* Altura do botão */
    border-radius: 50%; /* Deixa o botão redondo */
    background-color: #333;
    color: white;
    border: none;
    font-size: 24px; /* Tamanho do ícone/texto */
    cursor: pointer;
    z-index: 9001; /* ALTERADO DE 1001 PARA 9001 */
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
	transition: background-color 0.3s ease, color 0.3s ease;
    outline: none;
}
#theme-toggle-button:focus {
    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.5); /* Uma "aura" verde suave ao focar */
}

#theme-toggle-button:hover {
    background-color: #555;
}

/* Ajuste para o modo escuro, se desejar uma cor diferente para o botão */
body.dark-mode #theme-toggle-button {
    background-color: #f1f1f1;
    color: #121212;
}

body.dark-mode #theme-toggle-button:hover {
    background-color: #dcdcdc;
}


body.dark-mode #botaoAgendar {
    background-color: #4CAF50; /* Voltamos para o azul */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
}

body.dark-mode #botaoAgendar:hover {
    background-color: #45a049; /* Azul um pouco mais escuro no hover */
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
}

/* Define o fundo opaco para a tela cheia no modo escuro */
body.dark-mode .fullscreen {
    background-color: #121212; /* A mesma cor do fundo do modo escuro */
}

/* Cor da versão do sistema no modo escuro */


/* Corrige bordas das células específicas bloqueadas manualmente no modo escuro */
body.dark-mode td[style*="background-color: #f2f2f2"],
body.dark-mode td[style*="background-color: rgb(242, 242, 242)"] {
    border: 1px solid #444444 !important;
}

/* Bloco novo e corrigido */
body.dark-mode .modal-content {
    background-color: #333333; /* Um cinza mais claro para destacar o modal */
    color: #f1f1f1;            /* Texto principal um pouco mais suave que branco puro */
    border: 1px solid #555555; /* Uma borda sutil para definir a janela */
} 

body.dark-mode .modal-content h3 {
    color: #ffffff; /* Garante que o título fique branco e visível */
}


body.dark-mode #loading {
    background-color: #121212 !important; /* Fundo escuro para combinar com o tema */
    color: #ffffff !important;           /* Garante que o texto seja branco e visível */
}

/* Estilo para a caixa de resumo no modal de confirmação */
.resumo-partida {
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
    text-align: center;
}

/* Estilo da mesma caixa para o modo escuro */
body.dark-mode .resumo-partida {
    background-color: #424242; /* Fundo cinza escuro */
    border-color: #555;      /* Borda sutil */
    color: #f1f1f1;          /* Texto claro */
}


/* ========================================================== */
/* fim do modo escuro */
/* ========================================================== */


/* Estilos para o Modal de Convites */
.modal-overlay {
    display: none; /* Começa invisível */
    position: fixed; /* Cobre a tela inteira */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6); /* Fundo preto semitransparente */
    backdrop-filter: blur(5px); /* Efeito de desfoque que você pediu */
    z-index: 10001; /* Mantenha 10001, pois já é maior que 9000 */
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    width: 90%;
    max-width: 500px; /* Mesma largura da sua caixa de convites */
    box-shadow: 0 5px 15px rgba(0,0,0,0.3); 
}

.modal-content-reserva {
    background-color: white;
    padding: 20px 30px;
    border-radius: 8px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    position: relative;
    color: #333;
}

.modal-content-reserva h3 {
    margin-top: 0;
    text-align: center;
    color: #228B22;
	margin-bottom: 1px;
}

.modal-content-reserva p {
    margin: 4px 0;
    line-height: 1.5;
}

.modal-content-reserva hr {
    border: none;
    border-top: 1px solid #eee;
    margin: 15px 0;
}

/* Ajusta o espaçamento da linha  antes do "Resultado do Jogo:" */
#modal-resultado-container hr {
    margin-top: -10px;    /* Controla o espaço ACIMA da linha (abaixo dos jogadores) */
    margin-bottom: 15px; /* Controla o espaço ABAIXO da linha (acima do texto "Resultado") */
    
    /* A regra original do modo escuro para a borda */
    border-top: 1px solid #eee;
}

/* Ajusta o espaçamento da linha ANTES de "Jogadores" */
#modalDetalhesReserva p:has(~ #modal-jogadores) + hr {
    margin-top: 5px;    /* Controla o espaço ACIMA da linha (abaixo do Organizador) */
    margin-bottom: 15px; /* Controla o espaço ABAIXO da linha (acima de "Jogadores") */
}


/* --- NOVOS ESTILOS PARA BOTÕES DO MODAL EDITAR --- */
.edit-modal-actions {
    display: flex;
    flex-direction: column; /* Padrão (Vertical) */
    gap: 10px; /* Espaço entre os botões */
    margin-top: 15px; /* Espaço acima do primeiro botão */
}
.edit-modal-actions button {
    margin: 0 !important; /* Remove margens inline/padrão */
}
/* --- FIM DOS NOVOS ESTILOS --- */

/* Ajusta o espaço ACIMA do texto "Resultado informado por..." no modal de detalhes (com !important) */
#modal-resultado-placar p:last-of-type {
    margin-top: -1px !important; /* Adicionado !important para sobrescrever o estilo inline */
	margin-bottom: -10px !important; /* Espaço ABAIXO - Ajuste este valor como desejar */
}

/* Ajuste da cor da linha no modo escuro */
body.dark-mode #modal-resultado-container hr {
    border-top: 1px solid #444;
}

.close-button {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    color: #aaa;
    cursor: pointer;
}

.close-button:hover {
    color: #333;
}

/* Estilos para os nomes dos jogadores no modal */
#modal-jogadores ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}


/* --- ESTILOS GLOBAIS (PC E CELULAR) PARA O MODAL DETALHES --- */
#modal-jogadores li,
#modal-convidados li {
    display: flex;             /* Torna o <li> um container flex */
    justify-content: space-between; /* Coloca nome na esquerda, status na direita */
    align-items: center;       /* Alinha verticalmente */
    width: 100%;               /* Ocupa todo o espaço */

    /* Regras que pegamos do <li> antigo */
    padding: 5px 0;
    border-bottom: 1px solid #f0f0f0;
}

#modal-jogadores li:last-child,
#modal-convidados li:last-child {
    border-bottom: none;
}

.status-confirmado,
.status-pendente,
.status-recusado {
    flex-shrink: 0;          /* Impede que o STATUS encolha */
    white-space: nowrap;     /* Impede que o STATUS quebre linha */
}
/* --- FIM DOS ESTILOS GLOBAIS --- */

/* Estilos para o status de confirmação */
.status-confirmado {
    color: green;
    font-weight: bold;
    margin-left: 8px;
}
.status-pendente {
    color: orange;
    font-weight: bold;
    margin-left: 8px;
}
.status-recusado {
    color: red;
    font-weight: bold;
    margin-left: 8px;
}

/* Ajustes para o Modo Escuro */
body.dark-mode .modal-content-reserva {
    background-color: #2a2a2a;
    color: #f1f1f1;
    border: 1px solid #555;
}

body.dark-mode .modal-content-reserva h3 {
    color: #4CAF50;
}

body.dark-mode .close-button {
    color: #888;
}
body.dark-mode .close-button:hover {
    color: #f1f1f1;
}
body.dark-mode #modal-jogadores li {
    border-bottom-color: #444;
}

/* COLE ESTE CÓDIGO DENTRO DA SUA TAG */

/* Estilos para os botões dentro do novo modal de ações */
.modal-content button {
    width: 100%;
    padding: 12px;
    margin-top: 10px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
}

/* Modo escuro para os botões do novo modal */
body.dark-mode .modal-content button {
    color: white; /* Garante que o texto seja branco em todos os botões no modo escuro */
}

/* Ajusta o espaçamento do botão de cancelar */
#btnModalCancelar {
    margin-top: 0;
}

/* ADICIONE ESTE NOVO BLOCO DE ESTILOS DENTRO DA SUA TAG <style> */

.edit-jogador-row {
    display: flex;
    align-items: center;
    gap: 0px; /* Controla o espaço entre os itens */
    margin-bottom: 10px;
}

.edit-jogador-row select {
    flex-grow: 1;
    margin-right: 10px;
}

.remove-jogador-btn {
    cursor: pointer;
    color: red;
    font-size: 24px;
    font-weight: bold;
    padding: 0px;
	margin-left: 5px;
}

/* Estilo base para o texto de status (computador) */
.edit-status-span {
    width: 85px; /* 
    text-align: left;
    font-size: 14px;
    font-weight: bold;
    flex-shrink: 0; /* Impede que o texto encolha */
	
}

/* Desabilita a seleção de texto nas células da planilha de reservas */ 
#tabelaCorpo td {
    -webkit-user-select: none; /* Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* IE 10+ e Edge */
    user-select: none;         /* Padrão */
}


/* ================================================== */
/* ====== ESTILOS PARA O CARTÃO DE ANIVERSÁRIO ====== */
/* ================================================== */

#birthdayModalContent {
    background: linear-gradient(145deg, #6a11cb 0%, #2575fc 100%);
    color: white;
    padding: 25px 30px;
    border-radius: 15px;
    width: 90%;
    max-width: 420px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    text-align: center;
    position: relative;
    border: 3px solid rgba(255, 255, 255, 0.8);
    animation: jelly-bounce 0.8s ease-out;
}

@keyframes jelly-bounce {
  from, to { transform: scale(1, 1); }
  25% { transform: scale(0.9, 1.1); }
  50% { transform: scale(1.1, 0.9); }
  75% { transform: scale(0.95, 1.05); }
}

#birthdayModalContent h2 {
    margin-top: 10px;
    font-size: 2.2em;
    font-weight: bold;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
}

#birthdayModalContent p {
    font-size: 1.1em;
    line-height: 1.5;
}

#closeBirthdayModal {
    background-color: white;
    color: #2575fc;
    border: none;
    padding: 12px 30px;
    font-size: 1.1em;
    font-weight: bold;
    border-radius: 50px;
    cursor: pointer;
    margin-top: 15px;
    transition: all 0.2s ease-in-out;
    width: auto !important;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

#closeBirthdayModal:hover {
    transform: scale(1.05);
    background-color: #f0f0f0;
}

/* Estilo para o "selo" da idade */
.birthday-badge {
    position: absolute;
    top: -25px;
    right: -20px;
    background-color: #ffc107;
    color: #333;
    width: 70px;
    height: 70px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.8em;
    font-weight: bold;
    border: 3px solid white;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    transform: rotate(15deg);
}


/* ================================================== */
/* Estilos para o novo placar de resultado */
/* ================================================== */
/* --- INÍCIO DO BLOCO DE CSS PARA O PLACAR --- */

/* Estilo para a posição do jogador no placar */
.placar-posicao {
    font-size: 0.8em; /* Menor que o nome */
    color: #888; /* Cor mais suave */
    margin-right: 8px; /* Espaçamento entre a posição e o nome */
    width: 25px; /* Largura fixa para alinhamento */
    text-align: right; /* Alinha o número à direita */
    flex-shrink: 0; /* Impede que seja espremido */
}
body.dark-mode .placar-posicao {
    color: #bbb; /* Cor mais suave no modo escuro */
}

/* Estilos para o novo placar de resultado */
.placar-container {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 1.2em; 
    line-height: 1.6;
}
.placar-row {
    display: flex;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px solid #eee;
}
body.dark-mode .placar-row {
    border-bottom: 1px solid #444; 
}
.placar-row:last-child {
    border-bottom: none;
}
.placar-nome {
    font-weight: normal;
    flex-grow: 1; /* Pede para o nome ocupar o espaço extra */
}
.placar-sets {
    display: flex;
    gap: 15px; 
    font-weight: bold; 
}
.set-score {
    width: 30px; 
    text-align: center;
    color: #888; 
}
body.dark-mode .set-score {
    color: #aaa;
}
.set-score.winner {
    color: #333; 
    font-weight: 900; 
}
body.dark-mode .set-score.winner {
    color: #fff;
}
.set-score sup {
    font-size: 0.7em;
    vertical-align: super;
    margin-left: -2px;
    font-weight: normal; 
}
/* Estilo para o nome do vencedor da partida */
.placar-nome.match-winner {
    font-weight: 900; 
    color: #333;
}
body.dark-mode .placar-nome.match-winner {
    color: #fff;
}

#modal-resultado-placar .placar-container {
    margin-top: 5px;
}

/* --- FIM DO BLOCO DE CSS PARA O PLACAR --- */
/* ================================================== */
/* final de Estilos para o novo placar de resultado */
/* ================================================== */


/* ================================================== */
/* --- Estilos para o Modal de Resultado de Duplas --- */
.matchup-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 0;
    border-bottom: 1px solid #eee;
}
.matchup-row:last-child {
    border-bottom: none;
}
.team-names {
    font-size: 1em;
    font-weight: bold;
    text-align: center;
    flex-basis: 40%; /* Define a largura das colunas dos nomes */
}
.score-input-container {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-basis: 20%; /* Define a largura da coluna do placar */
    justify-content: center;
}
.score-input {
    width: 50px; /* Mesmo tamanho da pirâmide */
    text-align: center;
    font-size: 1em; /* Tamanho de fonte padrão, sem aumento */
    font-weight: normal; /* Remove o negrito */
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

/* Ajustes para o modo escuro */
body.dark-mode .matchup-row {
    border-bottom-color: #444;
}
body.dark-mode #duplasJogadoresInfo {
    color: #aaa;
}
body.dark-mode .score-input {
    background-color: #333;
    color: white;
    border-color: #555;
}

.score-column {
    display: flex;
    flex-direction: column; /* Empilha os itens verticalmente */
    align-items: center;    /* Centraliza os itens horizontalmente */
    flex-basis: 20%;        /* Ocupa o espaço central */
}

/* --- Estilo para os parênteses do Tie-Break --- */
.tiebreak-paren {
    font-size: 1.1em;   /* Aumenta o tamanho da fonte do parêntesis */
    font-weight: normal;
    color: #888;
    display: inline-flex;
    align-items: center;
}
body.dark-mode .tiebreak-paren {
    color: #aaa;
}

/* Adicione esta nova regra para diminuir os campos do tie-break */
.tiebreak-container input[type="number"] {
    height: 20px;       /* Diminui a altura do campo */
    font-size: 0.9em;   /* Diminui a fonte do número */
    padding: 2px 4px;   /* Ajusta o espaçamento interno */
}

/* ---  fim de Estilos para o Modal de Resultado de Duplas --- */
/* ================================================== */


#VersaoSistema {
    display: inline-block !important; /* !important garante que ele fique na mesma linha */
    margin: 0 15px 0 0 !important; /* Zera as margens verticais e adiciona uma à direita */
    text-align: right !important; /* Mantém o alinhamento se necessário */
    position: static !important; /* Remove o posicionamento antigo */
    font-size: 0.9em !important;   
    color: #888 !important;       
    z-index: auto !important;
	user-select: none;
}

body.dark-mode #VersaoSistema {
    color: #777 !important;
}



/* Estilo para o fundo desfocado da página inteira */
.page-overlay {
    display: none; /* Começa oculto */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6); /* Usa o mesmo fundo dos outros modais */
    backdrop-filter: blur(5px); /* O efeito de desfoque */
    z-index: 999; /* Fica atrás da janela de login, mas na frente do resto */
}



/* Estilos para a tela de bloqueio de versão */
#versao-desatualizada-overlay {
    display: none; /* Começa oculto */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(20, 20, 20, 0.9);
    backdrop-filter: blur(8px);
    z-index: 99999; /* Fica na frente de absolutamente tudo */
    justify-content: center;
    align-items: center;
    text-align: center;
    color: white;
}

#versao-desatualizada-overlay .mensagem-overlay {
    padding: 20px;
    border-radius: 10px;
    background-color: rgba(0, 0, 0, 0.4);
}

#versao-desatualizada-overlay h1 {
    color: #ffc107; /* Amarelo para destaque */
}


/* ========================================================== */
/* ETAPA 1.3: ANIMAÇÃO DE ENTRADA PARA O CARD DE LOGIN      */
/* ========================================================== */

/* 1. Aqui definimos a "receita" da nossa animação */
@keyframes fadeInCard {
  /* Estado inicial da animação (quando começa) */
  from {
    opacity: 0; /* Começa totalmente transparente */
    transform: translate(-50%, -50%) scale(0.95); /* Começa um pouco menor */
  }

  /* Estado final da animação (quando termina) */
  to {
    opacity: 1; /* Termina totalmente visível */
    transform: translate(-50%, -50%) scale(1); /* Termina no tamanho normal */
  }
}

/* 2. Aqui aplicamos a animação ao nosso card de login */
#loginScreen {
    /* Usamos a animação 'fadeInCard' que criamos acima.
       Ela vai durar 0.5 segundos e terá uma curva de aceleração 'ease-out'.
    */
    animation: fadeInCard 0.5s ease-out forwards;
}

/* ========================================================== */
/* FIM DO BLOCO                                               */
/* ========================================================== */



/* ========================================================== */
/* ETAPA 2.1: MODERNIZAÇÃO DE TODOS OS MODAIS                 */
/* ========================================================== */

/* 1. Animação de entrada para os modais (similar à do login) */
@keyframes fadeInModal {
  from {
    opacity: 0;
    transform: scale(0.95); /* Começa um pouco menor e transparente */
  }
  to {
    opacity: 1;
    transform: scale(1); /* Termina no tamanho e opacidade normais */
  }
}

/* 2. Aplica a animação e o novo visual a todos os modais */
.modal-content, .modal-content-reserva {
    border-radius: 15px; /* Cantos arredondados, igual ao login */
    border: none; /* Remove a borda antiga, a sombra fará o trabalho */
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.15); /* Sombra para o efeito flutuante */
    
    /* Aplica a animação que criamos */
    animation: fadeInModal 0.4s ease-out forwards;
}

/* 3. Adaptação para o Modo Escuro */
body.dark-mode .modal-content, 
body.dark-mode .modal-content-reserva {
    background-color: #2a2a2a; /* Mesma cor do card de login para consistência */
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5); /* Sombra mais forte para o escuro */
    border: 1px solid #444; /* Borda sutil para definir as bordas */
}

/* ========================================================== */
/* FIM DO BLOCO                                               */
/* ========================================================== */


/* ========================================================== */
/* ETAPA 2.3: ESTILOS PARA AS NOTIFICAÇÕES CUSTOMIZADAS       */
/* ========================================================== */

.notificacao {
    position: fixed; /* Flutua sobre o resto do conteúdo */
    top: 20px;       /* Distância do topo */
    right: 20px;     /* Distância da direita (Padrão Desktop) */
    
    background-color: #333; /* Cor de fundo padrão */
    color: white;
    
    /* --- MELHORIA DE LEITURA E ESPAÇAMENTO --- */
    padding: 20px 25px;      /* Espaço interno generoso */
    border-radius: 12px;     /* Cantos arredondados modernos */
    box-shadow: 0 8px 25px rgba(0,0,0,0.4); /* Sombra mais forte para destacar */
    
    font-size: 1.05rem;      /* Letra levemente maior */
    line-height: 1.6;        /* Espaço entre linhas de texto comum */
    text-align: left;        /* Alinha à esquerda */
    max-width: 350px;        /* Largura máxima no PC */
    width: 90%;              /* Largura base */
    /* -------------------------------- */

    z-index: 99999; /* Fica na frente de tudo */
    
    /* Estado inicial: invisível e fora da tela (Desktop) */
    opacity: 0;
    transform: translateY(-50px);
    visibility: hidden;
    transition: all 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
}

/* --- AJUSTE CRÍTICO PARA CELULAR (CORREÇÃO DE CORTE) --- */
@media (max-width: 600px) {
    .notificacao {
        right: auto !important; /* Remove alinhamento à direita */
        left: 50% !important;   /* Posiciona o centro na metade da tela */
        width: 85% !important;  /* Define uma largura segura (com margens) */
        
        /* Estado INICIAL no Celular: Centralizado horizontalmente (-50%), Subido verticalmente (-50px) */
        transform: translate(-50%, -50px) !important; 
    }
    
    .notificacao.show {
        /* Estado VISÍVEL no Celular: Centralizado horizontalmente (-50%), Posição normal vertical (0) */
        transform: translate(-50%, 0) !important;
    }
}

/* --- O TRUQUE DO ESPAÇAMENTO --- */
/* Isso cria o espaço físico entre o Título e a Mensagem */
.notificacao br {
    display: block;
    margin-bottom: 8px; /* Aumente este número se quiser mais espaço */
    content: "";
}

/* Estilo para Negrito (Títulos) */
.notificacao b {
    font-weight: 900;
    letter-spacing: 0.5px;
    font-size: 1.1em; /* Título levemente maior */
}

/* Classe que torna a notificação visível (Padrão Desktop) */
.notificacao.show {
    opacity: 1;
    transform: translateY(0);
    visibility: visible;
}


/* 1. SUCESSO (Verde) */
.notificacao.success,
body.dark-mode .notificacao.success {
    background-color: #5cb85c;
    border-left: 6px solid #4cae4c;
}

/* 2. Cor de fonte geral da notificação */
.notificacao.success {
    color: #ffffff !important;
}

/* --- Estilos específicos para o PLACAR na notificação --- */
.notificacao.success .placar-nome.match-winner,
.notificacao.success .set-score.winner {
    color: #FFFFFF !important;
}
.notificacao.success .placar-nome:not(.match-winner),
.notificacao.success .set-score:not(.winner),
.notificacao.success .placar-posicao {
    color: #333333 !important;
}
/* Correção Modo Escuro Placar */
body.dark-mode .notificacao.success .placar-nome:not(.match-winner),
body.dark-mode .notificacao.success .set-score:not(.winner),
body.dark-mode .notificacao.success .placar-posicao {
    color: #D3D3D3 !important; 
}


/* Variação de cor para ERRO (Vermelho) */
.notificacao.error {
    background-color: #d9534f; 
    border-left: 6px solid #b52b27; /* Borda lateral mais escura */
}

/* Adaptação para o MODO ESCURO */
body.dark-mode .notificacao {
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
}

body.dark-mode .notificacao.error {
    background-color: #d9534f;
    border-left: 6px solid #b52b27;
}

/* Variação de cor para AVISO (Amarelo) */
.notificacao.warning {
    background-color: #ffc107; 
    color: #333; 
    border-left: 6px solid #e0a800;
}

body.dark-mode .notificacao.warning {
    background-color: #FFCA28;
    color: #333;
    border-left: 6px solid #e0a800;
}

/* ========================================================== */
/* fim de ETAPA 2.3: ESTILOS PARA AS NOTIFICAÇÕES CUSTOMIZADAS */
/* ========================================================== */


/* ========================================================== */
/* POLIMENTO DOS BOTÕES DO MODAL DE CONFIRMAÇÃO (PADRONIZADO) */
/* ========================================================== */

/* Estilos base para os botões de ação do modal */
#btnConfirmarAcao,
#btnCancelarAcao {
    font-weight: bold;
    transition: all 0.2s ease;
    width: auto !important; /* Força tamanho automático (não estica no celular) */
    min-width: 110px;       /* Garante um tamanho mínimo clicável */
    padding: 10px 25px;
    color: white !important; /* Texto sempre branco */
    border-radius: 8px;      /* Cantos arredondados modernos */
    border: none;
    cursor: pointer;
    margin: 0 !important;    /* Remove margens estranhas */
}

/* Efeito de hover (passar o mouse) */
#btnConfirmarAcao:hover,
#btnCancelarAcao:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    opacity: 0.9;
}

/* Efeito de clique */
#btnConfirmarAcao:active,
#btnCancelarAcao:active {
    transform: scale(0.98);
    box-shadow: none;
}

/* --- PADRONIZAÇÃO DE CORES (COM !important PARA VENCER O CELULAR) --- */

/* 1. Botão Cancelar: SEMPRE CINZA */
#btnCancelarAcao {
    background-color: #6c757d !important; 
}

/* 2. Botão Confirmar: MUDANÇA DE COR CONFORME O CONTEXTO */

/* Azul (Padrão/Neutro - ex: Sair, Info) */
#btnConfirmarAcao.btn-primary {
    background-color: #007bff !important; 
}

/* Verde (Positivo - ex: Confirmar Agendamento) */
#btnConfirmarAcao.btn-success {
    background-color: #28a745 !important; 
}

/* Vermelho (Destrutivo - ex: Excluir, Recusar, Cancelar Aula) */
#btnConfirmarAcao.btn-danger {
    background-color: #dc3545 !important; 
}
/* ========================================================== */
/* fim de POLIMENTO DOS BOTÕES DO MODAL DE CONFIRMAÇÃO (PADRONIZADO) */
/* ========================================================== */




/* ========================================================== */
/* AJUSTE FINAL: PADRONIZA COR DA FONTE DO PLACAR NA NOTIFICAÇÃO */
/* ========================================================== */

/* Força a cor da fonte para um tom claro nos textos secundários do placar (ranking e sets não vencidos) 
   QUANDO ele estiver dentro de uma notificação de erro. */
.notificacao.error .placar-posicao,
.notificacao.error .set-score {
    color: #f1f1f1; /* Um branco suave */
}

/* Força a cor da fonte para branco puro nos textos principais do placar (nomes e sets vencidos)
   QUANDO ele estiver dentro de uma notificação de erro. */
.notificacao.error .placar-nome,
.notificacao.error .set-score.winner,
.notificacao.error .placar-nome.match-winner {
    color: #ffffff; /* Branco puro */
}

/* ========================================================== */

/* ========================================================== */
/* ESTILOS PARA O MODAL "SOBRE O SISTEMA"                     */
/* ========================================================== */
#infoModalContent {
    display: flex;
    flex-direction: column;
    gap: 15px;
    background: linear-gradient(145deg, #6a11cb 0%, #2575fc 100%);
    color: white;
    padding: 25px 30px;
    border-radius: 15px;
    width: 90%;
    max-width: 450px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    border: 3px solid rgba(255, 255, 255, 0.8);
    animation: fadeInModal 0.4s ease-out; /* Reutiliza a animação existente */
}
#infoModalContent h3, #infoModalContent h4 {
    text-align: center;
    margin: 0;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
}
#infoModalContent h3 {
    margin-bottom: 10px;
}
.info-section p {
    margin: 8px 0;
    line-height: 1.5;
}
.about-section {
    text-align: center;
    font-size: 0.9em;
    opacity: 0.9;
}
.info-separator {
    border: none;
    border-top: 1px solid rgba(255, 255, 255, 0.3);
	margin: 1px 0;
}
.quick-links {
    list-style: none;
    padding: 0;
    margin: 10px 0 0 0;
}
.quick-links li {
    margin-bottom: 10px;
}
.quick-links a {
    color: white;
    text-decoration: underline;
    font-weight: bold;
    transition: color 0.2s ease;
}
.quick-links a:hover {
    color: #ffc107;
}
.pix-info {
    line-height: 1.4;
}
.user-logout-line {
    white-space: nowrap;     /* Impede a quebra de linha */
    overflow: hidden;          /* Esconde o texto que transbordar */
    text-overflow: ellipsis;   /* Adiciona "..." se o nome for muito longo */
    flex-shrink: 1;            /* Permite que o elemento encolha se necessário */
    display: flex;
    justify-content: space-between;
    align-items: center;
    line-height: 1.5;
}

/* Estilo para o novo botão de logout discreto */
/* Estilo para o novo botão de logout com ícone SVG */
#inlineLogoutBtn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    transition: background-color 0.2s ease, transform 0.1s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 10px;
    width: 36px !important;  
    height: 36px !important; 
    box-sizing: border-box; 
}
#inlineLogoutBtn svg {
    stroke: #ff5252; /* Tom de vermelho vivo para destaque */
}
#inlineLogoutBtn:hover {
    background-color: rgba(255, 255, 255, 0.2); /* Destaque sutil */
}
#inlineLogoutBtn:active {
    transform: scale(0.9); /* Efeito de clique */
}

#infoModalCloseBtn {
    background-color: white;
    color: #6a11cb;
    margin-top: -5px;
	border-radius: 8px; 
}
#infoModalCloseBtn:hover {
    background-color: #f0f0f0;
}


/* =================================================================== */
/* --- BLOCO DE CSS CONSOLIDADO PARA A FUNCIONALIDADE DE RESULTADO --- */
/* =================================================================== */

/* --- Estilos para o menu (⋮) e o formulário de resultado --- */

#btn-mais-opcoes {
    position: absolute; top: 50%; right: 0; transform: translateY(-50%);
    background: none; border: none; font-size: 28px; line-height: 1;
    font-weight: bold; cursor: pointer; color: #888;
    padding: 0 10px; width: auto !important;
}
#btn-mais-opcoes:hover { color: #333; }
body.dark-mode #btn-mais-opcoes { color: #aaa; }
body.dark-mode #btn-mais-opcoes:hover { color: #fff; }

.menu-dropdown {
    display: none; 
    position: absolute; 
    top: 100%; 
    right: 0;
    background-color: white; 
    border: 1px solid #ddd; 
    border-radius: 5px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1); 
    
    /* --- CORREÇÃO: AUMENTADO DE 10 PARA 100 --- */
    z-index: 100 !important; 
    /* ------------------------------------------ */
    
    width: 200px;
}
body.dark-mode .menu-dropdown { background-color: #444; border-color: #666; }
.menu-dropdown a {
    display: block; padding: 10px 15px; color: #333;
    text-decoration: none; font-size: 1rem;
}
body.dark-mode .menu-dropdown a { color: #f1f1f1; }
.menu-dropdown a:hover { background-color: #f5f5f5; }
body.dark-mode .menu-dropdown a:hover { background-color: #555; }
.menu-dropdown.visivel { display: block; }

#placar-fields-container input:disabled {
    background-color: #f0f0f0; cursor: not-allowed;
}
body.dark-mode #placar-fields-container input:disabled {
    background-color: #3a3a3a;
}

.botoes-acao-container {
    display: flex; justify-content: center;
    gap: 15px; margin-top: 20px;
}
.botoes-acao-container button {
    width: auto !important; padding: 10px 25px;
}

/* --- Estilos para a exibição final do placar --- */

.ret-indicator {
    display: inline-block; background-color: #dc3545; color: white;
    font-size: 0.8em; font-weight: bold; padding: 2px 5px;
    border-radius: 3px; margin-right: 10px; vertical-align: middle;
}

.motivo-resultado {
    text-align: center; font-size: 0.9em; font-style: italic;
    color: #666; margin-top: 10px; margin-bottom: 0;
}
body.dark-mode .motivo-resultado { color: #ccc; }

.placar-nome.match-winner {
    font-weight: 900 !important;
}

/* --- Estilos para o placar DENTRO das notificações --- */
/* (Este era um dos trechos que eu havia esquecido) */

.notificacao.success .placar-row[style*="font-weight: bold;"] .placar-nome,
.notificacao.success .placar-row[style*="font-weight: bold;"] .placar-sets {
    color: white !important;
}
.notificacao.success .placar-row[style*="font-weight: normal;"] .placar-nome,
.notificacao.success .placar-row[style*="font-weight: normal;"] .placar-sets {
    color: #333333 !important;
}
.notificacao.success .placar-posicao {
    color: #333333 !important;
}
.notificacao.error .placar-posicao,
.notificacao.error .set-score {
    color: #f1f1f1;
}
.notificacao.error .placar-nome,
.notificacao.error .set-score.winner,
.notificacao.error .placar-nome.match-winner {
    color: #ffffff;
}
/* =================================================================== */
/* --- FIM DO BLOCO DE CSS CONSOLIDADO PARA A FUNCIONALIDADE DE RESULTADO --- */
/* =================================================================== */



/* ================================================== */
/* ====== ESTILOS PARA O INDICADOR "AO VIVO" ====== */
/* ================================================== */

.live-indicator {
    /* REMOVIDO: position: absolute; */
    /* REMOVIDO: top: 6px; */
    /* REMOVIDO: left: 6px; */
    /* REMOVIDO: z-index: 5; */
    display: inline-block; /* NECESSÁRIO para o Modo Placar */
    width: 8px;           /* Tamanho */
    height: 8px;          /* Tamanho */
    background-color: #ff0000; /* Cor */
    border-radius: 50%;     /* Forma redonda */
    border: 1px solid white; /* Borda */
    box-shadow: 0 0 8px rgba(255, 0, 0, 0.8); /* Sombra/Brilho */
    vertical-align: middle; /* Alinhamento vertical com o texto no Modo Placar */
}

/* Animação de pulsar */
@keyframes pulse-live {
    0% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
    }
    70% {
        transform: scale(1.1);
        box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
    }
    100% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
    }
}
@keyframes pulse-live-placar-forte {
    0% {
        transform: scale(0.9); /* Começa um pouco menor */
        box-shadow: 0 0 4px 2px rgba(255, 0, 0, 0.8); /* Sombra inicial mais visível */
        opacity: 0.8; /* Levemente translúcido no início */
    }
    50% { /* Alterado para 50% para um pico mais rápido */
        transform: scale(1.2); /* Expande mais */
        box-shadow: 0 0 12px 6px rgba(255, 0, 0, 0); /* Sombra se expande e some mais */
        opacity: 1; /* Totalmente opaco no pico */
    }
    100% {
        transform: scale(0.9); /* Retorna ao tamanho menor */
        box-shadow: 0 0 4px 2px rgba(255, 0, 0, 0.8); /* Sombra retorna */
        opacity: 0.8; /* Retorna à translucidez */
    }
}

/* ================================================== */
/* ====== FIM DE ESTILOS PARA O INDICADOR "AO VIVO" ====== */
/* ================================================== */


/* ========================================================== */
/* ESTILOS PARA A ANIMAÇÃO DE CARREGAMENTO (SPINNER)          */
/* ========================================================== */
#loadingSpinner {
    border: 8px solid #f3f3f3; /* Borda cinza claro */
    border-top: 8px solid #4CAF50; /* Borda superior verde (cor do seu tema) */
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite; /* Aplica a animação de rotação */
    margin-bottom: 20px; /* Cria um espaço entre a animação e o texto */
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
/* ========================================================== */

/* ================================================== */
/* ====== NOVOS ESTILOS PARA O MODO PLACAR ====== */
/* ================================================== */
.placar-ao-vivo-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: #111;
    z-index: 99998;
    justify-content: center;
    align-items: center;
    font-family: 'Roboto', sans-serif;
    color: #e0e0e0;
    animation: fadeInModal 0.4s ease-out;
}

.placar-close-btn-novo {
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 40px;
    color: #888;
    cursor: pointer;
    transition: transform 0.2s ease, color 0.2s ease;
}
.placar-close-btn-novo:hover {
    color: white;
    transform: scale(1.2);
}

.placar-ao-vivo-content {
    display: flex;
    flex-direction: column;
    width: 95%;
    max-width: 900px;
    padding: 20px;
    box-sizing: border-box;
}

.placar-header-novo {
    text-align: center;
    margin-bottom: 40px;
}
.placar-header-novo h2 {
    margin: 0;
    font-size: 2em;
    font-weight: 700;
    color: white;
    letter-spacing: 1px;
}
.placar-header-novo p {
    margin: 5px 0 0 0;
    font-size: 1.2em;
    color: #888;
}

.placar-body {
    display: flex;
    flex-direction: column;
    gap: 0;
}

.placar-jogador-linha {
    display: flex;
    align-items: center;
    padding: 25px 15px;
    border-bottom: 1px solid #333;
}
.placar-jogador-linha:first-of-type {
    border-top: 1px solid #333;
}

.placar-jogador-posicao {
    font-size: 1.2em;
    font-weight: 400;
    color: #777;
    margin-right: 1px;
    width: 40px;
    text-align: center;
}

.placar-jogador-nome {
    flex-grow: 1;
    font-size: 2.2em;
    /* font-weight: 700; */
}

.placar-sets-container {
    display: flex;
    gap: 25px;
}

.placar-set {
    font-size: 2.2em; /* REDUZIDO de 3em */
    font-weight: 300;
    color: #888;
    width: 40px;      /* REDUZIDO de 50px para ficar proporcional */
    text-align: center;
    transition: all 0.3s ease;
}
.placar-set.set-vencedor {
    font-weight: 700;
    color: #ffffff;
    transform: scale(1.1);
}

.placar-footer {
    text-align: center;
    margin-top: 40px;
}

#tabelaCorpo td .live-indicator {
    position: absolute; /* ADICIONADO AQUI */
    top: 6px;           /* ADICIONADO AQUI */
    left: 6px;          /* ADICIONADO AQUI */
    z-index: 5;         /* ADICIONADO AQUI */
	animation: pulse-live 1.5s infinite;
}

.live-indicator-placar {
    font-weight: bold;
    color: #ff4d4d;
    font-size: 1.1em;
    letter-spacing: 2px;
    display: inline-flex;
    align-items: center;
}

/* Adiciona espaço entre o ponto e o texto "AO VIVO" (Permanece o mesmo) */
.live-indicator-placar .live-indicator {
    margin-right: 10px;
	animation: pulse-live-placar-forte 1.2s infinite;
}

/* ================================================== */
/* ====== NOVOS ESTILOS PARA DESISTÊNCIA NO PLACAR ====== */
/* ================================================== */

/* Container para o indicador RET (para espaçamento) */
.ret-indicator-placar-container {
    display: inline-block;
    margin-right: 15px; /* Espaço entre RET e o nome */
    vertical-align: middle; /* Alinha com o nome */
}


/* Estilo do próprio indicador RET (copiado do .ret-indicator original) */
.ret-indicator-placar {
    display: inline-block;
    background-color: #dc3545; /* Vermelho */
    color: white;
    font-size: 0.8em; /* Menor que o nome */
    font-weight: bold;
    padding: 3px 6px;
    border-radius: 4px;
    vertical-align: middle; /* Alinha verticalmente */
}

/* Estilo para o motivo da desistência (baseado no .motivo-resultado) */
.motivo-resultado-placar {
    display: none; /* Começa oculto */
    text-align: center;
    font-size: 1em; /* Tamanho um pouco maior para o placar */
    font-style: italic;
    color: #aaa; /* Cor mais clara para o fundo escuro */
    margin-top: 15px; /* Espaço acima do motivo */
    margin-bottom: 0;
}



/* Ajuste para celular */
@media (max-width: 600px) {
    .ret-indicator-placar-container {
        margin-right: 8px; /* Menos espaço no celular */
    }
	
	.placar-jogador-posicao { 
		font-size: 1.0em;
	}
	
    .ret-indicator-placar {
        font-size: 0.7em;
        padding: 2px 4px;
    }
    .motivo-resultado-placar {
        font-size: 0.9em;
        margin-top: 10px;
    }
	.placar-jogador-linha {
        padding: 18px 0px; /* Menos padding horizontal e vertical */
    }
	.placar-ao-vivo-content {
        padding-left: 0px;  /* Ou 2px, ou 0px para testar */
        padding-right: 0px; /* Ou 2px, ou 0px para testar */
        width: 100%;
        box-sizing: border-box;
    }
}



/* ================================================== */
/* ====== FIM DOS NOVOS ESTILOS PARA DESISTÊNCIA ====== */
/* ================================================== */

/* ========================================================== */
/* ====== ESTILO PARA A DECLARAÇÃO DO VENCEDOR ====== */
/* ========================================================== */

.placar-vencedor-declaracao {
    display: none; /* Começa oculto */
    font-size: 1.5em;
    font-weight: bold;
    color: #ffc107; /* Amarelo dourado */
    margin-bottom: 10px;
    
}

.placar-jogador-nome.match-winner {
    font-weight: 700;  /* Mantém o mesmo peso do set vencedor (que já é 700) */
    color: #ffffff;  /* Altera a cor para branco, igual ao set vencedor */
}

/* Ajuste para celular */
@media (max-width: 600px) {
    .placar-vencedor-declaracao {
        font-size: 1.2em;
    }
}

/* Regra para celular na vertical (portrait) - CORREÇÃO DE ALINHAMENTO V2 */
@media (max-width: 600px) {
    
    /* 1. Cabeçalho Compacto */
    .placar-header-novo h2 { font-size: 1.4em; }
    .placar-header-novo p { font-size: 0.9em; }

    /* 2. Container da Linha: Reduz espaçamentos para caber tudo */
    .placar-ao-vivo-content { padding: 10px 5px !important; }
    .placar-jogador-linha { 
        padding: 10px 2px !important; 
        gap: 2px !important;
        height: 55px !important; /* Altura fixa para manter alinhamento */
    }

    /* 3. Bolinha (Reduzida) */
    .placar-server-ball {
        width: 10px !important;
        height: 10px !important;
        margin-right: 5px !important;
        flex-shrink: 0;
    }

    /* 4. Nome do Jogador (O Grande Vilão resolvido) */
    .placar-jogador-nome { 
        font-size: 1.3em !important; 
        white-space: nowrap !important;     /* OBRIGATÓRIO: Impede quebra de linha */
        overflow: hidden !important;        /* Esconde o excesso */
        text-overflow: ellipsis !important; /* Adiciona "..." no final */
        flex-grow: 1 !important;            /* Ocupa o espaço que sobrar */
        min-width: 0 !important;            /* Permite encolher abaixo do conteúdo */
        margin-right: 5px !important;
        line-height: 1.5 !important;
    }

    /* 5. Sets (Jogou mais para a direita) */
    .placar-sets-container { 
        gap: 4px !important;       /* Reduz o buraco entre os sets */
        flex-shrink: 0 !important; /* Impede que os sets sejam esmagados */
    }
    .placar-set { 
        font-size: 1.4em !important; 
        width: 20px !important; /* Largura fixa menor */
    }

    /* 6. PONTOS (Ajuste crucial que faltava) */
    .placar-points {
        font-size: 1.4em !important; 
        width: 35px !important;      /* Reduz de 70px para 35px (cabe na tela) */
        margin-left: 5px !important;
        margin-right: 0 !important;
        text-align: center !important;
        flex-shrink: 0 !important;
    }

    /* 7. Ajustes menores */
    .placar-jogador-posicao {
        font-size: 0.9em !important;
        width: 20px !important;
        margin-right: 0px !important;
    }
    .ret-indicator-placar-container {
        margin-right: 5px !important;
    }
    .wo-indicator {
        font-size: 1.3em !important;
    }
}




/* ====== NOVOS ESTILOS PARA O INDICADOR W.O. DE PLACAR  ====== */

/* Estilo para o texto "W.O." em si */
.wo-indicator {
    font-size: 1.9em;     /* Ajuste o tamanho (original dos sets era 3em) */
    font-weight: 700;     /* Deixa em negrito (mesmo peso do set vencedor) */
    color: #FFC107;       /* Cor amarelada para destaque (pode escolher outra) */
    width: auto;          /* Largura automática baseada no texto */
    text-align: center;   /* Centraliza o texto dentro do span */
    /* Remove a largura fixa que os números dos sets tinham */
    min-width: 0;         /* Permite que seja mais estreito que os números */
}

/* Estilo para o CONTAINER PAI quando contém "W.O." */
.placar-sets-container.contains-wo {
    justify-content: flex-end; /* Alinha o "W.O." à DIREITA (como na imagem detalhes-da-reserva-8.jpg) */
    /* Outras opções de alinhamento: */
    /* justify-content: center; */ /* Para centralizar o "W.O." */
    /* justify-content: flex-start; */ /* Para alinhar à esquerda */
}

/* Ajuste opcional para celular na vertical, se necessário */
@media (max-width: 600px) {
    .wo-indicator {
        font-size: 1.3em; /* Fonte um pouco menor no celular vertical */
    }
}



/* === ESTILOS PARA LEGENDA RECOLHÍVEL === */
.header-legenda-container {
    padding: 0 10px;
    margin-bottom: 10px;
    
    position: sticky;
    /* 60px (Header) + 55px (Abas) = 115px */
    top: 100px; 
    z-index: 1090;
    background-color: white;
    
    margin-top: 10px; 
    transition: margin-top 0.4s ease-out;
}
.header-legenda-linha {
    display: flex;
    justify-content: space-between; /* Título à esquerda, Legenda à direita */
    align-items: center; /* Alinha verticalmente */
    margin-bottom: 5px; /* Pequeno espaço antes da legenda expandida */
}

/* Ajusta o título para não ter margem extra */
.header-legenda-container .header {
    margin: 0;
    font-size: 20px;
    flex-grow: 1; /* Permite que o título ocupe o espaço disponível */
    margin-right: 15px; /* Espaço entre o título e o "Legenda:" */
}

.legenda-trigger {
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    color: #555; /* Cor padrão do texto */
    white-space: nowrap; /* Impede que "Legenda: ▼" quebre linha */
    user-select: none; /* Evita seleção de texto ao clicar */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

body.dark-mode .legenda-trigger {
    color: #ccc; /* Cor no modo escuro */
}

#legenda-icone {
    display: inline-block;
    transition: transform 0.2s ease-in-out; /* Animação suave da seta */
}

.legenda-trigger.expandido #legenda-icone {
    transform: rotate(180deg); /* Gira a seta para ▲ */
}

.legenda-conteudo {
    display: none; /* Começa oculto */
    padding: 10px;
    border: 1px solid #eee;
    border-radius: 5px;
    background-color: #f9f9f9;
    margin-top: 5px; /* Espaço entre o trigger e o conteúdo */
}

body.dark-mode .legenda-conteudo {
    border-color: #444;
    background-color: #2a2a2a;
}

/* --- NOVOS ESTILOS PARA LEGENDA INTERNA EM LINHA ÚNICA --- */

/* Título "Legenda:" dentro do conteúdo */
.legenda-conteudo strong {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
}

/* Container que segura todos os itens da legenda */
.legenda-itens-linha-unica {
    display: flex; /* Coloca os itens lado a lado */
    flex-wrap: wrap; /* Permite quebrar linha em telas MUITO pequenas */
    align-items: center; /* Alinha verticalmente */
    gap: 15px; /* Espaço HORIZONTAL entre os itens da legenda */
}

/* Estilo para cada par ÍCONE + TEXTO */
.legenda-item {
    display: inline-flex; /* Faz o ícone e o texto ficarem juntos na linha */
    align-items: center; /* Alinha ícone e texto verticalmente */
    gap: 4px; /* Espaço PEQUENO entre o ícone e o texto */
}

/* Estilo para o QUADRADO colorido (ícone) */
.legenda-icone-cor {
    display: inline-block;
    width: 15px;
    height: 15px; /* Deixa quadrado */
    border: 1px solid rgba(0,0,0,0.1); /* Borda sutil opcional */
}

/* Estilo para o TEXTO da legenda */
.legenda-texto {
    font-size: 12px;
}
/* --- FIM DOS NOVOS ESTILOS --- */

/* === FIM DOS ESTILOS === */


/* --- ESTILOS PARA O NOVO BOTÃO FLUTUANTE (FAB) --- */
#fab-toggle-form {
    position: fixed;
    bottom: 20px;
    left: 20px; /* Canto inferior esquerdo */
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: #4CAF50; /* Cor verde principal */
    color: white;
    border: none;
    font-size: 30px; /* Tamanho do ícone '+' */
    font-weight: bold;
    
    cursor: pointer;
    z-index: 9001; /* ALTERADO DE 1001 PARA 9001 */
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    
    /* Transição para a futura animação do ícone */
    transition: background-color 0.3s ease, transform 0.3s ease-in-out; 
    outline: none;
	/* --- LINHAS ADICIONADAS PARA CENTRALIZAÇÃO PERFEITA --- */
    display: flex;           /* Ativa o Flexbox */
    align-items: center;     /* Centraliza verticalmente */
    justify-content: center; /* Centraliza horizontalmente */
    /* --- FIM DAS LINHAS ADICIONADAS --- */
}

/* Estilo do botão QUANDO o painel estiver visível */
#fab-toggle-form.active {
    background-color: #dc3545; /* Vermelho (cor "danger" que você já usa) */
    transform: rotate(45deg);  /* Gira o '+' para formar um 'X' */
}

@media (max-width: 600px) {
  #fab-toggle-form.active {
		background-color: #dc3545 !important; /* Vermelho (cor "danger" que você já usa) */
		transform: rotate(45deg);  /* Gira o '+' para formar um 'X' */
	}
}

#fab-toggle-form:hover {
    background-color: #45a049; /* Verde mais escuro */
}

/* Efeito de clique */
#fab-toggle-form:active {
    transform: scale(0.95);
}

#fab-toggle-form:focus {
    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.5); /* Aura verde (acessibilidade) */
}


/* ======================================= */
/* === ESTILOS PARA AGENDA RECOLHÍVEL === */
/* ======================================= */

.agenda-trigger {
    font-size: 16px; /* Tamanho do texto/ícone */
    font-weight: bold;
    cursor: pointer;
    color: #555; /* Cor padrão */
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    
    /* Alinha o 📅 e o ▼ */
    display: flex;
    align-items: center;
    gap: 5px;
}

body.dark-mode .agenda-trigger {
    color: #ccc; /* Cor no modo escuro */
}

#agenda-icone {
    display: inline-block;
    transition: transform 0.2s ease-in-out; /* Animação suave da seta */
    font-size: 14px; /* Deixa a seta um pouco menor que o 📅 */
}

/* Gira a seta quando o painel estiver aberto */
.agenda-trigger.expandido #agenda-icone {
    transform: rotate(180deg);
}

/* O painel expansível da agenda */
.agenda-conteudo {
    display: none; /* Começa oculto */
    padding: 15px; /* Mais espaço interno que a legenda */
    border: 1px solid #eee;
    border-radius: 5px;
    background-color: #f9f9f9;
    margin-top: 5px;
    margin-bottom: 10px; /* Espaço antes da tabela */
}

body.dark-mode .agenda-conteudo {
    border-color: #444;
    background-color: #2a2a2a;
}

/* Estilos para o conteúdo interno do painel da agenda */
.agenda-info p {
    margin: 4px 0;
    font-size: 1.05em;
    line-height: 1.5;
}
.agenda-info strong {
    display: inline-block;
    min-width: 80px; /* Alinha os campos "Quadra:", "Data:", etc. */
}

/* Estilo para a mensagem "Nenhuma reserva" */
.agenda-nenhuma-reserva {
    text-align: center;
    font-size: 1.05em;
    font-style: italic;
    color: #888;
    margin: 5px 0;
}

body.dark-mode .agenda-nenhuma-reserva {
    color: #aaa;
}

/* Destaque para jogos "Hoje" */
.agenda-hoje-destaque {
    color: #4CAF50;
    font-weight: bold;
}
body.dark-mode .agenda-hoje-destaque {
    color: #66BB6A;
}
/* ======================================= */
/* === FIM DE ESTILOS PARA AGENDA RECOLHÍVEL === */
/* ======================================= */


/* ======================================= */
/* === ESTILOS PARA TÍTULO RESPONSIVO === */
/* ======================================= */

/* Estilo para o subtítulo (ex: " - Coberta") */
.header-sub {
    /* Mantém o subtítulo visível por padrão (Desktop e Celular Horizontal) */
    display: inline;
    font-size: 0.9em; /* Opcional: deixa o subtítulo um pouco menor */
    color: #888;
}

/* Modo escuro para o subtítulo */
body.dark-mode .header-sub {
    color: #aaa;
}

/* * ESTA É A REGRA PRINCIPAL
 * Esconde o subtítulo APENAS em telas pequenas (celular) E
 * APENAS quando o celular estiver na vertical (portrait).
 */
@media (max-width: 600px) and (orientation: portrait) {
    .header-sub {
        display: none; /* Esconde o " - Coberta" */
    }
    
    .header-main {
        /* Opcional: Centraliza o "Quadra 1" quando o subtítulo some */
        width: 100%;
        text-align: center;
    }

    /* Ajuste para alinhar os ícones 📅 e ▼ no celular vertical */
    .header-legenda-linha {
        justify-content: space-between;
    }
	
	
	.header-legenda-container {
		/* Controla a altura do espaço em branco */
		padding-top: 5px !important;    /* Espaço acima do texto */
		padding-bottom: 5px !important; /* Espaço abaixo da legenda */
		
		/* Mantém a margem que colamos na tabela anteriormente */
		margin-bottom: 2px !important;
	}
	
		
    .header-legenda-container .header {
        flex-grow: 0; /* Impede o título de ocupar espaço extra */
    }
	/* --- AJUSTE MODAL DETALHES (CELULAR VERTICAL) --- */
        
        .modal-player-name {
            white-space: nowrap;     /* Impede a quebra de linha do NOME */
            overflow: hidden;          /* Esconde o texto que transbordar */
            text-overflow: ellipsis;   /* Adiciona "..." no NOME */
            flex-grow: 1;            /* Permite que o nome cresça */
            min-width: 0;              /* Permite que o nome encolha */
            padding-right: 10px;       /* Espaço entre o nome e o status */
        }

        /* --- FIM DO AJUSTE --- */
		
	/* --- AJUSTE RESULTADO DUPLAS (CELULAR VERTICAL) --- */
    .dupla-name-item {
        white-space: nowrap;       /* Impede que o nome quebre em duas linhas */
        overflow: hidden;          /* Esconde o que passar da largura */
        text-overflow: ellipsis;   /* Adiciona os três pontinhos (...) */
        max-width: 110px;          /* Define uma largura máxima segura */
        margin: 0 auto;            /* Centraliza o nome */
        line-height: 1.3;          /* Espaçamento entre os dois nomes */
    }
    
    /* Ajuste extra para dar mais espaço aos nomes */
    #modal-resultado-placar .matchup-row .team-names {
        flex-basis: 38% !important; /* Aumenta um pouco o espaço dos nomes */
    }
    #modal-resultado-placar .matchup-row .score-input-container {
        flex-basis: 24% !important; /* Ajusta o espaço do placar */
    }
    /* --- FIM DO AJUSTE --- */
}

/* ======================================= */
/* === FIM ESTILOS PARA TÍTULO RESPONSIVO === */
/* ======================================= */



/* ==================================================================== */
/* --- CORREÇÃO FINAL V3: Indicador Centralizado na Direita --- */
/* ==================================================================== */
.tab-button.live-game::after {
    content: '' !important;
    display: block !important;
    position: absolute;
    
    /* CENTRALIZAÇÃO VERTICAL PERFEITA */
    /* 50% da altura do botão MENOS metade da altura do ponto (4px) */
    top: calc(50% - 4px); 
    right: 8px; /* Distância da borda direita */
    
    /* TAMANHO DISCRETO */
    width: 8px;
    height: 8px;
    
    background-color: #ff4d4d;
    border-radius: 50%;
    border: 1.5px solid white;
    box-shadow: 0 0 4px rgba(255, 0, 0, 0.8);
    animation: pulse-live 1.5s infinite;
    z-index: 999;
}

/* Ajuste para o Modo Escuro */
body.dark-mode .tab-button.live-game::after {
    border-color: #333;
    box-shadow: 0 0 4px rgba(255, 60, 60, 0.8);
}
/* ==================================================================== */



/* Contador de Espectadores no Placar */
.espectadores-counter {
    color: #aaa; /* Cinza claro para não chamar muita atenção */
    font-size: 1.1em;
    display: inline-flex;
    align-items: center;
    gap: 6px; /* Espaço entre o ícone e o número */
    transition: all 0.3s ease;
}

/* Efeito sutil quando o número muda (opcional, mas fica legal) */
.espectadores-counter.mudou {
    color: #fff; /* Pisca em branco quando alguém entra/sai */
    transform: scale(1.1);
}
/* ==================================================================== */


/* ================================================================= */
/* --- CSS MODERNO PARA O MODAL DE RESULTADOS --- */
/* ================================================================= */

/* 1. O Container Principal */
.modern-modal {
    padding: 25px !important;
    border-radius: 24px !important; /* Cantos mais arredondados */
    max-width: 450px !important;
    background: #ffffff;
    font-family: 'Roboto', sans-serif; /* Garante a fonte moderna */
}

/* 2. Cabeçalho e Menu */

.modern-modal-header {
    /* --- O QUE VOCÊ JÁ TEM (MANTENHA) --- */
    display: flex;
    justify-content: center;
    align-items: center;
	
    margin-bottom: 20px;
    position: relative;

    /* --- O QUE PRECISA ADICIONAR (PARA CENTRALIZAR O TÍTULO) --- */
    /* Isso garante que o título fique no meio exato, independente dos botões laterais */
    padding-right: 50px; /* Espaço reservado para o botão Menu */
    padding-left: 50px;  /* Espaço reservado para o botão Fullscreen (simetria) */
    min-height: 40px;    /* Garante altura para os botões */
}
.modern-modal-header h3 {
    margin: 0;
    font-size: 1.4rem;
    font-weight: 800;
    color: #2c3e50;
    /* CORREÇÃO: Garante que o texto em si fique centralizado, permitindo que o flexbox ocupe o espaço */
    text-align: center;
    flex-grow: 1; 
}
/* Ajuste no botão de três pontinhos para ficar mais elegante */
#btn-mais-opcoes {
    background: transparent !important;
    color: #95a5a6 !important;
    font-size: 26px !important;
    width: 40px !important;
    height: 40px !important;
    padding: 8px !important;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50% !important;
    transform: translateY(-50%);
    transition: all 0.2s ease;
	position: absolute !important;
	top: 50%;
    right: -10px; /* Alinha com a margem direita */
	margin-top: -1px;
}
#btn-mais-opcoes:hover {
    background-color: #f5f6fa !important;
    color: #2c3e50 !important;
}







@keyframes slideDown {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}



/* 7. Super Tie-break (3º Set) - Destaque Especial */



/* 8. Display do Vencedor Final */
.winner-display {
    background: #e8f8f5;
    border: 2px solid #d1f2eb;
    border-radius: 16px;
    padding: 15px;
    text-align: center;
	margin-top: 0px;
    margin-bottom: 5px;
}
.winner-label {
    display: block;
    font-size: 0.75rem;
    font-weight: 900;
    color: #1abc9c;
    letter-spacing: 1.2px;
    margin-bottom: 5px;
}

.winner-name {
    font-size: 1.2rem; /* Reduzido de 1.5rem */
    font-weight: 800;
    color: #16a085;
}

/* 9. Botões de Ação Modernos (ATUALIZADO) */

.modern-actions {
    display: flex;
    gap: 15px;
    width: 100%; /* Garante que o container ocupe a largura total */
}

/* Estilo Base do Botão: Tamanho TRAVADO em 50px */
.btn-modern {
    flex: 1;                      /* Cada botão ocupa 50% do espaço */
    height: 50px !important;      /* Altura fixa (não muda com o texto) */
    padding: 0 !important;        /* Remove padding interno que poderia alterar a altura */
    font-size: 1rem !important;
    font-weight: 700 !important;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px !important;
    border: none !important;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    transition: background-color 0.3s ease, transform 0.1s ease !important;
}

/* Efeito de clique */
.btn-modern:active {
    transform: scale(0.97);
}

/* Cores Padrão (Mantendo o que você já tinha) */
.btn-save {
    /* A cor será definida dinamicamente pelo JS, mas o padrão é verde */
    background-color: #28a745; 
    color: white;
    box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
}
.btn-cancel {
    background-color: #6c757d !important; /* Cinza Escuro (#6c757d) */
    color: white !important;               /* Texto Branco */
}
.btn-cancel:hover {
    background-color: #5a6268 !important; /* Um pouco mais escuro no hover */
    color: white !important;
}

/* --- NOVOS ESTADOS VISUAIS (Para o Modo Arbitragem) --- */

/* Estado: Salvando... (Azul, cursor de espera) */
.btn-status-saving {
    background-color: #3498db !important; /* Azul */
    color: white !important;
    opacity: 0.9;
    pointer-events: none; /* Bloqueia cliques */
    cursor: wait !important;
}

/* Estado: Salvo ✓ (Cinza, indicando repouso) */
.btn-status-saved {
    background-color: #95a5a6 !important; /* Cinza Concreto */
    color: white !important;
    pointer-events: none; /* Bloqueia cliques */
}

/* Estado: MATCH POINT (Laranja Pulsante) */
.btn-status-matchpoint {
    background-color: #f39c12 !important; /* Laranja */
    color: white !important;
    animation: pulse-orange 1.5s infinite; /* Ativa a animação */
    pointer-events: none; /* Apenas visual */
}

/* Animação de Pulsar */
@keyframes pulse-orange {
    0% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(243, 156, 18, 0); }
    100% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0); }
}

/* 10. Estilos para os selects modernos (W.O./Desistência) */
.modern-form-group {
    margin-bottom: 20px;
}
/* Estilos para os labels de selects modernos (W.O./Desistência) */
.modern-form-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #7f8c8d;
    font-size: 0.9rem;
    
    /* CORREÇÃO CRÍTICA: Impede que a linha quebre */
    white-space: nowrap; 
    
    /* Garante que o label não seja espremido por regras flexbox */
    width: auto; 
    min-width: fit-content; 
}
.modern-select {
    width: 100% !important;
    padding: 12px 15px !important;
    border: 2px solid #ecf0f1 !important;
    border-radius: 12px !important;
    font-size: 1rem !important;
    background-color: #fff !important;
    color: #2c3e50;
    appearance: none; /* Remove estilo padrão do navegador */
    /* Adiciona uma setinha customizada */
    background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23BDC3C7%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
    background-repeat: no-repeat;
    background-position: right 15px top 50%;
    background-size: 12px auto;
}
.modern-select:focus {
    border-color: #3498db !important;
    outline: none;
}

/* ================================================================= */
/* --- ADAPTAÇÃO COMPLETA PARA O MODO ESCURO --- */
/* ================================================================= */
body.dark-mode .modern-modal {
    background-color: #2c3e50 !important;
    color: #ecf0f1;
}
body.dark-mode .modern-modal-header h3 {
    color: #ecf0f1;
}
body.dark-mode #btn-mais-opcoes {
    color: #7f8c8d !important;
}
body.dark-mode #btn-mais-opcoes:hover {
    background-color: #34495e !important;
    color: #ecf0f1 !important;
}


body.dark-mode .set-card {
    background-color: #34495e;
    border-color: #455a64;
}
body.dark-mode .set-card:focus-within {
    border-color: #1abc9c;
}





body.dark-mode .tb-tile {
    background-color: #2c3e50;
    border-color: #455a64 !important;
    color: #bdc3c7;
}
body.dark-mode .set-card.super-tiebreak {
    background-color: #4e342e; /* Marrom escuro para destaque */
    border-color: #6d4c41;
}

body.dark-mode .set-card.super-tiebreak .score-tile {
    background-color: #3e2723;
    border-color: #ffb74d !important;
}
body.dark-mode .winner-display {
    background-color: #145a32; /* Verde escuro */
    border-color: #1e8449;
}
body.dark-mode .winner-label {
    color: #2ecc71;
}
body.dark-mode .winner-name {
    color: #fff;
}
body.dark-mode .btn-cancel {
    background-color: #4e5d6c !important; /* Cinza levemente azulado para o tema escuro */
    color: white !important;
}
body.dark-mode .btn-cancel:hover {
    background-color: #3e4b57 !important;
}
body.dark-mode .modern-form-group label {
    color: #bdc3c7;
}
body.dark-mode .modern-select {
    background-color: #34495e !important;
    border-color: #455a64 !important;
    color: #ecf0f1;
}

/* ================================================================= */
/* --- FIM DE CSS MODERNO PARA O MODAL DE RESULTADOS --- */
/* ================================================================= */



/* ================================================================= */
/* Estilo para os inputs do modal de convidados */
.convidado-nome-input {
    width: 100%;
    padding: 10px;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 5px;
    box-sizing: border-box; /* Garante que o padding não estoure a largura */
}

body.dark-mode .convidado-nome-input {
    background-color: #333;
    color: #fff;
    border-color: #555;
}
/* --- INÍCIO DA CORREÇÃO (Etapa 7) --- */
/* Aplica o estilo base (sem bullets) para a lista de convidados */
#modal-convidados ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}

/* Aplica a linha separadora em cada item da lista de convidados */
#modal-convidados li {
    padding: 5px 0;
    border-bottom: 1px solid #f0f0f0;
}
#modal-convidados li:last-child {
    border-bottom: none;
}

/* Garante que a linha separadora funcione no Modo Escuro */
body.dark-mode #modal-convidados li {
    border-bottom-color: #444;
}

/* Estilo para a convidado nomeado (ex: "Joao Maria") */
.convidado-nomeado-option {
    font-style: italic;
    color: #000000; /* Preto */
}

/* Estilo para o <select> QUANDO um convidado nomeado está selecionado */
.edit-jogador-row select.select-convidado-nomeado {
    font-style: italic;
}

/* Garante o estilo no Modo Escuro */
body.dark-mode .convidado-nomeado-option {
    color: #FFFFFF !important; /* Branco (com !important para garantir) */
    background-color: #333; /* Fundo escuro para a opção */
}


/* --- FIM DA CORREÇÃO --- */
/* ================================================================= */


/* ================================================================= */
/* --- NOVO LAYOUT: SCOREBOARD (TABELA) --- */
/* ================================================================= */

.scoreboard-container {
    display: flex;
    flex-direction: column;
    gap: 8px; /* Espaço entre as linhas dos jogadores */
    margin-bottom: 20px;
    font-family: 'Roboto', sans-serif;
    padding: 0 5px;
}

/* Classe para ocultar Sets futuros */
.sb-hidden {
    display: none !important;
}

/* --- Cabeçalho da Tabela --- */
.sb-header {
    display: flex;
    align-items: center;
    padding: 0 10px;
    margin-bottom: 5px;
}

.sb-col-name {
    flex-grow: 1; /* Ocupa o espaço restante à esquerda */
    font-size: 0.7rem;
    font-weight: 700;
    color: #95a5a6;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.sb-col-set {
    width: 38px; /* Largura fixa das colunas de set */
    text-align: center;
    font-size: 0.7rem;
    font-weight: 700;
    color: #95a5a6;
}

.sb-col-points {
    width: 100px; /* Largura da área de botões */
    text-align: center;
    font-size: 0.7rem;
    font-weight: 700;
    color: #3498db; /* Azul destaque */
    margin-left: 5px;
}

/* --- Linha do Jogador --- */
.sb-row {
    display: flex;
    align-items: center;
    background-color: #f8f9fa;
    border-radius: 12px;
    padding: 10px 5px; /* Mais altura para facilitar o toque */
    border: 1px solid #eee;
    transition: all 0.2s ease;
}

/* Nome do Jogador (Ajuste de Alinhamento Definitivo) */
.sb-name {
    /* MUDANÇA CRÍTICA: flex: 1 1 0;
       1 = pode crescer
       1 = pode encolher
       0 = começa com tamanho zero (ignora o tamanho do texto para o cálculo inicial) 
    */
    flex: 1 1 0 !important; 
    
    min-width: 0 !important; /* Permite encolher abaixo do conteúdo */
    font-size: 1rem;
    font-weight: 500;
    color: #2c3e50;
    
    /* Garante que o texto corte com ... */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    
    margin-right: 5px;
    padding-left: 5px;
    cursor: pointer;
    transition: color 0.2s;
}

/* --- Inputs dos Games (Sets) --- */
.sb-input {
    width: 34px !important;
    height: 34px !important;
    text-align: center;
    font-size: 1.0rem !important; /* Reduzido de 1.1rem para 1.0rem */
    font-weight: 600 !important;  /* Reduzido de 700 (Bold) para 600 (Semi-bold) */
    border: 1px solid #ddd !important;
    border-radius: 6px !important;
    background-color: #fff;
    margin-left: 4px;
    padding: 0 !important;
    color: #333;
    /* Remove setas do input number */
    -moz-appearance: textfield; 
}
.sb-input::-webkit-outer-spin-button,
.sb-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

.sb-input:focus {
    border-color: #3498db !important;
    outline: none;
    background-color: #f0f8ff;
    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

.sb-input:disabled {
    background-color: #f0f0f0;
    border-color: transparent !important;
    color: #ccc;
}

/* Destaque para o Super Tie-break (3º set) */
.sb-input.super-tb:not(:disabled) {
    background-color: #fffbf2;
    border-color: #f39c12 !important;
    color: #d35400;
}

/* --- Controle de Pontos (O Controle Remoto) --- */
.sb-points-control {
    width: 100px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-left: 8px;
    background-color: #fff;
    border-radius: 20px;
    padding: 2px;
    border: 1px solid #e0e0e0;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

/* Botões + e - */
.btn-point {
    width: 28px !important;
    height: 28px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-weight: bold;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
    padding: 0 !important;
    margin: 0 !important;
    line-height: 1;
}

.btn-point.minus {
    background-color: #fff;
    color: #e74c3c; /* Vermelho */
}
.btn-point.minus:hover { background-color: #fcebe9; }

.btn-point.plus {
    background-color: #e8f6f3;
    color: #2ecc71; /* Verde */
}
.btn-point.plus:hover { background-color: #d5f5e3; }

/* Mostrador de Pontos (15, 30, 40) */
.point-display {
    flex-grow: 1;
    text-align: center;
    font-size: 1.2rem;
    font-weight: 900;
    color: #2c3e50;
    user-select: none;
}

/* --- MODO ESCURO --- */
body.dark-mode .sb-row { background-color: #34495e; border-color: #455a64; }
body.dark-mode .sb-name { color: #ecf0f1; }
body.dark-mode .sb-input { background-color: #2c3e50; border-color: #555 !important; color: #fff; }
body.dark-mode .sb-input:disabled { background-color: #34495e; color: #555; border-color: transparent !important; }
body.dark-mode .sb-points-control { background-color: #2c3e50; border-color: #555; }
body.dark-mode .point-display { color: #fff; }
body.dark-mode .btn-point.minus { background-color: #2c3e50; color: #e74c3c; }
body.dark-mode .btn-point.plus { background-color: #2c3e50; color: #2ecc71; }
body.dark-mode .sb-col-name, body.dark-mode .sb-col-set { color: #bdc3c7; }
body.dark-mode .sb-input.super-tb:not(:disabled) { background-color: #4e342e; border-color: #f39c12 !important; color: #f39c12; }


/* ================================================================= */
/* === SUPER MASTER: MODO CELULAR NA HORIZONTAL (TELA CHEIA) === */
/* ================================================================= */
@media (orientation: landscape) and (max-height: 600px) {
    
    /* --- 1. JANELA DO MODAL (ESTRUTURA) --- */
    #modalResultadoPiramide .modern-modal {
        position: fixed !important;
        top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important;
        width: 100vw !important; max-width: none !important; max-height: none !important;
        margin: 0 !important; border-radius: 0 !important; padding: 5px 15px 10px 15px !important; 
        overflow-y: auto !important; z-index: 99999 !important; box-sizing: border-box !important;
        background-color: white !important; display: block !important;
    }
    body.dark-mode #modalResultadoPiramide .modern-modal { background-color: #2c3e50 !important; }

    /* Cabeçalho */
    #modalResultadoPiramide .modern-modal-header {
        margin-bottom: 5px !important; margin-top: 2px !important; min-height: 25px !important;
        position: relative !important;
    }
    #modalResultadoPiramide .modern-modal-header h3 { font-size: 1.1rem !important; }

    /* --- 2. CORREÇÃO DA DUPLICAÇÃO AQUI --- */
    /* Removemos o 'display: block' forçado para respeitar o JS */
    #modalResultadoPiramide .scoreboard-container,
    #modalResultadoPiramide #simple-score-container {
        margin-bottom: 5px !important;
        gap: 4px !important; 
        width: 100% !important; /* Garante largura total */
    }
    
    /* GARANTIA: Se o JS mandou esconder (style="display: none"), o CSS obedece */
    #modalResultadoPiramide .scoreboard-container[style*="none"],
    #modalResultadoPiramide #simple-score-container[style*="none"] {
        display: none !important;
    }

    /* Linhas e Inputs */
    #modalResultadoPiramide .sb-row, #modalResultadoPiramide .simple-row {
        padding: 2px 5px !important; min-height: 35px !important; margin-bottom: 5px !important;
    }
    #modalResultadoPiramide .sb-input, #modalResultadoPiramide .simple-input {
        height: 28px !important; width: 35px !important; font-size: 1rem !important;
    }
    #modalResultadoPiramide .btn-point { width: 26px !important; height: 26px !important; }

    /* Botões e Painéis Menores */
    #modalResultadoPiramide .modern-actions {
        margin-top: 5px !important; margin-bottom: 20px !important; gap: 10px !important;
    }
    #modalResultadoPiramide .btn-modern {
        padding: 0 !important; height: 35px !important; font-size: 0.9rem !important;
        line-height: 35px !important; display: flex; align-items: center; justify-content: center;
        margin-bottom: 5px !important;
    }
    #wo-controls .modern-form-group, #desistencia-controls .modern-form-group { margin-bottom: 5px !important; }
    #wo-controls label, #desistencia-controls label { margin-bottom: 0px !important; font-size: 0.85rem !important; }
    #modalResultadoPiramide .winner-display {
        padding: 2px 10px !important; margin-top: 2px !important; margin-bottom: 5px !important; min-height: 38px !important; 
    }
    #btn-fullscreen-toggle { left: 0 !important; top: 50% !important; transform: translateY(-50%) !important; }

    /* --- 3. PLACAR AO VIVO --- */
    .placar-ao-vivo-content { height: 100%; padding: 5px 20px; justify-content: center; }
    .placar-header-novo { margin-bottom: 10px; }
    .placar-header-novo h2 { font-size: 1.3em; }
    .placar-header-novo p { font-size: 0.9em; }
    .placar-jogador-linha { padding: 8px 15px; }
    .placar-jogador-nome { font-size: 1.6em; }
    .placar-jogador-posicao { font-size: 1.0em; margin-right: 1px; }
    .placar-set { font-size: 1.6em; width: 30px; }
    .placar-footer { margin-top: 15px; padding-top: 5px; }

    /* --- 4. DETALHES DA RESERVA (JOGO NORMAL) --- */
    .modal-content-reserva.modo-placar > p:not(.resultado-info),
    .modal-content-reserva.modo-placar #modal-organizador-container,
    .modal-content-reserva.modo-placar #modal-jogadores,
    .modal-content-reserva.modo-placar #container-convidados,
    .modal-content-reserva.modo-placar hr { display: none !important; }
    
    .modal-content-reserva.modo-placar #modal-resultado-container {
        display: block !important; margin-top: 5px !important; padding-top: 0px !important;
    }
    .modal-content-reserva.modo-placar #modal-resultado-container p {
        display: block !important; margin: 0 0 5px 0 !important; font-size: 1.0em !important;
    }
    .modal-content-reserva.modo-placar #modal-resultado-placar .placar-container {
        font-size: 1.2em !important;
    }

    /* Regras do Modo Normal */
    .modal-content-reserva.modo-normal .p-tecnico { display: none !important; }
    .modal-content-reserva.modo-normal hr {
        display: block !important; visibility: hidden !important; border: none !important;
        margin: 15px 0 !important; height: 1px !important;          
    }
    .modal-content-reserva.modo-normal h3 { font-size: 1.2em !important; margin: 0 0 5px 0 !important; }
    .modal-content-reserva.modo-normal #modal-status {
        display: inline !important; font-size: 1.1em !important; font-weight: bold !important; margin-bottom: 5px !important;
    }
    .modal-content-reserva.modo-normal #modal-jogadores { display: block !important; margin-top: 0 !important; }

    /* Elementos menores */
    .ret-indicator-placar { font-size: 0.7em !important; }
    .motivo-resultado-placar { font-size: 0.8em !important; margin-top: 5px !important; }
    .wo-indicator { font-size: 1.5em !important; }
}
/* ================================================================= */
/* === FIM DE SUPER MASTER: MODO CELULAR NA HORIZONTAL (TELA CHEIA) === */
/* ================================================================= */





/* --- ITEM DE TOGGLE DENTRO DO MENU --- */
.menu-toggle-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    cursor: default; /* O clique será no switch */
}

.menu-toggle-item span {
    font-size: 0.95rem;
    color: #333;
    font-weight: 600;
}

.menu-divider {
    border: 0;
    border-top: 1px solid #eee;
    margin: 0;
}

/* Switch Pequeno para Menu */
.toggle-switch-menu {
    position: relative;
    display: inline-block;
    width: 34px;
    height: 18px;
}

.toggle-switch-menu input { 
    opacity: 0;
    width: 0;
    height: 0;
}

.slider-menu {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 34px;
}

.slider-menu:before {
    position: absolute;
    content: "";
    height: 14px;
    width: 14px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider-menu {
    background-color: #2ecc71;
}

input:checked + .slider-menu:before {
    transform: translateX(16px);
}

/* Modo Escuro */
body.dark-mode .menu-toggle-item span { color: #ecf0f1; }
body.dark-mode .menu-divider { border-top-color: #555; }

/* ---  FIM DE ITEM DE TOGGLE DENTRO DO MENU --- */


/* --- INDICADOR DE SACADOR (BOLINHA) --- */

/* O espaço reservado para a bolinha (entre o nome e o set) */
.sb-server-marker {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 2px; /* Um respiro antes do input */
}

/* A bolinha em si */
.server-ball {
    width: 12px;
    height: 12px;
    background-color: #ccff00; /* Amarelo Tênis Neon */
    border-radius: 50%;
    border: 1px solid #99cc00; /* Borda sutilmente mais escura */
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    position: relative;
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* (Opcional) Desenho da curva da bola de tênis com CSS puro */
.server-ball::after {
    content: '';
    position: absolute;
    top: 2px; left: 2px;
    width: 6px; height: 6px;
    border-radius: 50%;
    border-top: 1px solid rgba(0,0,0,0.2);
    border-left: 1px solid rgba(0,0,0,0.2);
    transform: rotate(45deg);
}

/* Efeito de clique no nome */
.sb-name {
    cursor: pointer; /* Mãozinha para indicar que é clicável */
    transition: color 0.2s;
}
.sb-name:active {
    color: #2ecc71; /* Pisca verde ao clicar */
}

/* Animação de entrada */
@keyframes popIn {
    from { transform: scale(0); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}
/* --- FIM DE INDICADOR DE SACADOR (BOLINHA) --- */


/* ================================================================= */
/* --- PARTE 1: ESTILO DO BADGE (NÚMERO PEQUENO) --- */
/* ================================================================= */

/* Container que segura o input e o número pequeno juntos */
.set-input-wrapper {
    position: relative;       /* Necessário para o número pequeno se alinhar a ele */
    display: inline-block;    /* Mantém o comportamento de linha */
    margin-left: 4px;         /* Espaçamento lateral igual ao do input original */
}

/* O estilo do número pequeno (Badge) */
.sb-tb-display {
    position: absolute;       /* Flutua sobre o input */
    top: -8px;                /* Sobe um pouco para ficar na borda superior */
    right: -5px;              /* Vai para a direita, meio fora do input */
    
    font-size: 0.7rem;        /* Tamanho pequeno e legível */
    font-weight: 900;         /* Bem negrito */
	
    /* --- MUDANÇAS AQUI --- */
    color: #333;            /* Texto Preto Suave */
    background-color: #fff; /* Fundo Branco */
    border: 1px solid #ccc; /* Borda Cinza (para não sumir no fundo) */
    /* --------------------- */
    
    padding: 1px 4px;         /* Espacinho interno */
    border-radius: 4px;       /* Cantos arredondados */
    pointer-events: none;     /* Permite clicar no input "através" dele */
    z-index: 10;              /* Garante que fique por cima de tudo */
    box-shadow: 1px 1px 2px rgba(0,0,0,0.3); /* Sombra leve para destacar */
    
    min-width: 12px;          /* Tamanho mínimo */
    text-align: center;
    line-height: 1.1;
}

/* Ajuste importante para esconder o conjunto inteiro quando necessário */
.set-input-wrapper.sb-hidden {
    display: none !important;
}

/* Ajuste para o Modo Escuro - Badge Clean (Alto Contraste) */
body.dark-mode .sb-tb-display {
    background-color: #e0e0e0; /* Um cinza muito claro (quase branco) para não ofuscar demais */
    color: #000000;            /* Texto preto para leitura fácil */
    border: 1px solid #555;    /* Borda para separar visualmente do input escuro */
    box-shadow: 0 1px 3px rgba(0,0,0,0.4); /* Sombra um pouco mais forte para dar profundidade */
}
/* Esconde o badge laranja se ele estiver vazio */
.sb-tb-display:empty {
    display: none;
}

/* ================================================================= */
/* --- FIM DEESTILO DO BADGE (NÚMERO PEQUENO) --- */
/* ================================================================= */


/* ================================================================= */
/* --- NOVO LAYOUT: SCOREBOARD (TABELA) --- */
/* ================================================================= */


/* ================================================================= */
/* --- ESTILO OPÇÃO 1: TIE-BREAK "SUPERSCRIPT" (FLUTUANTE) --- */
/* ================================================================= */

/* O Container que segura o par (Game + Tie-break) */
.simple-set-group {
    position: relative; /* Essencial para o número pequeno flutuar em relação a ele */
    display: flex;
    align-items: center;
    justify-content: center;
    width: 45px;
    margin-left: 2px;
}

/* O Input Principal (Game 6, 7...) */
.simple-input {
    width: 36px !important;
    height: 36px !important;
    font-size: 1.0rem !important; /* Reduzido de 1.2rem para 1.0rem */
    font-weight: 600 !important;  /* Adicionado peso 600 para ficar igual ao de cima */
    text-align: center;
    border-radius: 8px !important;
    border: 1px solid #ccc !important;
    background-color: #fff;
    z-index: 1;
    margin: 0 !important;
}

/* O Input de Tie-break (O "5" pequeno) */
.simple-tb-input {
    position: absolute;
    top: -8px;    /* Sobe para fora do quadrado principal */
    right: -8px;  /* Vai para a direita */
    
    width: 24px !important;  /* Tamanho do quadradinho */
    height: 24px !important;
    font-size: 0.85rem !important; /* Texto menor */
    font-weight: bold;
    text-align: center;
    padding: 0 !important;
    
    background-color: #fff;
    border: 1px solid #e0e0e0 !important; /* Cinza bem claro */
    color: #d35400;
    border-radius: 6px;
    
    z-index: 10; /* Fica por cima de tudo */
    box-shadow: 1px 1px 3px rgba(0,0,0,0.2); /* Sombra para dar profundidade */
    
    display: none; /* Começa invisível */
}

/* Animação suave quando aparece */
.simple-tb-input[style*="display: block"] {
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* Ajuste para Modo Escuro */
body.dark-mode .simple-tb-input {
    background-color: #2c3e50;
    color: #ffb74d;
    border-color: #d35400 !important;
}


/* ================================================================= */
/* === CSS ATUALIZADO: VISUALIZAÇÃO COM NEGRITO CORRETO === */
/* ================================================================= */

/* 1. Estilo BASE para campos desabilitados (Texto Normal) */
#placar-fields-container input:disabled,
#simple-score-container input:disabled {
    background-color: #ffffff !important;
    color: #000000 !important;
    -webkit-text-fill-color: #000000 !important;
    opacity: 1 !important;
    font-weight: 400 !important; /* Normal */
    border-color: #ddd !important;
    cursor: default !important;
}

/* 2. REGRA FORTE para o Vencedor (Negrito) */
/* Usamos o ID do container para garantir que essa regra vença a anterior */
#placar-fields-container input.input-winner:disabled,
#simple-score-container input.input-winner:disabled {
    font-weight: 900 !important; /* Negrito Forte */
    color: #000000 !important;
    border-color: #999 !important; /* Borda um pouco mais escura para destaque */
}

/* 3. Ajuste para os números pequenos do Tie-Break (Badges) */
.sb-tb-display, 
#simple-score-container .simple-tb-input:disabled {
    background-color: #f9f9f9 !important;
    color: #555 !important;
    font-weight: 400 !important; /* Normal */
    font-size: 0.9em !important;
    border: 1px solid #eee !important;
}

/* 4. Negrito para os números pequenos do Tie-Break */
.sb-tb-display.input-winner,
#simple-score-container .simple-tb-input.input-winner:disabled {
    font-weight: 900 !important; /* Negrito Forte */
    color: #000000 !important;
    background-color: #fff !important;
    border-color: #999 !important;
    z-index: 100 !important; /* Garante que fique bem visível */
}

/* Modo Escuro */
body.dark-mode #simple-score-container input.input-winner:disabled {
    background-color: #444 !important;
    color: #fff !important;
    font-weight: 900 !important;
    border-color: #777 !important;
}
/* ================================================================= */

/* ================================================================= */
/* === FIM CSS ATUALIZADO: MODO LEITURA + BOTÃO FECHAR + NEGRITO === */
/* ================================================================= */


/* ================================================================= */
/* === ESTILOS DO BOTÃO "X" (Igual ao Detalhes da Reserva) === */
/* ================================================================= */
#btn-fechar-visualizacao {
    display: none; /* Oculto por padrão */
    background: transparent;
    border: none;
    cursor: pointer;
    z-index: 101;
    
    /* Estilo idêntico ao .close-button */
    font-size: 28px;
    font-weight: bold;
    color: #aaa; /* Cinza claro */
    padding: 0;
    line-height: 1;
    transition: color 0.2s ease, transform 0.2s ease;
}

/* Efeito Hover (igual ao Detalhes) */
#btn-fechar-visualizacao:hover {
    color: #333; /* Cinza escuro */
    transform: translateY(-50%) scale(1.1); /* Mantém centralizado verticalmente e aumenta */
}

/* Ajuste para modo escuro */
body.dark-mode #btn-fechar-visualizacao {
    color: #888;
}
body.dark-mode #btn-fechar-visualizacao:hover {
    color: #f1f1f1; /* Branco no hover do modo escuro */
}
/* ================================================================= */
/* === FIM DE ESTILOS DO BOTÃO "X" (Igual ao Detalhes da Reserva) === */
/* ================================================================= */

/* Botão de Tela Cheia no Cabeçalho */
#btn-fullscreen-toggle {
    position: absolute;
    left: 0;            
    right: auto;        
    top: 50%;
    transform: translateY(-50%);
    
    /* --- AJUSTE DE ALINHAMENTO --- */
    margin-top: -3px !important; /* Sobe o botão levemente para alinhar com os 3 pontinhos */
    /* ----------------------------- */

    /* Estilo limpo */
    background: transparent;
    border: none;
    color: #95a5a6;
    font-size: 20px;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
}

#btn-fullscreen-toggle:hover {
    background-color: #f5f6fa !important;
    color: #2c3e50 !important;
}

/* Modo Escuro */
body.dark-mode #btn-fullscreen-toggle {
    color: #7f8c8d !important;
}
body.dark-mode #btn-fullscreen-toggle:hover {
    background-color: #34495e !important;
    color: #ecf0f1 !important;
}
/* FIM DE Botão de Tela Cheia no Cabeçalho */




/* ================================================================= */
/* === CORREÇÃO V15: VISIBILIDADE DOS CABEÇALHOS CORRIGIDA === */
/* ================================================================= */

/* 1. BOTÃO MAXIMIZAR */
#btn-fullscreen-toggle { display: none !important; }
@media screen and (orientation: landscape) and (max-height: 600px) {
    #btn-fullscreen-toggle {
        display: flex !important;
        position: absolute !important;
        left: 20px !important;
        z-index: 100 !important;
    }
}

/* 2. JANELA DO MODAL */
#modalResultadoPiramide.modo-cheio .modern-modal {
    width: 100vw !important;
    height: 100vh !important;
    max-width: none !important;
    max-height: none !important;
    border-radius: 0 !important;
    padding: 5px 25px !important;
    box-sizing: border-box !important;
    background-color: white !important;
    display: flex !important;
    flex-direction: column !important;
    overflow: hidden !important;
}

/* 3. CABEÇALHO */
#modalResultadoPiramide.modo-cheio .modern-modal-header {
    width: 100% !important;
    height: 40px !important;
    min-height: 40px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: space-between !important;
    position: relative !important;
    margin-bottom: 5px !important;
    padding: 0 !important;
}

#modalResultadoPiramide.modo-cheio .modern-modal-header h3 {
    position: absolute !important;
    left: 50% !important;
    top: 50% !important;
    transform: translate(-50%, -50%) !important;
    margin: 0 !important;
    font-size: 1.2rem !important;
    white-space: nowrap !important;
    z-index: 1 !important;
}

#modalResultadoPiramide.modo-cheio #btn-mais-opcoes {
    display: flex !important;
    position: absolute !important;
    right: 0 !important;
    top: 50% !important;
    transform: translateY(-50%) !important;
    z-index: 100 !important;
    background: transparent !important;
    font-size: 1.5rem !important;
    padding: 10px !important;
}

/* 4. CABEÇALHO DA TABELA (SETS E GAME) */
#modalResultadoPiramide.modo-cheio .sb-header {
    width: 100% !important;
    display: flex !important;
    justify-content: flex-end !important;
    padding: 0 0 !important;
    margin-bottom: 2px !important;
}

#modalResultadoPiramide.modo-cheio .sb-header .sb-col-name { display: none !important; }

/* REGRA GERAL PARA OS NÚMEROS (1, 2, 3) */
#modalResultadoPiramide.modo-cheio .sb-header .sb-col-set {
    width: 45px !important;
    text-align: center !important;
    font-size: 1rem !important;
    font-weight: bold !important;
    margin-left: 10px !important; 
    display: block !important;
}

/* --- REGRAS ESPECÍFICAS DE VISIBILIDADE (AQUI ESTÁ A CORREÇÃO) --- */

/* CASO 1 (SÚMULA): Esconde o '3' se o JS mandar (style="display:none") */
#modalResultadoPiramide.modo-cheio #simple-header-set3[style*="none"] {
    display: none !important;
}

/* CASO 2 (ARBITRAGEM): Esconde o '3' se tiver a classe .sb-hidden */
#modalResultadoPiramide.modo-cheio #header-set3.sb-hidden {
    display: none !important;
}

/* CASO 3 (ARBITRAGEM): FORÇA O '2' A APARECER (mesmo com .sb-hidden) */
#modalResultadoPiramide.modo-cheio #header-set2.sb-hidden {
    display: block !important;
}

/* ------------------------------------------------------------------ */

/* Título GAME (Arbitragem) */
#modalResultadoPiramide.modo-cheio .sb-header .sb-col-points {
    width: 110px !important;
    text-align: center !important;
    font-size: 0.8rem !important;
    font-weight: bold !important;
    margin-left: 10px !important;
    color: #3498db !important;
}

/* 5. LINHAS */
#modalResultadoPiramide.modo-cheio .sb-row, 
#modalResultadoPiramide.modo-cheio .simple-row {
    width: 100% !important;
    display: flex !important;
    align-items: center !important;
    justify-content: space-between !important;
    padding: 8px 0 !important;
    margin-bottom: 8px !important;
    background-color: transparent !important;
    border: none !important;
    border-bottom: 1px solid #f0f0f0 !important;
    border-radius: 0 !important;
}

/* 6. NOMES */
#modalResultadoPiramide.modo-cheio .sb-name,
#modalResultadoPiramide.modo-cheio .simple-name {
    flex: 1 !important;
    text-align: left !important;
    margin-right: 10px !important;
    font-size: 1.2rem !important;
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    padding-left: 0 !important;
}

/* 7. INPUTS E GRUPOS */
#modalResultadoPiramide.modo-cheio .simple-set-group,
#modalResultadoPiramide.modo-cheio .set-input-wrapper {
    position: relative !important;
    width: 45px !important;
    flex-shrink: 0 !important;
    margin-left: 10px !important;
    overflow: visible !important;
    display: flex !important;
}

/* Ajuste específico para mostrar o input do set 2 na Arbitragem se quiser (Opcional, remove o hidden do wrapper) */
/* #modalResultadoPiramide.modo-cheio #wrapper-set2-j1.sb-hidden,
   #modalResultadoPiramide.modo-cheio #wrapper-set2-j2.sb-hidden {
       display: flex !important;
       opacity: 0.5; 
   } */

#modalResultadoPiramide.modo-cheio .sb-points-control {
    width: 110px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: space-between !important;
    margin-left: 10px !important;
    flex-shrink: 0 !important;
}

/* Game Score */
#modalResultadoPiramide.modo-cheio input.sb-input,
#modalResultadoPiramide.modo-cheio input.simple-input {
    width: 45px !important; 
    height: 45px !important;
    font-size: 1.3rem !important;
    text-align: center !important;
    padding: 0 !important;
    margin: 0 !important;
    z-index: 1 !important;
}

/* Tie-Break (Badge Flutuante) */
#modalResultadoPiramide.modo-cheio input.simple-tb-input,
#modalResultadoPiramide.modo-cheio .sb-tb-display {
    position: absolute !important;
    top: -12px !important;
    right: -12px !important;
    width: 30px !important;
    height: 30px !important;
    font-size: 1rem !important;
    text-align: center !important;
    margin: 0 !important;
    background-color: white !important;
    border: 1px solid #ccc !important;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3) !important;
    border-radius: 6px !important;
    z-index: 50 !important;
    padding: 0 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

#modalResultadoPiramide.modo-cheio .sb-tb-display:empty {
    display: none !important;
}

/* Oculta inputs que realmente devem sumir (Set 3 se inativo) */
#modalResultadoPiramide.modo-cheio input[style*="display: none"],
#modalResultadoPiramide.modo-cheio .simple-set-group[style*="none"],
#modalResultadoPiramide.modo-cheio .set-input-wrapper[id*="set3"].sb-hidden {
    display: none !important;
}

/* 8. RODAPÉ */
#modalResultadoPiramide.modo-cheio .modern-actions {
    width: 100% !important;
    display: flex !important;
    flex-direction: row !important;
    gap: 15px !important;
    margin-top: auto !important;
    margin-bottom: 5px !important;
}

#modalResultadoPiramide.modo-cheio .btn-modern {
    flex: 1 !important;
    height: 50px !important;
    font-size: 1.1rem !important;
    width: auto !important;
    max-width: none !important;
    margin: 0 !important; 
}

#modalResultadoPiramide.modo-cheio .winner-display:empty { display: none !important; }
#modalResultadoPiramide.modo-cheio .winner-display { 
    width: 100% !important;
    box-sizing: border-box !important;
    padding: 8px !important; 
    margin-bottom: 10px !important; 
    font-size: 1rem !important; 
}

/* Ajuste Modo Escuro */
body.dark-mode #modalResultadoPiramide.modo-cheio .modern-modal { background-color: #2c3e50 !important; }
body.dark-mode #modalResultadoPiramide.modo-cheio input.simple-tb-input,
body.dark-mode #modalResultadoPiramide.modo-cheio .sb-tb-display {
    background-color: #4e342e !important;
    border-color: #ffb74d !important;
    color: #ffcc80 !important;
}
/* Evita duplicação */
#modalResultadoPiramide.modo-cheio .scoreboard-container[style*="none"] { display: none !important; }
#modalResultadoPiramide.modo-cheio .scoreboard-container {
    width: 100% !important;
    max-width: none !important;
    flex-grow: 1 !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: center !important;
}

/* --- AJUSTE: DESISTÊNCIA/W.O. CENTRALIZADO (SEM QUEBRAR A SÚMULA) --- */

    /* 1. Transforma a Janela Modal em uma coluna flexível */
    /* Isso permite distribuir o cabeçalho, conteúdo e rodapé */
    #modalResultadoPiramide:not(.modo-cheio) .modern-modal {
        display: flex !important;
        flex-direction: column !important;
        height: 85vh !important;       /* Define uma altura fixa relativa à tela */
        max-height: 320px !important;  /* Trava para não estourar a tela */
    }

    /* 2. O Cabeçalho fica fixo no topo */
    #modalResultadoPiramide:not(.modo-cheio) .modern-modal-header {
        flex-shrink: 0 !important;
        margin-bottom: 0 !important;
    }

    /* 3. O PULO DO GATO: Centraliza QUALQUER conteúdo visível */
    /* Usamos margin: auto para centralizar verticalmente dentro do flex parent */
    /* NÃO usamos display: flex aqui para não quebrar a lógica de ocultação do JS */
    #desistencia-controls, 
    #wo-controls,
    #simple-score-container,
    #placar-fields-container {
        margin-top: auto !important;
        margin-bottom: auto !important;
        width: 100% !important;
    }

    /* 4. Ajuste fino nos inputs para ficarem mais compactos apenas nesta visualização */
    #desistencia-controls .modern-form-group,
    #wo-controls .modern-form-group {
        margin-bottom: 8px !important; /* Reduz espaço entre inputs para caber na tela */
    }
    
    /* 5. Garante que os labels não ocupem espaço demais */
    #desistencia-controls label,
    #wo-controls label {
        margin-bottom: 2px !important;
        font-size: 0.9rem !important;
    }

    /* 6. Botões fixos no rodapé */
    #modalResultadoPiramide:not(.modo-cheio) .modern-actions {
        margin-top: 0 !important;      /* Remove margem extra */
        padding-bottom: 5px !important;
        flex-shrink: 0 !important;     /* Garante que os botões não sumam */
    }

/* ================================================================= */
/* === FIM DE CORREÇÃO V15: VISIBILIDADE DOS CABEÇALHOS CORRIGIDA === */
/* ================================================================= */



/* --- ESTILOS DA ETAPA 4: INTERFACE DINÂMICA --- */

/* Texto de Status (Salvando... Salvo) */
.save-status {
    flex-grow: 1; /* Ocupa o espaço central */
    text-align: center;
    font-size: 0.9rem;
    font-weight: 600;
    color: #95a5a6;
    text-transform: uppercase;
    letter-spacing: 1px;
    opacity: 0; /* Invisível por padrão */
    transition: opacity 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 50px; /* Mesma altura dos botões */
}

.save-status.visible {
    opacity: 1;
}

/* Animação para o botão de Finalizar (Pulsar) */
@keyframes pulse-green {
    0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); }
    100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
}

.btn-finish {
    background-color: #2ecc71 !important;
    color: white !important;
    font-size: 1.2rem !important;
    animation: pulse-green 2s infinite;
    display: none; /* Começa oculto */
}

#btnTossJ1, #btnTossJ2 {
    height: auto !important;      /* Ignora o 50px fixo e deixa crescer */
    padding: 15px !important;     /* Restaura o "gordinho" do botão */
    flex: none !important;        /* Remove comportamento de esticar do rodapé */
    margin-bottom: 10px !important;
    width: 100% !important;       /* Garante largura total */
    font-size: 1.1rem !important; 
}

/* --- FIM DE ESTILOS DA ETAPA 4: INTERFACE DINÂMICA --- */


/* ================================================== */
/* === ESTILOS DO PLACAR AO VIVO (PONTOS E SAQUE) === */
/* ================================================== */

/* Coluna de PONTOS (15, 30, 40) */
.placar-points {
    font-size: 2.2em;
    font-weight: 700;
    color: #ffffff; /* Amarelo Tênis para destaque */
    width: 70px;    /* Largura fixa para alinhar */
    text-align: center;
    margin-right: 20px; /* Separa dos Sets */
    margin-left: 10px;
    text-shadow: 0 0 10px rgba(204, 255, 0, 0.3); /* Brilho sutil */
}

/* Bolinha de Saque (Overlay) */
.placar-server-ball {
    width: 20px;  /* Aumentei levemente para caber o detalhe */
    height: 20px;
    background-color: #ccff00; /* Amarelo Neon Tênis */
    border-radius: 50%;
    margin-right: 15px;
    
    /* Sombra interna para dar efeito 3D (esfera) + Brilho externo */
    box-shadow: inset -2px -2px 4px rgba(0,0,0,0.2), 0 0 10px rgba(204, 255, 0, 0.6);
    
    position: relative; /* Necessário para desenhar as linhas dentro */
    overflow: hidden;   /* Corta o que sair do círculo */
    display: none;      /* Começa invisível */
    vertical-align: middle;
}

/* Desenha a curva superior da costura */
.placar-server-ball::before {
    content: "";
    position: absolute;
    width: 70%;
    height: 70%;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.7); /* Costura branca */
    top: -45%;
    left: 15%;
    background: transparent;
}
/* fim de Bolinha de Saque (Overlay) */


/* Desenha a curva inferior da costura */
.placar-server-ball::after {
    content: "";
    position: absolute;
    width: 70%;
    height: 70%;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.7); /* Costura branca */
    bottom: -45%;
    left: 15%;
    background: transparent;
}

/* Classe para mostrar a bolinha com animação de "pop" */
.placar-server-ball.visible {
    display: inline-block;
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* Ajustes para Celular (Vertical) */
@media (max-width: 600px) {
    .placar-points {
        font-size: 1.5em; /* Um pouco menor no celular */
        width: 50px;
        margin-right: 10px;
    }
    .placar-server-ball {
        width: 10px;
        height: 10px;
        margin-right: 8px;
    }
}


/* Aviso de Match Point no Placar ao Vivo */
.placar-match-point-alert {
    background-color: #ff0000; /* Fundo Vermelho */
    color: white;
    font-weight: 900;
    text-transform: uppercase;
    padding: 5px 15px;
    border-radius: 4px;
    font-size: 0.9em;
    letter-spacing: 2px;
    margin-left: 15px; /* Espaço do indicador AO VIVO */
    animation: pulse-alert 1s infinite;
    display: none; /* Oculto por padrão */
    vertical-align: middle;
}

@keyframes pulse-alert {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.05); }
    100% { opacity: 1; transform: scale(1); }
}

/* ================================================== */
/* === FIM DE ESTILOS DO PLACAR AO VIVO (PONTOS E SAQUE) === */
/* ================================================== */


/* ================================================================= */
/* --- SUPER MASTER SEGURO: APENAS TELA DE RESULTADO (VISUALIZAÇÃO) EM LANDSCAPE --- */
/* ================================================================= */
@media (orientation: landscape) and (max-height: 600px) {
    
    /* 1. CONTAINER DA JANELA (Força tela cheia SOMENTE na visualização) */
    #modalResultadoPiramide.visualizando-resultado .modern-modal {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        
        width: 100vw !important;
        height: 100% !important;
        max-width: none !important;
        max-height: none !important;
        
        margin: 0 !important;
        border-radius: 0 !important;
        /* Padding lateral 30px para afastar das bordas arredondadas da tela */
        padding: 5px 30px 5px 30px !important; 
        
        overflow-y: auto !important;
        -webkit-overflow-scrolling: touch;
        
        background-color: white !important;
        box-sizing: border-box !important;
        z-index: 99999 !important;
        
        display: flex !important;
        flex-direction: column !important;
        
        /* Distribui: Cabeçalho no topo, Tabela no meio, Vencedor no fundo */
        justify-content: space-between !important; 
    }

    /* Ajuste Modo Escuro */
    body.dark-mode #modalResultadoPiramide.visualizando-resultado .modern-modal {
        background-color: #2c3e50 !important;
    }

    /* 2. CABEÇALHO (Compacto no topo) */
    #modalResultadoPiramide.visualizando-resultado .modern-modal-header {
        margin-bottom: 0 !important;
        margin-top: 0 !important;
        min-height: 30px !important;
        flex-shrink: 0;
        padding: 0 !important;
    }
    
    #modalResultadoPiramide.visualizando-resultado .modern-modal-header h3 {
        font-size: 1.2rem !important;
        margin: 0 !important;
        line-height: 1.2 !important;
    }

    /* 3. TABELA (Centralizada verticalmente no espaço que sobra) */
    #modalResultadoPiramide.visualizando-resultado .scoreboard-container,
    #modalResultadoPiramide.visualizando-resultado #simple-score-container {
        margin: auto 0 !important; /* Margem automática vertical */
        gap: 5px !important;
        flex-shrink: 0;
        width: 100% !important;
    }

    #modalResultadoPiramide.visualizando-resultado .sb-row,
    #modalResultadoPiramide.visualizando-resultado .simple-row {
        padding: 5px 10px !important;
        min-height: 45px !important;
        margin-bottom: 5px !important;
    }

    /* 4. INPUTS DE GAME (Tamanho Médio) */
    #modalResultadoPiramide.visualizando-resultado input.sb-input,
    #modalResultadoPiramide.visualizando-resultado input.simple-input {
        width: 40px !important;
        height: 35px !important;
        font-size: 1.2rem !important;
        padding: 0 !important;
        margin: 0 4px !important;
    }

    /* 5. INPUTS DE TIE-BREAK (Pequenos) */
    #modalResultadoPiramide.visualizando-resultado input.simple-tb-input,
    #modalResultadoPiramide.visualizando-resultado .sb-tb-display {
        width: 22px !important;
        height: 22px !important;
        font-size: 0.8rem !important;
        top: -10px !important;
        right: -10px !important;
        line-height: 22px !important;
        z-index: 50 !important;
        background-color: white !important;
        box-shadow: 0 1px 2px rgba(0,0,0,0.2) !important;
    }

    /* 6. VENCEDOR (FONTE AUMENTADA + Posição no Rodapé) */
    #modalResultadoPiramide.visualizando-resultado .winner-display {
        padding: 5px 10px !important;
        margin-top: 0 !important;
        margin-bottom: 5px !important; /* Margem segura do fundo */
        min-height: auto !important;
        flex-shrink: 0;
        border-radius: 12px !important;
    }
    
    #modalResultadoPiramide.visualizando-resultado .winner-label {
        font-size: 0.9rem !important; /* AUMENTADO (antes 0.7) */
        margin-bottom: 2px !important;
    }
    
    #modalResultadoPiramide.visualizando-resultado .winner-name {
        font-size: 1.5rem !important; /* AUMENTADO (antes 1.2) */
        line-height: 1.2 !important;
    }

    /* 7. BOTÃO X (Fixado no canto) */
    #modalResultadoPiramide.visualizando-resultado #btn-fechar-visualizacao {
        top: 50% !important;
        right: 0px !important; 
        transform: translateY(-50%) !important;
        font-size: 32px !important;
    }

    /* 8. GARANTIA: Esconde botões de ação */
    #modalResultadoPiramide.visualizando-resultado .modern-actions {
        display: none !important;
    }
    
    /* 9. JOGADORES (FONTE AUMENTADA) */
    #modalResultadoPiramide.visualizando-resultado .simple-name,
    #modalResultadoPiramide.visualizando-resultado .sb-name {
        font-size: 1.4rem !important; /* Fonte bem maior */
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        font-weight: 500 !important;
    }
}
/* ================================================================= */
/* --- FIM DE SUPER MASTER SEGURO: APENAS TELA DE RESULTADO (VISUALIZAÇÃO) EM LANDSCAPE --- */
/* ================================================================= */


/* Quebra de linha inteligente para o rodapé do placar */
.break-mobile {
    display: none; /* Invisível no Computador e Celular Deitado */
}
@media (max-width: 600px) and (orientation: portrait) {
    .break-mobile {
        display: block; /* Vira uma quebra de linha no Celular em Pé */
        margin-top: 2px;
    }
}
/* fim de Quebra de linha inteligente para o rodapé do placar */


/* ================================================================= */
/* === AJUSTE MODO TELA CHEIA (PC: PLACAR + DESISTÊNCIA GIGANTE) === */
/* ================================================================= */

/* ----------------------------------------------------------- */
/* 1. CONFIGURAÇÕES PARA COMPUTADOR (PC) */
/* ----------------------------------------------------------- */

@media (min-width: 1024px) {
    #btn-fullscreen-toggle {
        display: none !important;
    }

    #modalResultadoPiramide:has(#chk-modo-arbitragem:checked) #btn-fullscreen-toggle,
    #modalResultadoPiramide.modo-cheio #btn-fullscreen-toggle {
        display: flex !important;
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        
        background-color: transparent; 
        box-shadow: none;              
        border: none;                  
        padding: 5px;
        z-index: 2000;
        cursor: pointer;
        margin-top: -3px;
        color: #333; 
        width: 40px;
        height: 40px;
        justify-content: center;
        align-items: center;
    }

    #modalResultadoPiramide:has(#chk-modo-arbitragem:checked) #btn-fullscreen-toggle:hover,
    #modalResultadoPiramide.modo-cheio #btn-fullscreen-toggle:hover {
        background-color: #f5f5f5; 
        transform: translateY(-50%) scale(1.1);
    }
}

/* ----------------------------------------------------------- */
/* 2. LAYOUT QUANDO MAXIMIZADO (Somente com a classe .modo-cheio) */
/* ----------------------------------------------------------- */
@media (min-width: 1024px) {
    
    /* Janela ocupa a tela toda */
    #modalResultadoPiramide.modo-cheio .modern-modal {
        width: 98vw !important;
        height: 95vh !important;
        max-width: none !important;
        max-height: none !important;
        top: 2.5vh !important;
        left: 1vw !important;
        position: fixed !important;
        margin: 0 !important;
        
        display: flex !important;
        flex-direction: column !important;
        justify-content: center !important;
        padding: 0 !important;
        box-sizing: border-box !important;
        overflow: hidden !important;
    }

    /* Cabeçalho */
    #modalResultadoPiramide.modo-cheio .modern-modal-header h3 {
        font-size: 2.5rem !important;
        margin-bottom: 20px !important;
        margin-top: 30px !important; 
    }

    /* Placar Gigante */
    #modalResultadoPiramide.modo-cheio #placar-fields-container {
        transform: scale(1.5); 
        width: 60% !important; 
        margin: 0 auto !important;
        transform-origin: center center;
    }

    /* Nomes dos Jogadores */
    #modalResultadoPiramide.modo-cheio .sb-name {
        font-size: clamp(1.2rem, 2vw, 2.5rem) !important; 
        font-weight: 400 !important;
        line-height: 1.3 !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
    }
    
    #modalResultadoPiramide.modo-cheio .sb-name b {
        font-weight: 900 !important; 
        color: #000; 
    }

    /* Espaçamento Sets */
    #modalResultadoPiramide.modo-cheio .sb-col-set {
        font-size: 1.5rem !important;
        text-align: center !important;
        width: clamp(70px, 6vw, 100px) !important; 
        margin: 0 10px !important;
    }

    #modalResultadoPiramide.modo-cheio .set-input-wrapper,
    #modalResultadoPiramide.modo-cheio input.super-tb { 
        margin: 0 10px !important; 
    }

    /* Vencedor */
    #modalResultadoPiramide.modo-cheio .winner-display {
        padding: 20px !important;
        margin-top: 30px !important;
        border-width: 3px !important;
    }
    #modalResultadoPiramide.modo-cheio .winner-label {
        font-size: clamp(0.9rem, 1.2vw, 1.5rem) !important;
        margin-bottom: 10px !important;
    }
    #modalResultadoPiramide.modo-cheio .winner-name {
        font-size: clamp(1.8rem, 3.5vw, 4rem) !important;
        line-height: 1.2 !important;
    }

    /* Botões */
    #modalResultadoPiramide.modo-cheio .modern-actions {
        transform: scale(1.2);
        width: 80% !important;
        margin: 40px auto 20px auto !important;
    }

    /* ----------------------------------------------------------------- */
    /* 4. AJUSTE PARA DESISTÊNCIA E W.O. (Centralizado + Texto Esquerda) */
    /* ----------------------------------------------------------------- */
    
    /* Container (Aplica a ambos) */
    #modalResultadoPiramide.modo-cheio #desistencia-controls,
    #modalResultadoPiramide.modo-cheio #wo-controls {
        width: 80% !important;
        margin: auto !important; /* Centraliza verticalmente */
        padding-top: 120px !important; /* Afasta do topo */
        
        display: flex;
        flex-direction: column;
        justify-content: center;
        flex-grow: 1; 
    }

    /* Títulos das perguntas */
    #modalResultadoPiramide.modo-cheio #desistencia-controls label,
    #modalResultadoPiramide.modo-cheio #wo-controls label {
        font-size: clamp(1.5rem, 3vw, 3rem) !important; 
        margin-bottom: 15px !important;
        font-weight: bold !important;
        
        text-align: left !important; /* Texto alinhado à esquerda */
        display: block !important;
        width: 100% !important;
    }

    /* Caixas de seleção (Inputs) */
    #modalResultadoPiramide.modo-cheio #desistencia-controls .modern-select,
    #modalResultadoPiramide.modo-cheio #wo-controls .modern-select {
        height: clamp(70px, 12vh, 120px) !important; 
        font-size: clamp(1.5rem, 2.5vw, 3rem) !important; 
        padding: 0 20px !important;
        border-width: 3px !important;
        border-radius: 15px !important;
    }
    
    /* Espaço entre os campos */
    #modalResultadoPiramide.modo-cheio #desistencia-controls .modern-form-group,
    #modalResultadoPiramide.modo-cheio #wo-controls .modern-form-group {
        margin-bottom: 60px !important;
        width: 100%;
        text-align: left !important;
    }
}

/* ----------------------------------------------------------- */
/* 5. CORREÇÃO PARA CELULAR DEITADO (ESPAÇAMENTO) */
/* ----------------------------------------------------------- */
@media (orientation: landscape) and (max-height: 600px) {
    #modalResultadoPiramide .set-input-wrapper,
    #modalResultadoPiramide input.super-tb {
        margin-left: 10px !important;
        margin-right: 10px !important;
    }
    #modalResultadoPiramide .sb-header .sb-col-set {
        margin-left: 10px !important;
        margin-right: 0px !important;
        width: 45px !important; 
    }
    #placar-fields-container {
        width: 98% !important;
        padding-left: 2px !important;
        padding-right: 2px !important;
    }
}

/* ================================================================= */
/* === FIM DE AJUSTE PC e CELULAR: MODO TELA CHEIA (BOTÃO + ZOOM) === */
/* ================================================================= */ 


/* ================================================================= */
/* === ESTILO PARA INPUTS READONLY (MODO ARBITRAGEM BLINDADO) === */
/* ================================================================= */

/* Transforma o input em um "Display" puro (sem clique, sem foco) */
.sb-input[readonly] {
    background-color: #fff !important; 
    color: #333 !important;            
    
    /* BLOQUEIO TOTAL DE INTERAÇÃO */
    pointer-events: none !important;   /* O segredo: impede qualquer clique ou toque */
    user-select: none !important;      /* Impede selecionar o texto */
    
    /* Visual Limpo */
    cursor: default !important;        
    outline: none !important;          /* Remove borda azul de foco */
    box-shadow: none !important;       /* Remove sombras de foco */
}

/* Ajuste para Modo Escuro */
body.dark-mode .sb-input[readonly] {
    background-color: #2c3e50 !important;
    color: #fff !important;
}

/* Mantém o destaque do Super Tie-break (3º set) mesmo bloqueado */
.sb-input.super-tb[readonly]:not(:disabled) {
    background-color: #fffbf2 !important;
    color: #d35400 !important;
}
body.dark-mode .sb-input.super-tb[readonly]:not(:disabled) {
    background-color: #4e342e !important;
    color: #f39c12 !important;
}
/* ================================================================= */
/* === FIM DE ESTILO PARA INPUTS READONLY (MODO ARBITRAGEM BLINDADO) === */
/* ================================================================= */


/* ================================================================= */
/* === CORREÇÃO DEFINITIVA DO FUNDO NO MODO ESCURO (TOPO) === */
/* ================================================================= */

/* 1. Pinta a barra fixa dos botões (Abas) de preto */
body.dark-mode .tab-container {
    background-color: #121212 !important; /* Fundo escuro */
    border-bottom: 1px solid #333;        /* Linha sutil para separar */
    box-shadow: 0 2px 5px rgba(0,0,0,0.5) !important; /* Sombra escura */
}

/* 2. Pinta o container de Agenda/Título/Legenda de preto */
body.dark-mode .header-legenda-container {
    background-color: #121212 !important; /* Fundo escuro */
    color: #e0e0e0 !important;            /* Texto claro */
    border-bottom: 1px solid #333;        /* Linha sutil */
    box-shadow: none !important;
}

/* 3. Garante que o texto do título (h2) fique branco */
body.dark-mode .header-legenda-container h2,
body.dark-mode .header-legenda-container .header-main,
body.dark-mode .header-legenda-container .header-sub {
    color: #ffffff !important;
}
/* ================================================================= */
/* === fim de CORREÇÃO DEFINITIVA DO FUNDO NO MODO ESCURO (TOPO) === */
/* ================================================================= */

/* --- ESTILO PARA DIAS FORA DO PRAZO DE ANTECEDÊNCIA --- */
.dia-bloqueado-visual {
    background-color: #e9ecef !important; /* Cinza claro */
    color: #a0a0a0 !important;            /* Texto cinza apagado */
    opacity: 0.7;
}

/* Ajuste para o Modo Escuro */
body.dark-mode .dia-bloqueado-visual {
    background-color: #252525 !important; /* Cinza escuro */
    color: #666 !important;               /* Texto escuro apagado */
}
/* --- fim de ESTILO PARA DIAS FORA DO PRAZO DE ANTECEDÊNCIA --- */



/* ================================================================ */
/* === CORREÇÃO DE LOGIN APENAS PARA CELULAR (V3 - ROBUSTA) === */
/* ================================================================ */
@media (max-width: 600px) {

    /* 1. O Container da linha: Flexbox para alinhar tudo na mesma régua */
    #loginScreen .acesso-wrapper {
        display: flex !important;
        flex-direction: row !important;       /* Linha horizontal */
        align-items: center !important;       /* Centraliza verticalmente */
        justify-content: space-between !important;
        width: 100% !important;
        position: static !important;          /* Remove posição relativa se houver */
        box-sizing: border-box !important;    /* Garante que padding não aumente largura */
        gap: 5px !important;                  /* Espacinho entre os itens */
    }

    /* 2. O Rótulo "Senha:" (Fica na esquerda) */
    #loginScreen .label-acesso {
        width: auto !important;
        margin: 0 !important;
        white-space: nowrap !important;       /* Não quebra linha */
        flex-shrink: 0 !important;            /* Não deixa esmagar */
    }

    /* 3. O Campo de Digitação (Garante bolinhas em todos os dispositivos) */
	#loginScreen #acesso_user {
		flex: 1 !important;
		width: auto !important;
		min-width: 0 !important;
		padding: 0 10px !important;
		height: 40px !important;
		margin: 0 !important;
		box-sizing: border-box !important;

		/* --- O SEGREDO PARA AS BOLINHAS (Mobile + Desktop) --- */
		/* Usamos os três tipos de prefixos para garantir compatibilidade total */
		-webkit-text-security: disc !important;
		-moz-text-security: disc !important; /* Para Firefox antigo */
		text-security: disc !important;      /* Padrão futuro */
	}

    /* 4. O Botão do Olho (Fica na direita) */
    #loginScreen #toggleSenha {
        position: static !important;          /* Remove absolute/fixed */
        transform: none !important;           /* Remove translate centralizado */
        top: auto !important;
        right: auto !important;
        
        /* --- AQUI ESTÁ A MUDANÇA FORTE --- */
        width: 50px !important;         /* Largura fixa */
        min-width: 50px !important;     /* Garante que não esmague */ 
        /* -------------------------------- */
		
        height: 40px !important;              /* Altura igual ao input */
        padding: 0 !important;
        margin: 0 !important;
        
        background-color: #4CAF50 !important; /* Fundo Verde */
        color: white !important;              /* Ícone Branco */
        border-radius: 5px !important;
        border: none !important;
        
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        flex-shrink: 0 !important;            /* Não deixa esmagar */
    }
}

/* Isso garante bolinhas em qualquer dispositivo, sem mexer no tamanho do campo */
#acesso_user {
    -webkit-text-security: disc !important;
    text-security: disc !important;
}

/* ================================================================ */
/* === fim de CORREÇÃO DE LOGIN APENAS PARA CELULAR (IGUAL AO PC) === */
/* ================================================================ */



/* ========================================================== */
/* === CORREÇÃO FINAL: MODO MANUTENÇÃO (MOBILE PERFECT) === */
/* ========================================================== */

/* 1. Esconde o botão (+) */
.form-container.modo-manutencao .add-jogador,
.form-container.modo-manutencao span.add-jogador {
    display: none !important;
}

/* 2. ALINHAMENTO DOS RÓTULOS */
.form-container.modo-manutencao label {
    flex: 0 0 105px !important;   /* Largura fixa da coluna de texto */
    max-width: 105px !important;
    text-align: left !important;
    margin-right: 5px !important;
    white-space: nowrap !important;
    font-size: 0.95rem !important; /* Um pouquinho menor para garantir no celular */
}

/* 3. AJUSTE DOS CAMPOS (FLEXÍVEL) */
.form-container.modo-manutencao select,
.form-container.modo-manutencao input,
.form-container.modo-manutencao #jogador1 {
    /* O SEGREDO DO CELULAR: */
    flex: 1 !important;           /* Ocupa o espaço que sobrar */
    width: 100% !important;       /* Tenta preencher */
    
    /* No PC fica 260px (igual aos outros). No celular, encolhe para caber. */
    max-width: 260px !important;  
    min-width: 0 !important;      /* Permite encolher abaixo do padrão se necessário */
    
    margin: 0 !important;
    box-sizing: border-box !important;
}
/* =============================================== */
/* === fim de CORREÇÃO FINAL: MODO MANUTENÇÃO (LAYOUT) === */
/* ========================================================== */ 



/* AJUSTE FINAL - APENAS BOTÕES PRINCIPAIS DE SALVAR NO CELULAR */
@media (max-width: 600px) {
    /* Novo Agendamento (ID) */
    .form-container #botaoAgendar, 
    /* Nova Aula (Função específica) */
    .form-container button[onclick*="salvarAulaPeloForm"], 
    /* Nova Manutenção (Função específica) */
    .form-container button[onclick*="salvarManutencaoPeloForm"] {
        height: 45px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        font-size: 18px !important;
        font-weight: bold !important;
        margin-top: 15px !important;
        margin-bottom: 5px !important;
        
        /* Garante que o botão use a largura correta com as margens que você gosta */
        
        margin-left: 20px !important;
        margin-right: 20px !important;
    }
}
/* fim de  AJUSTE FINAL - APENAS BOTÕES PRINCIPAIS DE SALVAR NO CELULAR */ 


/* --- CORREÇÃO DE CAMADAS DOS MODAIS --- */

/* Modal Sobre o Sistema */
#infoModalOverlay {
    z-index: 10000 !important; 
}

/* Modal de Confirmação/Logout (Precisa ser maior que o Sobre) */
#modalOverlay, 
#confirmModalOverlay {
    z-index: 10001 !important; 
}
/* --- FIM DE CORREÇÃO DE CAMADAS DOS MODAIS --- */



/* --- CABEÇALHO (Versão Final Profissional) --- */
#app-header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 35px;
    
    /* EFEITO DEGRADÊ (Do Branco para o Cinza Gelo) */
    background: linear-gradient(to bottom, #ffffff 0%, #e8e8e8 100%);
    
    /* Sombra mais marcada para destacar do fundo */
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 15px;
    box-sizing: border-box;
    z-index: 2000;
}
/* --- CORREÇÃO DO CLIQUE NO IPHONE --- */
#app-header, .header-legenda, #header-nome {
    /* 1. O SEGREDO: Diz ao iPhone para não fazer zoom com duplo toque */
    touch-action: manipulation; 
    
    /* 2. Impede que o texto fique azul (selecionado) ao clicar várias vezes */
    -webkit-user-select: none;
    user-select: none;
    
    /* 3. Garante que o sistema entenda que é um botão */
    cursor: pointer;
}

.header-left {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-grow: 1; 
}

.header-logo {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    object-fit: cover;
    
    /* Borda sutil para dar acabamento */
    border: 2px solid rgba(255,255,255,0.5); 
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);

    /* MÁGICA PARA O MODO CLARO (Remove o fundo branco) */
    mix-blend-mode: multiply; 
    /* Aumenta o contraste para o branco ficar puríssimo e sumir de vez */
    filter: contrast(1.2) brightness(1.1); 
}

/* --- MÁGICA PARA O MODO ESCURO (Inverte para virar Branco) --- */
body.dark-mode .header-logo {
    /* 1. Volta ao normal (Remove a inversão e a mistura de tela) */
    mix-blend-mode: normal !important; 
    filter: none !important;
    
    /* 2. Ajuste visual */
    /* Como o fundo da imagem é branco, ele vai parecer uma "bolinha branca" */
    /* Adicionamos uma borda cinza para suavizar o recorte */
    border: 2px solid #555 !important;
    
    /* Opcional: Reduzir levemente o brilho para o branco não "estourar" os olhos no escuro */
    opacity: 0.9;
}

.header-user {
    font-family: 'Roboto', sans-serif;
    font-size: 15px; /* Ajustado para caber nome composto */
    font-weight: 700;
    color: #333;
    white-space: nowrap;
    text-shadow: 0 1px 0 #fff; /* Leve brilho no texto */
}

/* A VACINA DO BOTÃO SAIR */
.header-logout {
    background: transparent !important; /* Remove o verde */
    background-color: transparent !important; /* Garante remoção */
    border: none !important;
    box-shadow: none !important; /* Remove sombra do botão antigo */
    width: auto !important; /* Remove a largura gigante */
    margin: 0 !important;
    padding: 8px !important;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #555; /* Cor do ícone cinza escuro (mais elegante) */
    transition: transform 0.2s;
}

.header-logout:active {
    transform: scale(0.95); /* Efeito de clique sutil */
}

/* --- AJUSTES DO CABEÇALHO PARA MODO ESCURO --- */

/* 1. O Fundo da Barra (Cinza Escuro com Degradê Suave) */
body.dark-mode #app-header {
    background: linear-gradient(to bottom, #333333 0%, #1a1a1a 100%) !important;
    box-shadow: 0 4px 6px rgba(0,0,0,0.6) !important; /* Sombra mais escura */
    border-bottom: 1px solid #444; /* Linha sutil para separar */
}

/* 2. O Texto "Olá, Nome" (Vira Branco) */
body.dark-mode .header-user {
    color: #ffffff !important;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8); /* Sombra no texto para leitura */
}

/* 3. A Borda da Bolinha do Logo (Vira Cinza para não brilhar) */
body.dark-mode .header-logo {
    border: 2px solid #555 !important;
}

/* 4. O Ícone de Sair (Vermelho mais claro para destacar no preto) */
body.dark-mode .header-logout svg {
    stroke: #ef5350 !important; /* Vermelho claro */
}
/* --- FIM DE CABEÇALHO (Versão Final Profissional) --- */


/* --- CONTROLE DE EXIBIÇÃO DE NOME (PC vs CELULAR) --- */
.nome-desktop { display: inline; } /* PC: Mostra nome completo */
.nome-mobile { display: none; }    /* PC: Esconde apelido */

@media (max-width: 600px) {
    .nome-desktop { display: none; } /* Celular: Esconde nome completo */
    .nome-mobile { display: inline; } /* Celular: Mostra apelido */
}
/* FIM DE --- CONTROLE DE EXIBIÇÃO DE NOME (PC vs CELULAR) --- */


/* --- TECLADO ESTILO GAVETA (NATIVO) --- */
/* --- TECLADO VIRTUAL ESTILO NATIVO (IOS/ANDROID) --- */
.teclado-gaveta {
    position: fixed;
    bottom: -100%; /* Começa escondido */
    left: 0;
    width: 100%;
    
    /* COR DE FUNDO EXATA DO TECLADO DO IPHONE/SAMSUNG */
    background-color: #d1d5db; 
    
    z-index: 9999;
    transition: bottom 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Slide rápido */
    padding-bottom: 20px; /* Espaço para a barra de gesto do celular */
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
}

.teclado-gaveta.aberto {
    bottom: 0;
}

/* Barra superior (Concluído) */
.teclado-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #f0f2f5; 
    padding: 10px 15px;
    border-bottom: 1px solid #c8cdd1;
    height: 25px;
}

.teclado-botao-concluir {
    font-size: 17px;
    font-weight: 600;
    color: #007aff; /* Azul nativo do iOS/Android */
    cursor: pointer;
}

/* Container das Teclas */
.teclado-grid {
    padding: 6px;
    display: flex;
    flex-direction: column;
    gap: 6px; 
}

.teclado-linha {
    display: flex;
    justify-content: center;
    gap: 6px; 
    width: 100%;
}

/* A TECLA EM SI (O visual importante - BLINDADO CONTRA VERDE) */
.tecla {
    flex: 1; 
    height: 48px; 
	
	/* --- A CORREÇÃO PARA O IPHONE (ZOOM) --- */
    /* Isso impede o iPhone de tentar dar zoom ao clicar rápido 2x */
    touch-action: manipulation !important; 
    /* -------------------------------------- */
    
    /* VISUAL BRANCO COM SOMBRA SUTIL + BLINDAGEM (!important) */
    background-color: #ffffff !important;
    border: none !important;
    border-radius: 5px; 
    box-shadow: 0 1px 0 #888888 !important;
    
    /* TEXTO */
    color: #000 !important;
    font-size: 25px;
    font-weight: 400;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    
    /* REMOVE ESTILOS PADRÃO */
    padding: 0;
    margin: 0;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    display: flex;
    align-items: center;
    justify-content: center;
    outline: none !important; /* Remove borda azul/verde de foco */
}

/* Efeito ao tocar na tecla (ficar cinza escuro, NÃO VERDE) */
.tecla:active {
    background-color: #d1d1d6 !important; /* Cinza clássico de toque */
    transform: translateY(1px); 
    box-shadow: none !important;
}

/* Botões de Função (C e Backspace) - Cinza mais escuro */
.tecla-funcao {
    background-color: #acb3bc !important; 
    color: #000 !important;
    box-shadow: 0 1px 0 #6e7275 !important;
}

.tecla-funcao:active {
    background-color: #ffffff !important; /* Inverte a cor ao clicar */
    transform: translateY(1px);
}

/* Ajuste do ícone SVG do Backspace */
.tecla svg {
    pointer-events: none;
}

/* MODO ESCURO (Se o usuário ativar) */
body.dark-mode .teclado-gaveta {
    background-color: #1c1c1e; 
    border-top-color: #333;
}
body.dark-mode .teclado-header {
    background-color: #252525;
    border-bottom: 1px solid #111;
}
body.dark-mode .tecla {
    background-color: #555555 !important; 
    color: #fff !important;
    box-shadow: 0 1px 0 #111 !important;
}
body.dark-mode .tecla:active {
    background-color: #777 !important;
}
body.dark-mode .tecla-funcao {
    background-color: #3a3a3a !important; 
    box-shadow: 0 1px 0 #111 !important;
}
/* --- FIM DE TECLADO ESTILO GAVETA (NATIVO) --- */


#acesso_user::placeholder {
    font-size: 16px !important;       /* Fonte menor apenas para o aviso */
    letter-spacing: normal !important; /* Letras normais, sem espaçamento */
    font-weight: normal !important;
    opacity: 0.7;                      /* Um pouco mais suave */
}



/* --- ----------------------------------------*/
/* --- ESTILO DO SISTEMA DE NOTIFICAÇÕES --- */
/* --- --------------------------------------- */

/* 1. O BADGE (BOLINHA VERMELHA) */
.notificacao-container {
    position: relative; /* Importante para a bolinha ficar presa aqui */
}

.badge-vermelho {
    position: absolute;
    top: -5px;    /* Ajuste fino vertical */
    right: -6px;  /* Ajuste fino horizontal */
    
    background-color: #ff3b30; /* Vermelho vibrante (padrão iOS) */
    color: white;
    font-size: 10px;
    font-weight: bold;
    font-family: Arial, sans-serif;
    
    height: 16px;
    min-width: 16px;
    border-radius: 50%; /* Faz virar uma bolinha perfeita */
    
    display: flex;
    align-items: center;
    justify-content: center;
    
    border: 2px solid #ffffff; /* Borda branca para destacar do fundo */
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    z-index: 10;
}

/* 2. A JANELA MODAL (MURAL) */
.modal-grande {
    width: 90%;
    max-width: 600px; /* Não deixa ficar gigante no PC */
    max-height: 85vh; /* Ocupa até 85% da altura da tela */
    overflow-y: auto; /* Cria barra de rolagem se tiver muita mensagem */
    border-radius: 12px;
    padding: 0; /* Remove padding padrão para caber o cabeçalho */
}

/* Cabeçalho fixo do modal */
.modal-header {
    position: sticky;
    top: 0;
    background-color: #fff;
    padding: 15px 20px;
    border-bottom: 1px solid #eee;
    z-index: 5;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h3 {
    font-size: 18px;
    color: #333;
    margin: 0;
}

/* Botão X de fechar */
.close-button {
    font-size: 28px;
    color: #aaa;
    cursor: pointer;
    line-height: 20px;
}

/* Área de conteúdo (Lista) */
.lista-msg-container {
    padding: 20px;
    background-color: #f9f9f9;
    min-height: 200px;
}

/* 3. OS CARTÕES DE MENSAGEM (CARDS) */
.card-mensagem {
    background-color: #ffffff;
    border-left: 5px solid #4CAF50; /* Tarja Verde lateral */
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08); /* Sombra suave */
    transition: transform 0.2s;
	position: relative; /* Necessário para posicionar o botão X */
}

/* Botão de Excluir Mensagem */
.btn-excluir-msg {
    display: none; 
    position: absolute;
    top: 5px;
    right: 8px;
    color: #d32f2f;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    line-height: 1;
    padding: 2px 6px;
    border-radius: 4px;
    transition: background 0.2s;
    z-index: 2;
}

.btn-excluir-msg:hover {
    background-color: #ffebee;
    color: #b71c1c;
}

.modo-admin-ativo .btn-excluir-msg {
    display: block !important;
}

.card-mensagem:active {
    transform: scale(0.98); /* Efeito de clique sutil */
}

.card-mensagem h3 {
    margin: 0 0 8px 0;
    font-size: 16px;
    color: #222;
    font-weight: 600;
}

.card-mensagem p {
    margin: 0;
    font-size: 14px;
    color: #555;
    line-height: 1.5;
    white-space: pre-wrap; /* Mantém os parágrafos do texto */
}

.card-info-autor {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #eee;
    font-size: 11px;
    color: #999;
    display: flex;
    justify-content: space-between;
}

/* Ajustes para MODO ESCURO */
body.dark-mode .modal-header {
    background-color: #2c2c2e;
    border-bottom-color: #444;
}
body.dark-mode .modal-header h3 { color: #fff; }

body.dark-mode .lista-msg-container {
    background-color: #1c1c1e;
}

body.dark-mode .card-mensagem {
    background-color: #333;
    border-left-color: #66bb6a; /* Verde mais claro */
}
body.dark-mode .card-mensagem h3 { color: #fff; }
body.dark-mode .card-mensagem p { color: #ccc; }
body.dark-mode .card-info-autor { border-top-color: #444; }

/* --- ----------------------------------------*/
/* --- fim de ESTILO DO SISTEMA DE NOTIFICAÇÕES --- */
/* --- --------------------------------------- */

</style>


</head>


<body> 

<header id="app-header">
    <div class="header-left">
        <img src="https://clube-olimpico.github.io/Reservas/novo-logo-6.png" alt="Logo" class="header-logo">
        <span class="header-user" id="header-nome">Olá, Sócio</span>
    </div>
    
    <div class="header-right" style="display: flex; align-items: center;">
        
        <div class="notificacao-container" onclick="abrirMuralMensagens()" title="Mural de Avisos" style="display: flex; align-items: center; justify-content: center; margin-right: 8px; cursor: pointer;">
			<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
				<path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
			</svg>
			<span id="notificacao-badge" class="badge-vermelho" style="display: none;">0</span>
		</div>

        <button class="header-logout" onclick="confirmarLogout()" title="Sair / Trocar Usuário">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#d32f2f" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                <polyline points="16 17 21 12 16 7"></polyline>
                <line x1="21" y1="12" x2="9" y2="12"></line>
            </svg>
        </button>
    </div>
</header>

 <!-- Tela de carregamento -->
    <div id="pageOverlay" class="page-overlay"></div> <div id="loading" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2rem; background-color: white; width: 100%; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 9999;">
		<div id="loadingSpinner"></div>
		<div>Carregando... Aguarde.</div> 
	</div>
	
	

<!-- Tela de Login -->
<div id="loginScreen">
    <!-- Cabeçalho com as informações do clube -->
    <div id="loginHeader">
        <h1>Clube Olímpico</h1>
        <h2>Quadras de Tênis</h2>
        <h3>Sistema de Reservas</h3>
    </div>

    <!-- Painel de seleção de jogadores -->
    <div id="loginForm">
        <h2>Selecione seu nome:</h2>
        <div class="input-group">
            <select id="jogadorSelect">
                <option value="">Carregando jogadores...</option>
            </select>
        </div>
        
        <div class="acesso-wrapper" style="margin-bottom: 15px;">
			<label for="acesso_user" class="label-acesso">Senha:</label>
            <input type="text" id="acesso_user" placeholder="Digite sua senha..." 
			   maxlength="8" autocomplete="off" readonly
			   style="text-align: left; padding-left: 15px; font-size: 22px; letter-spacing: 3px; background-color: #f9f9f9; color: #333; cursor: pointer;">            <button type="button" id="toggleSenha">👁️</button>
		</div>
		       
        <button onclick="fazerLogin()">Entrar</button>
    </div>
</div>


<div id="teclado-overlay" class="teclado-gaveta">
    <div class="teclado-header">
        <div class="teclado-placeholder"></div> <div class="teclado-botao-concluir" onclick="fecharTeclado()">Concluído</div>
    </div>

    <div class="teclado-grid">
        <div class="teclado-linha">
            <button class="tecla" onclick="teclar('1')">1</button>
            <button class="tecla" onclick="teclar('2')">2</button>
            <button class="tecla" onclick="teclar('3')">3</button>
        </div>
        <div class="teclado-linha">
            <button class="tecla" onclick="teclar('4')">4</button>
            <button class="tecla" onclick="teclar('5')">5</button>
            <button class="tecla" onclick="teclar('6')">6</button>
        </div>
        <div class="teclado-linha">
            <button class="tecla" onclick="teclar('7')">7</button>
            <button class="tecla" onclick="teclar('8')">8</button>
            <button class="tecla" onclick="teclar('9')">9</button>
        </div>
        <div class="teclado-linha">
            <button class="tecla tecla-funcao" onclick="limparSenha()">C</button>
            <button class="tecla" onclick="teclar('0')">0</button>
            <button class="tecla tecla-funcao" onclick="apagarUltimo()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line></svg>
            </button>
        </div>
    </div>
</div>


<!-- Conteúdo Principal -->
<div id="mainContent" style="display: none; text-align: center;">
    <h2>Bem-vindo, <span id="nomeJogador"></span>!</h2>
    <button onclick="fazerLogout()">Sair</button>
</div>


<!-- Conteúdo da página (inicialmente oculto) -->
<div id="content" style="display: none;">

<div class="tab-container" style="display: flex; justify-content: center; margin-bottom: 10px;">
    <button class="tab-button" data-nome-original="Quadra 1 - Coberta" onclick="selecionarQuadra('Quadra 1 - Coberta')">Quadra 1 - Coberta</button>
    <button class="tab-button" data-nome-original="Quadra 2 - Aberta" onclick="selecionarQuadra('Quadra 2 - Aberta')">Quadra 2 - Aberta</button>
    <button class="tab-button" data-nome-original="Quadra 3 - Coberta" onclick="selecionarQuadra('Quadra 3 - Coberta')">Quadra 3 - Coberta</button>
</div>


<div id="formBackdrop" class="form-backdrop"></div>
<div class="form-container">
    <div class="form-header">
        <h3>Novo Agendamento</h3>
        <button type="button" class="close-form-btn" aria-label="Fechar">&times;</button>
    </div>
    <form id="dataForm">
	
	    <div class="form-row">
			<label for="quadra">Quadra:</label>
			<select id="quadra" onchange="selecionarQuadra(this.value)">
				<option value="Quadra 1 - Coberta">Quadra 1 - Coberta</option>
				<option value="Quadra 2 - Aberta">Quadra 2 - Aberta</option>
				<option value="Quadra 3 - Coberta">Quadra 3 - Coberta</option>
			</select>
		</div>



        <div class="form-row">
            <label for="dia">Dia:</label>
            <select id="dia"  onchange="atualizarOpcoesHorario()">
                </select>
        </div>

        <div class="form-row">
			<label for="duracao">Duração:</label>
			<select id="duracao" onchange="atualizarOpcoesHorario()">
			<option value="1">1 hora</option>
			<option value="2">2 horas</option>
			<option value="3-piramide" style="display: none;">Pirâmide</option> <!-- Opção inicialmente oculta -->
			</select>
		</div>
		

        <div class="form-row">
            <label for="hora">Horário:</label>
            <select id="hora">
                <!-- As opções de horário serão ajustadas pelo JavaScript -->  
            </select>
        </div>

        <div class="jogadores-container" id="jogadoresContainer">
			<div class="form-row">
				<label for="jogador1">Jogador:</label>
				<select id="jogador1" name="jogador" required style="width: 100px;" onchange="handleConvidadoSelect(this)">
					<option value="">Selecione um jogador</option>
				</select>
				<span class="add-jogador" onclick="adicionarJogador()">+</span>
			</div>
		</div>

        <button id="botaoAgendar" type="button" onclick="atualizarTabela()">Agendar</button>
    </form>
</div>


<div id="modalConvites" class="modal-overlay">
    <div class="modal-content">
        <div id="convites-pendentes-container">
            <h3 style="margin-top: 0; text-align: center;">Meus Convites Pendentes</h3>
            <ul id="lista-convites" style="list-style: none; padding: 0;">
                </ul>
        </div>
    </div>
</div>



<div id="modalResultadoPiramide" class="modal-overlay">
    <div class="modal-content modern-modal">
        
        <div class="modern-modal-header">
            <h3>Súmula</h3>
            
            <button id="btn-fullscreen-toggle" type="button" title="Tela Cheia" onclick="alternarFullScreenManual()">
				<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				  <line x1="15" y1="3" x2="21" y2="3"></line>
				  <line x1="21" y1="3" x2="21" y2="9"></line>
				  <line x1="21" y1="3" x2="14" y2="10"></line>
				  <line x1="3" y1="21" x2="9" y2="21"></line>
				  <line x1="3" y1="21" x2="3" y2="15"></line>
				  <line x1="3" y1="21" x2="10" y2="14"></line>
				</svg>
			</button>

            <button id="btn-mais-opcoes" type="button" title="Mais Opções">⋮</button>
			
			<button id="btn-fechar-visualizacao" type="button" title="Fechar">&times;</button>
			
            <div id="menu-opcoes-resultado" class="menu-dropdown">
                <div class="menu-toggle-item" id="item-modo-arbitragem">
                    <span>Modo Arbitragem</span>
                    <label class="toggle-switch-menu">
                        <input type="checkbox" id="chk-modo-arbitragem"> 
                        <span class="slider-menu round"></span>
                    </label>
                </div>
                <div class="menu-toggle-item" id="item-no-ad">
                    <span>No-Ad</span>
                    <label class="toggle-switch-menu">
                        <input type="checkbox" id="chk-modo-no-ad"> 
                        <span class="slider-menu round"></span>
                    </label>
                </div>
                <hr class="menu-divider">
                <a href="#" id="acao-voltar-jogo" style="display: none;">↩ Voltar ao Jogo</a>
                <a href="#" id="acao-wo">🏳️ W.O.</a>
                <a href="#" id="acao-desistencia">🤕 Desistência</a>
            </div>
        </div>

        <div class="scoreboard-container" id="placar-fields-container" style="display: none;">
            
            <div class="sb-header">
                <div class="sb-col-name"></div> 
                <div class="sb-col-set">1</div>
                <div class="sb-col-set sb-hidden" id="header-set2">2</div>
                <div class="sb-col-set sb-hidden" id="header-set3">3</div>
                <div class="sb-col-points" id="label-game-points">GAME</div>
            </div>

            <div class="sb-row" id="sb-row-p1">
                <div class="sb-name" id="apelido-j1" onclick="toggleSacador('j1')">Jogador 1</div>
                <div class="sb-server-marker" id="server-marker-j1"></div>  
                
                <div class="set-input-wrapper">
                    <input type="tel" class="sb-input" id="set1-j1" placeholder="" readonly
                           oninput="calcularVencedorPiramide()" 
                           onclick="carregarTieBreakParaEdicao(1)"
                           onfocus="focarInputArbitragem(this)" 
                           onblur="desfocarInputArbitragem(this)">
                    <span id="view-tb1-j1" class="sb-tb-display"></span>
                </div>

                <div class="set-input-wrapper sb-hidden" id="wrapper-set2-j1">
                    <input type="tel" class="sb-input" id="set2-j1" placeholder="" disabled readonly
                           oninput="calcularVencedorPiramide()" 
                           onclick="carregarTieBreakParaEdicao(2)"
                           onfocus="focarInputArbitragem(this)" 
                           onblur="desfocarInputArbitragem(this)">
                    <span id="view-tb2-j1" class="sb-tb-display"></span>
                </div>

                <input type="tel" class="sb-input super-tb sb-hidden" id="set3-j1" placeholder="" disabled readonly
                       oninput="calcularVencedorPiramide()"
                       onfocus="focarInputArbitragem(this)" 
                       onblur="desfocarInputArbitragem(this)">

                <div class="sb-points-control">
                    <button class="btn-point minus" onclick="ajustarPonto('j1', -1)">−</button>
                    <div class="point-display" id="pontos-j1">0</div>
                    <button class="btn-point plus" onclick="ajustarPonto('j1', 1)">+</button>
                </div>
            </div>

            <div class="sb-row" id="sb-row-p2">
                <div class="sb-name" id="apelido-j2" onclick="toggleSacador('j2')">Jogador 2</div>
                <div class="sb-server-marker" id="server-marker-j2"></div>
                
                <div class="set-input-wrapper">
                    <input type="tel" class="sb-input" id="set1-j2" placeholder="" readonly
                           oninput="calcularVencedorPiramide()" 
                           onclick="carregarTieBreakParaEdicao(1)"
                           onfocus="focarInputArbitragem(this)" 
                           onblur="desfocarInputArbitragem(this)">
                    <span id="view-tb1-j2" class="sb-tb-display"></span>
                </div>

                <div class="set-input-wrapper sb-hidden" id="wrapper-set2-j2">
                    <input type="tel" class="sb-input" id="set2-j2" placeholder="" disabled readonly
                           oninput="calcularVencedorPiramide()" 
                           onclick="carregarTieBreakParaEdicao(2)"
                           onfocus="focarInputArbitragem(this)" 
                           onblur="desfocarInputArbitragem(this)">
                    <span id="view-tb2-j2" class="sb-tb-display"></span>
                </div>

                <input type="tel" class="sb-input super-tb sb-hidden" id="set3-j2" placeholder="" disabled readonly
                       oninput="calcularVencedorPiramide()"
                       onfocus="focarInputArbitragem(this)" 
                       onblur="desfocarInputArbitragem(this)">

                <div class="sb-points-control">
                    <button class="btn-point minus" onclick="ajustarPonto('j2', -1)">−</button>
                    <div class="point-display" id="pontos-j2">0</div>
                    <button class="btn-point plus" onclick="ajustarPonto('j2', 1)">+</button>
                </div>
            </div>
        </div>

        <div class="scoreboard-container" id="simple-score-container">
            <div class="sb-header">
                <div class="sb-col-name" style="padding-left: 10px;"></div>
                <div class="sb-col-set">1</div>
                <div class="sb-col-set">2</div>
                <div class="sb-col-set" id="simple-header-set3" style="display: none;">3</div>
            </div>

            <div class="sb-row simple-row">
                <div class="sb-name simple-name" id="simple-name-j1">Jogador 1</div>
                
                <div class="simple-set-group">
                    <input type="tel" class="sb-input simple-input" id="simple-s1-j1" maxlength="1" value="0"
                           oninput="verificarTieBreakManual(1); calcularVencedorPiramide(); verificarNecessidadeSet3();"
                           onfocus="focarCampoSumula(this, 1)" 
                           onblur="desfocarCampoSumula(this, 1)">
                    
                    <input type="tel" class="sb-input simple-tb-input" id="simple-tb1-j1" placeholder="" maxlength="2" value="0"
                           oninput="calcularVencedorPiramide(); verificarNecessidadeSet3();"
                           onfocus="this.dataset.val = this.value; this.value = '';" 
                           onblur="if(this.value.trim() === '') this.value = this.dataset.val; calcularVencedorPiramide();">
                </div>
                
                <div class="simple-set-group">
                    <input type="tel" class="sb-input simple-input" id="simple-s2-j1" maxlength="1" value="0"
                           oninput="verificarTieBreakManual(2); calcularVencedorPiramide(); verificarNecessidadeSet3();"
                           onfocus="focarCampoSumula(this, 2)" 
                           onblur="desfocarCampoSumula(this, 2)">
                    
                    <input type="tel" class="sb-input simple-tb-input" id="simple-tb2-j1" placeholder="" maxlength="2" value="0"
                           oninput="calcularVencedorPiramide(); verificarNecessidadeSet3();"
                           onfocus="this.dataset.val = this.value; this.value = '';" 
                           onblur="if(this.value.trim() === '') this.value = this.dataset.val; calcularVencedorPiramide();">
                </div>
                
                <div class="simple-set-group" id="simple-group-set3-j1" style="display: none;">
                    <input type="tel" class="sb-input simple-input super-tb" id="simple-s3-j1" maxlength="2" value="0"
                           oninput="calcularVencedorPiramide();"
                           onfocus="focarCampoSumula(this, 3)" 
                           onblur="desfocarCampoSumula(this, 3)">
                </div>
            </div>

            <div class="sb-row simple-row">
                <div class="sb-name simple-name" id="simple-name-j2">Jogador 2</div>
                
                <div class="simple-set-group">
                    <input type="tel" class="sb-input simple-input" id="simple-s1-j2" maxlength="1" value="0"
                           oninput="verificarTieBreakManual(1); calcularVencedorPiramide(); verificarNecessidadeSet3();"
                           onfocus="focarCampoSumula(this, 1)" 
                           onblur="desfocarCampoSumula(this, 1)">
                    
                    <input type="tel" class="sb-input simple-tb-input" id="simple-tb1-j2" placeholder="" maxlength="2" value="0"
                           oninput="calcularVencedorPiramide(); verificarNecessidadeSet3();"
                           onfocus="this.dataset.val = this.value; this.value = '';" 
                           onblur="if(this.value.trim() === '') this.value = this.dataset.val; calcularVencedorPiramide();">
                </div>
                
                <div class="simple-set-group">
                    <input type="tel" class="sb-input simple-input" id="simple-s2-j2" maxlength="1" value="0"
                           oninput="verificarTieBreakManual(2); calcularVencedorPiramide(); verificarNecessidadeSet3();"
                           onfocus="focarCampoSumula(this, 2)" 
                           onblur="desfocarCampoSumula(this, 2)">
                    
                    <input type="tel" class="sb-input simple-tb-input" id="simple-tb2-j2" placeholder="" maxlength="2" value="0"
                           oninput="calcularVencedorPiramide(); verificarNecessidadeSet3();"
                           onfocus="this.dataset.val = this.value; this.value = '';" 
                           onblur="if(this.value.trim() === '') this.value = this.dataset.val; calcularVencedorPiramide();">
                </div>
                
                <div class="simple-set-group" id="simple-group-set3-j2" style="display: none;">
                    <input type="tel" class="sb-input simple-input super-tb" id="simple-s3-j2" maxlength="2" value="0"
                           oninput="calcularVencedorPiramide();"
                           onfocus="focarCampoSumula(this, 3)" 
                           onblur="desfocarCampoSumula(this, 3)">
                </div>
            </div>
        </div>
		
		
        
        <div id="wo-controls" style="display: none;">
            <div class="modern-form-group">
                <label for="select-vencedor-wo">Quem venceu por W.O.?</label>
                <select id="select-vencedor-wo" class="modern-select"></select>
            </div>
            <div class="modern-form-group">
                <label for="select-motivo-wo">Qual o motivo?</label>
                <select id="select-motivo-wo" class="modern-select">
                    <option value="">Selecione...</option>
                    <option value="Não comparecimento">Não comparecimento</option>
                    <option value="Lesão ou Doença (pré-jogo)">Lesão/Doença (antes do jogo)</option>
                    <option value="Desistência do Torneio">Desistência do Torneio</option>
                    <option value="Desqualificação">Desqualificação</option>
                </select>
            </div>
        </div>

        <div id="desistencia-controls" style="display: none;">
            <div class="modern-form-group">
                <label for="select-desistente">Quem desistiu?</label>
                <select id="select-desistente" class="modern-select"></select>
            </div>
            <div class="modern-form-group">
                <label for="select-motivo-desistencia">Motivo da desistência:</label>
                <select id="select-motivo-desistencia" class="modern-select">
                    <option value="">Selecione...</option>
                    <option value="Lesão durante o jogo">Lesão durante o jogo</option>
                    <option value="Mal estar / Doença">Mal estar / Doença</option>
                    <option value="Fadiga extrema">Fadiga extrema</option>
                    <option value="Motivos pessoais">Motivos pessoais</option>
                </select>
            </div>
        </div>
		
		<div class="winner-display">
            <span class="winner-label" id="label-vencedor-final">VENCEDOR DA PARTIDA</span>
            <span id="resultado-vencedor" class="winner-name"></span>
        </div>
        
        <div class="modern-actions">
			<button id="btnSalvarResultado" class="btn-modern btn-save" type="button" onclick="salvarResultadoPiramide()">Salvar</button>
			<button id="btnCancelarResultado" class="btn-modern btn-cancel">Cancelar</button>
		</div>
        
        <div style="display:none;">
            <input id="tb1-j1"><input id="tb1-j2"><input id="tb2-j1"><input id="tb2-j2">
        </div>

    </div>
</div>


<div id="modalToss" class="modal-overlay" style="z-index: 100000;">
    <div class="modal-content" style="max-width: 350px; text-align: center; border-radius: 20px; padding: 30px;">
        <h3 id="tossTitle" style="margin-top: 0; color: #2c3e50; font-size: 1.5rem;">🪙 Toss Inicial</h3>
        <p id="tossMessage" style="color: #7f8c8d; margin-bottom: 25px; font-size: 1rem;">Quem começa sacando?</p>
        
        <div style="display: flex; flex-direction: column; gap: 15px;">
            <button id="btnTossJ1" class="btn-modern" style="background-color: #3498db; color: white; padding: 15px; font-size: 1.1rem;">Jogador 1</button>
            <button id="btnTossJ2" class="btn-modern" style="background-color: #3498db; color: white; padding: 15px; font-size: 1.1rem;">Jogador 2</button>
        </div>
    </div>
</div>



<div class="header-legenda-container">
    <div class="header-legenda-linha">
        
        <div id="agenda-trigger" class="agenda-trigger">
            📅 <span id="agenda-icone">▼</span>
        </div>
        <h2 class="header">Quadra 1 - Coberta</h2> <div id="legenda-trigger" class="legenda-trigger">
            Legenda: <span id="legenda-icone">▼</span>
        </div>
    </div>
    
    <div id="agenda-conteudo" class="agenda-conteudo">
        </div>
    <div id="legenda" class="legenda-conteudo">
        </div>
</div>

<div id="modalDetalhesReserva" class="modal-overlay">
    <div class="modal-content-reserva">
        <span class="close-button" onclick="fecharModalDetalhes()">&times;</span>
        <h3>Detalhes da Reserva</h3>
        <p><strong>Quadra:</strong> <span id="modal-quadra"></span></p>
        <p><strong>Dia:</strong> <span id="modal-dia"></span></p>
        <p><strong>Data:</strong> <span id="modal-data"></span></p>
        <p><strong>Horário:</strong> <span id="modal-horario"></span></p>
        <p><strong>Duração:</strong> <span id="modal-duracao"></span></p>
        <p><strong>Status:</strong> <span id="modal-status"></span></p>
        <p id="p-expira-em" style="display: none;"><strong>Expira em:</strong> <span id="modal-expira-em" style="font-weight: bold; color: #dc3545;"></span></p>
        <p><strong>Organizador(a):</strong> <span id="modal-organizador"></span></p>
        <hr>
        <p style="margin-bottom: 2px;margin-top: -10px;"><strong>Jogadores:</strong></p>
        <div id="modal-jogadores">
        </div>

        <div id="container-convidados" style="display: none; margin-top: 10px;">
            <p style="margin-bottom: 2px; margin-top: 0;"><strong>Convidados:</strong></p>
            <div id="modal-convidados">
                </div>
        </div>
        <div id="modal-resultado-container" style="display: none; margin-top: 15px;">
            <hr>
            <p style="margin-bottom: 0px;margin-top: -10px;"><strong id="modal-resultado-titulo">Resultado do Jogo:</strong></p>
            <div id="modal-resultado-placar">
            </div>
        </div>

        <div id="container-btn-placar-ao-vivo" style="display: none; text-align: center; margin-top: 15px;">
            <hr>
            <button id="btn-placar-ao-vivo" style="background-color: #333; color: white; width: auto !important; padding: 10px 20px; font-weight: bold; border-radius: 5px;">
                📺 Modo Placar
            </button>
        </div>
        
    </div>
</div>

	
<div id="placarAoVivoOverlay" class="placar-ao-vivo-overlay">
    <span class="placar-close-btn-novo" onclick="fecharPlacarAoVivo()">&times;</span>
    <div class="placar-ao-vivo-content">
        <div class="placar-header-novo">
            <h2>Torneio Pirâmide</h2>
            <p id="placar-quadra">Quadra</p>
        </div>

        <div class="placar-body">
            <div class="placar-jogador-linha">
                <span class="placar-jogador-posicao" id="placar-j1-posicao">(0)</span>
                
                <span id="placar-j1-server" class="placar-server-ball"></span>
                <span class="placar-jogador-nome" id="placar-j1-nome">Jogador 1</span>
                <span id="placar-j1-ret" class="ret-indicator-placar-container"></span>
                
                <div class="placar-sets-container" id="placar-j1-sets"> 
                    <span class="placar-set" id="placar-j1-set1">0</span>
                    <span class="placar-set" id="placar-j1-set2">0</span>
                    <span class="placar-set" id="placar-j1-set3"></span>
                </div>

                <span id="placar-j1-points" class="placar-points">0</span>
            </div>

            <div class="placar-jogador-linha">
                <span class="placar-jogador-posicao" id="placar-j2-posicao">(0)</span>
                
                <span id="placar-j2-server" class="placar-server-ball"></span>
                <span class="placar-jogador-nome" id="placar-j2-nome">Jogador 2</span>
                <span id="placar-j2-ret" class="ret-indicator-placar-container"></span>
                
                <div class="placar-sets-container" id="placar-j2-sets"> 
                    <span class="placar-set" id="placar-j2-set1">0</span>
                    <span class="placar-set" id="placar-j2-set2">0</span>
                    <span class="placar-set" id="placar-j2-set3"></span>
                </div>

                <span id="placar-j2-points" class="placar-points">0</span>
            </div>
        </div>

        <div class="placar-footer">
            <p id="placar-vencedor-declaracao" class="placar-vencedor-declaracao"></p>
            
            <div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
                <div>
                    <span class="live-indicator-placar pulsing-live">AO VIVO</span>
                    <span id="placar-mp-alert" class="placar-match-point-alert">MATCH POINT</span>
                </div>

                <span id="placar-espectadores" class="espectadores-counter" style="display: none;">
                    👥 <span id="numero-espectadores">0</span>
                </span>
            </div>

            <p id="placar-motivo-desistencia" class="motivo-resultado-placar"></p>
        </div>

    <p id="placar-motivo-desistencia" class="motivo-resultado-placar"></p>
</div>
    </div>
</div>


<div id="modalAcoesReserva" class="modal-overlay">
    <div class="modal-content">
        <h3 style="margin-top: 0; text-align: center;">O que deseja fazer?</h3>
        
        <button id="btnModalVer" style="background-color: #007bff;">Ver Detalhes</button>
        <button id="btnModalEditar" style="background-color: #ffc107; color: black;">Editar Jogadores</button>
		<button id="btnModalDelegar" style="background-color: #4CAF50; display: none;">Delegar Placar</button> <button id="btnModalResultadoDuplas" style="background-color: #28a745; display: none;">Informar Resultado</button>
		<button id="btnModalExcluir" style="background-color: #dc3545;">Excluir Reserva</button>
        
        <hr style="border: none; border-top: 1px solid #eee; margin: 15px 0;">
        
        <button id="btnModalCancelar" style="background-color: #6c757d;">Cancelar</button>
    </div>
</div> 


<div id="modalDelegacao" class="modal-overlay"> 
    <div class="modal-content">
        <h3 style="margin-top: 0; text-align: center;">Delegar Anotação do Placar</h3>
        <p style="text-align: center; font-size: 0.9em; color: #666;">Selecione um jogador online para permitir que ele atualize as parciais deste jogo.</p>

        <div id="lista-jogadores-online" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-top: 15px; border-radius: 5px;">
            <p style="text-align: center; color: #888;">Carregando...</p>
        </div>

        <div class="botoes-acao-container" style="margin-top: 20px;">
            <button id="btnConfirmarDelegacao" style="background-color: #28a745;">Confirmar</button>
            <button id="btnCancelarDelegacao" style="background-color: #6c757d;">Cancelar</button>
        </div>
    </div>
</div>



<div id="modalEdicaoReserva" class="modal-overlay">
    <div class="modal-content">
        <span class="close-button" onclick="fecharModalEdicao()">&times;</span>
        <h3 style="margin-top: 0; text-align: center;">Editar Jogadores da Reserva</h3>
        
        <div id="edit-jogadores-container">
            </div>

        <div class="edit-modal-actions">
			<button id="btnAdicionarJogadorEdicao" style="background-color: #17a2b8;">Adicionar Jogador</button>
			<button id="btnSalvarEdicao" style="background-color: #28a745;">Salvar Alterações</button>
		</div>
    </div>
</div>

<div id="modalConfirmacaoResultado" class="modal-overlay">
    <div class="modal-content">
        <h3 style="margin-top: 0; text-align: center;">Confirmação de Resultado</h3>
        
        
        <div id="resumo-partida-confirmacao" class="resumo-partida">
            </div>
        
        <div id="placar-informado-confirmacao" style="margin: 15px 0;">
            </div>
        
        <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
			<button id="btnAprovarResultado" style="background-color: #28a745; width: auto !important; padding: 10px 20px;">Aprovar</button>
			<button id="btnDepoisResultado" style="background-color: #6c757d; width: auto !important; padding: 10px 20px;">Depois</button>
			<button id="btnRecusarResultado" style="background-color: #dc3545; width: auto !important; padding: 10px 20px;">Recusar</button>
		</div>
    </div>
</div>


<div id="modalResolucaoArbitro" class="modal-overlay">
    <div class="modal-content">
        <h3 style="margin-top: 0; text-align: center;">Resolução de Disputa (Árbitro)</h3>
        <p style="text-align: center;">O seguinte resultado foi recusado.<br>Analise e tome uma decisão.</p>

        <div id="resumo-partida-arbitro" class="resumo-partida">
            </div>

        <div id="placar-recusado-arbitro" style="margin: 15px 0;">
            </div>

        <div style="display: flex; justify-content: space-around; gap: 10px; margin-top: 20px;">
            <button id="btnAprovarPeloArbitro" style="background-color: #28a745; width: auto !important; padding: 10px 15px;">Aprovar</button>
            <button id="btnEditarPeloArbitro" style="background-color: #ffc107; color: black; width: auto !important; padding: 10px 15px;">Editar</button>
            <button id="btnCancelarPeloArbitro" style="background-color: #dc3545; width: auto !important; padding: 10px 15px;">Cancelar</button>
        </div>
         <hr style="border: none; border-top: 0px solid #eee; margin: 10px 0;">
         <button id="btnFecharArbitro" style="background-color: #6c757d; margin-top: 0;">Depois</button>
    </div>
</div>



<div id="modalResultadoDuplas" class="modal-overlay">
    <div class="modal-content">
        <h3 style="margin-top: 0; text-align: center;">Resultado da Partida de Duplas</h3>
        
        <p id="duplasJogadoresInfo" style="text-align: center; font-style: italic; color: #666;"></p>
        
        <div id="duplasMatchupsContainer" style="margin-top: 20px;">
            </div>
        
        <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
            <button id="btnSalvarDuplas" style="background-color: #28a745; width: auto !important; padding: 10px 20px;">Salvar</button>
            <button id="btnDepoisDuplas" onclick="fecharModalResultadoDuplas()" style="background-color: #6c757d; width: auto !important; padding: 10px 20px;">Depois</button>
            <button id="btnCancelarDuplas" onclick="fecharModalResultadoDuplas()" style="background-color: #dc3545; width: auto !important; padding: 10px 20px;">Cancelar</button>
        </div>
    </div>
</div>



<div class="tabela-container">
<table id="tabelaQuadra" style="width: 100%; margin-top: 10px;"> 
    <tr>
        <th rowspan="2" style="text-align: center;">Horários</th>
        <th>Segunda-Feira</th>
        <th>Terça-Feira</th>
        <th>Quarta-Feira</th>
        <th>Quinta-Feira</th>
        <th>Sexta-Feira</th> 
        <th>Sábado</th>
        <th>Domingo</th>
        <th rowspan="2" style="text-align: center;">Horários</th>
    </tr>
    <tr style="background-color: #f2f2f2;">
        <td style="font-weight: bold; font-size: 0.9em;">09/10/24</td>
        <td style="font-weight: bold; font-size: 0.9em;">10/10/24</td>
        <td style="font-weight: bold; font-size: 0.9em;">11/10/24</td>
        <td style="font-weight: bold; font-size: 0.9em;">12/10/24</td>
        <td style="font-weight: bold; font-size: 0.9em;">13/10/24</td>
        <td style="font-weight: bold; font-size: 0.9em;">14/10/24</td>
        <td style="font-weight: bold; font-size: 0.9em;">15/10/24</td>
    </tr>
    <tbody id="tabelaCorpo">
    <tr>
        <td class="horario">06:00 - 07:00</td>
        <td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Sábado -->
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">06:00 - 07:00</td>
    </tr>
    <tr>
        <td class="horario">07:00 - 08:00</td>
        <td></td><td></td><td></td><td></td><td></td>
        <td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo --> 
        <td class="horario">07:00 - 08:00</td>
    </tr>
    <tr>
        <td class="horario">08:00 - 09:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
        <td class="horario">08:00 - 09:00</td>
    </tr>
    <tr>
        <td class="horario">09:00 - 10:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
        <td class="horario">09:00 - 10:00</td>
    </tr>
    <tr>
        <td class="horario">10:00 - 11:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
        <td class="horario">10:00 - 11:00</td>
    </tr>
    <tr>
        <td class="horario">11:00 - 12:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
        <td class="horario">11:00 - 12:00</td>
    </tr>
    <tr>
        <td class="horario">12:00 - 13:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">12:00 - 13:00</td>
    </tr>
    <tr>
        <td class="horario">13:00 - 14:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">13:00 - 14:00</td>
    </tr>
    <tr>
        <td class="horario">14:00 - 15:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">14:00 - 15:00</td>
    </tr>
    <tr>
        <td class="horario">15:00 - 16:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">15:00 - 16:00</td>
    </tr>
    <tr>
        <td class="horario">16:00 - 17:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">16:00 - 17:00</td>
    </tr>
    <tr>
        <td class="horario">17:00 - 18:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">17:00 - 18:00</td>
    </tr>
    <tr>
        <td class="horario">18:00 - 19:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">18:00 - 19:00</td>
    </tr>
    <tr>
        <td class="horario">19:00 - 20:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">19:00 - 20:00</td>
    </tr>
    <tr>
        <td class="horario">20:00 - 21:00</td>
        <td></td><td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">20:00 - 21:00</td>
    </tr>
    <tr>
        <td class="horario">21:00 - 22:00</td>
        <td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Sábado -->
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">21:00 - 22:00</td>
    </tr>
    <tr>
        <td class="horario">22:00 - 23:00</td>
        <td></td><td></td><td></td><td></td><td></td>
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Sábado -->
        <td style="background-color: #f2f2f2; pointer-events: none; cursor: not-allowed;"></td> <!-- Domingo -->
        <td class="horario">22:00 - 23:00</td>
    </tr>
</tbody>

</table>
</div>
</div>


<div id="birthdayModalOverlay" class="modal-overlay">
    <div id="birthdayModalContent">
        <span id="birthdayAge" class="birthday-badge"></span>
        <h2>Feliz Aniversário, <span id="birthdayName"></span>!</h2>
        <p>O Clube Olímpico e todos os seus amigos do tênis desejam a você um dia espetacular, cheio de alegrias e grandes jogadas!</p>
  		<p style="font-size: 2em; margin: 10px 0;">🥳🎉🎂🎾</p>
        <button id="closeBirthdayModal">Obrigado!</button>
    </div>
</div>

<div id="modalConfirmacaoOverlay" class="modal-overlay">
    <div class="modal-content">
        <h3 style="margin-top: 0; text-align: center;">Confirmação</h3>
        <p id="modalConfirmacaoMensagem" style="text-align: center; line-height: 1.5; font-size: 1.1em;"></p>
        
        <div class="modal-botoes-container" style="display: flex; justify-content: center; gap: 15px; margin-top: 25px;">
            <button id="btnCancelarAcao" style="background-color: #6c757d; width: auto !important; padding: 10px 25px;">Cancelar</button>
            <button id="btnConfirmarAcao">Confirmar</button>
        </div>
    </div>
</div>


<div id="modalInputNomeOverlay" class="modal-overlay">
    <div class="modal-content" style="max-width: 400px;">
        <h3 id="modalInputNomeTitulo" style="margin-top: 0; text-align: center;">Identificar Convidado</h3>
        <p id="modalInputNomeMensagem" style="text-align: center; font-size: 0.9em; color: #666; margin-bottom: 20px;">
            Por favor, digite o nome completo do convidado:
        </p>
        
        <input type="text" id="inputNomeConvidado" class="convidado-nome-input" oninput="this.value = this.value.toUpperCase()" placeholder="NOME DO CONVIDADO">
        
        <div style="display: flex; justify-content: center; gap: 10px; margin-top: 25px;">
            <button id="btnConfirmarInputNome" style="background-color: #28a745; width: auto !important; padding: 10px 20px;">Confirmar</button>
            <button id="btnCancelarInputNome" style="background-color: #6c757d; width: auto !important; padding: 10px 20px;">Cancelar</button>
        </div>
    </div>
</div>



<div id="infoModalOverlay" class="modal-overlay">
    <div id="infoModalContent">
        <h3>Sobre o Sistema</h3>

        <div class="info-section">
			<div class="user-logout-line" style="display: flex; align-items: center;">
				<div style="text-align: left; flex-grow: 1;">
					<p style="margin: 0;"><strong>Login:</strong> <span id="info-modal-user-name">...</span></p>
					<p style="margin: 4px 0 0 0;"><strong>Apelido:</strong> <span id="info-modal-apelido">...</span></p>
				</div>
				
				<button id="inlineLogoutBtn" title="Fazer logout" style="background: none; border: none; cursor: pointer; padding: 5px; transform: scale(1.1);">
					<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="color: #d32f2f;">
						<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
						<polyline points="16 17 21 12 16 7"></polyline>
						<line x1="21" y1="12" x2="9" y2="12"></line>
					</svg>
				</button>
			</div>
			<p><strong>Administradores do Sistema:</strong><br><span id="info-modal-admins">Carregando...</span></p>
			<p><strong>Árbitro Pirâmide:</strong> <span id="info-modal-arbitro">Carregando...</span></p>
		</div>

        <hr class="info-separator">

        <div class="info-section">
            <h4>Links Rápidos</h4>
            <ul class="quick-links">
				<li><a href="https://wa.me/5541999176972" target="_blank">Admin Sistema (Ronaldo Taborda)</a></li>
				<li><a href="https://wa.me/5541999478950" target="_blank">Admin Pirâmide (Edemar Titschkowski)</a></li>
				<li><a href="https://wa.me/5541998409631" target="_blank">Árbitro Pirâmide (Lenardo Carrara)</a></li
     		</ul>
        </div>

        <hr class="info-separator">

        <div class="info-section about-section">
            <p><strong>Versão do Sistema:</strong> <span id="info-modal-version">Carregando...</span></p>
            <p><strong>Atualizado em:</strong> <span id="info-modal-data-versao">Carregando...</span></p> <p>Desenvolvido por Ronaldo Taborda</p>
        </div>

        <button id="infoModalCloseBtn">Fechar</button>
    </div>
</div>


<div id="modal-mensagens" class="modal-overlay" style="display: none;">
    <div class="modal-content modal-grande">
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0;">🔔 Mural de Avisos</h3>
            <span class="close-button" onclick="fecharMuralMensagens()" style="position: static; font-size: 28px; cursor: pointer;">&times;</span>
        </div>

        <div id="admin-area-mensagens" style="display: none; padding: 15px; background: #f0f8ff; border: 1px solid #cce5ff; border-radius: 8px; margin-bottom: 15px;">
            <button onclick="mostrarFormularioMensagem()" style="width:100%; background-color: #007bff; color: white; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">✍️ Escrever Nova Mensagem</button>
            
            <div id="form-nova-mensagem" style="display: none; margin-top: 15px;">
                <input type="text" id="msg-titulo" placeholder="Título do Aviso" style="width: 100%; margin-bottom: 10px; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px;">
                <textarea id="msg-texto" rows="4" placeholder="Mensagem..." style="width: 100%; margin-bottom: 10px; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px;"></textarea>
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="enviarMensagemFirebase()" style="flex: 1; background-color: #28a745; color: white; padding: 10px; border-radius: 5px;">Enviar</button>
                    <button onclick="ocultarFormularioMensagem()" style="flex: 1; background-color: #6c757d; color: white; padding: 10px; border-radius: 5px;">Cancelar</button>
                </div>
            </div>
        </div>

        <div id="lista-mensagens" class="lista-msg-container">
            <p style="text-align: center; color: #888;">Carregando avisos...</p>
        </div>
    </div>
</div>




<footer style="text-align: center; margin-top: 20px; font-size: 0.9em; color: #555;">
    <div id="VersaoSistema" style="text-align: right; margin-top: 70px; margin-right: 10px; font-size: 1rem; cursor: default; position: relative; z-index: 1001;">
    </div>
    Desenvolvido por Ronaldo Taborda
</footer>


<button id="fab-toggle-form">+</button>
<button id="theme-toggle-button">🌙</button>


<div id="notificacao" class="notificacao"></div>



<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script> 
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>   
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>



<script>
        
document.addEventListener('DOMContentLoaded', function () {
    const toggleButton = document.getElementById('toggleSenha');
    const senhaInput = document.getElementById('acesso_user'); // ID novo

    if (toggleButton && senhaInput) {
        toggleButton.addEventListener('click', function () {
            // Verificamos se as bolinhas estão ativas no CSS
            // Usamos getComputedStyle para ler o estado real, seja no PC ou Celular
            const estiloAtual = window.getComputedStyle(senhaInput).webkitTextSecurity;
            
            if (estiloAtual !== 'none') {
                // MOSTRAR: Remove as bolinhas
                senhaInput.style.setProperty('-webkit-text-security', 'none', 'important');
                senhaInput.style.setProperty('text-security', 'none', 'important');
                toggleButton.textContent = '🙈';
            } else {
                // ESCONDER: Volta as bolinhas
                senhaInput.style.setProperty('-webkit-text-security', 'disc', 'important');
                senhaInput.style.setProperty('text-security', 'disc', 'important');
                toggleButton.textContent = '👁️';
            }
        });
    }


    const notificacaoElement = document.getElementById('notificacao');
    if (notificacaoElement) {
        // Adiciona o "ouvinte" de clique ao elemento da notificação
        notificacaoElement.addEventListener('click', () => {
            // Remove a classe .show, o que ativa a animação de saída do CSS
            notificacaoElement.classList.remove('show');
            
            // Também cancela o timer que a faria desaparecer sozinha, por segurança
            clearTimeout(notificacaoTimer);
        });
    }
});

document.addEventListener('DOMContentLoaded', function () {
    // ... (seu código existente do toggleSenha está aqui) ...


    // ==============================================
    // --- INÍCIO DO CÓDIGO DA ETAPA 2 (PAINEL FAB + FECHAR) ---
    // ==============================================
    
    const fabToggleBtn = document.getElementById('fab-toggle-form');
    const formContainer = document.querySelector('.form-container');
    const formBackdrop = document.getElementById('formBackdrop'); 
    const closeFormBtn = document.querySelector('.close-form-btn'); // <--- NOVO: Pegamos o botão X

    // Verifica se os elementos essenciais existem
    if (fabToggleBtn && formContainer) {
        
        // Função Centralizada para fechar o formulário
        const fecharFormulario = () => {
            formContainer.classList.remove('visible');
            if (formBackdrop) formBackdrop.classList.remove('visible');
            fabToggleBtn.classList.remove('active');
            
            // Rola a tela para o topo
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        // 1. Clique no Botão Flutuante (+)
        fabToggleBtn.addEventListener('click', (e) => {
            if (navigator.vibrate) navigator.vibrate(50);
            
            // Fecha painéis da Agenda/Legenda se estiverem abertos
            if (typeof legendaConteudo !== 'undefined' && legendaConteudo && legendaConteudo.style.display === 'block') {
                legendaConteudo.style.display = 'none';
                legendaTrigger.classList.remove('expandido');
            }
            if (typeof agendaConteudo !== 'undefined' && agendaConteudo && agendaConteudo.style.display === 'block') {
                agendaConteudo.style.display = 'none';
                agendaTrigger.classList.remove('expandido');
            }

            const isVisible = formContainer.classList.contains('visible');

            if (isVisible) {
                fecharFormulario();
            } else {
                // --- INÍCIO DA MUDANÇA: O Porteiro ---
                
                // 1. Verifica se devemos pular o porteiro (ex: clicou em "Jogo" no menu do Admin)
                const skipGatekeeper = e.detail && e.detail.skipGatekeeper;
                
                let podeAbrir = false;
                
                if (skipGatekeeper) {
                    podeAbrir = true; // Veio do menu, libera geral
                } else {
                    // Pergunta ao porteiro: "Posso abrir direto?"
                    // Se for Erick (só manutenção) -> Retorna false e mostra menu (Jogo/Manut)
                    // Se for Vania (professora) -> Retorna false e mostra menu (Jogo/Admin)
                    // Se for Sócio -> Retorna true
                    podeAbrir = verificarPermissoesBotaoMais(); 
                }


                // 2. Se o porteiro liberou
                if (podeAbrir) {
                    limparCampos(); 

                    // --- NOVO: Preenche a quadra com a aba ativa ---
                    if (typeof quadraSelecionada !== 'undefined') {
                        document.getElementById('quadra').value = quadraSelecionada;
					
					atualizarOpcoesHorario();
                    }
                    // -----------------------------------------------

                    carregarJogadores(); 

                    // Preenche Jogador 1 (Logado)
                    try {
                        const jogadorLogadoNome = localStorage.getItem('jogadorLogado');
                        if (jogadorLogadoNome && typeof jogadoresData !== 'undefined') {
                            const apelidoDoLogado = Object.keys(jogadoresData).find(
                                apelido => jogadoresData[apelido].nomeCompleto.toUpperCase() === jogadorLogadoNome.toUpperCase()
                            );
                            if (apelidoDoLogado) {
                                document.getElementById('jogador1').value = apelidoDoLogado;
                            }
                        }
                    } catch (e) {}

                    formContainer.classList.add('visible');
                    if (formBackdrop) formBackdrop.classList.add('visible');
                    fabToggleBtn.classList.add('active');
                    
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
                // --- FIM DA MUDANÇA ---
            }
        });

        // 2. Clique no Fundo Escuro para fechar
        

        // 3. Clique no Botão "X" para fechar (NOVO)
        if (closeFormBtn) {
            closeFormBtn.addEventListener('click', () => {
                fecharFormulario();
            }); 
        }
    }
    // ============================================
    // --- FIM DO CÓDIGO DA ETAPA 2 ---
    // ============================================
    
});



// --- CÓDIGO PARA O PAINEL "SOBRE O SISTEMA" ---
const gatilhoPainel = document.getElementById('VersaoSistema');
const modalOverlay = document.getElementById('infoModalOverlay');
const closeBtn = document.getElementById('infoModalCloseBtn');
//const logoutBtn = document.getElementById('infoModalLogoutBtn');
const logoutBtn = document.getElementById('inlineLogoutBtn'); 


if (gatilhoPainel && modalOverlay && closeBtn && logoutBtn) {
    const userNameSpan = document.getElementById('info-modal-user-name');
    const apelidoSpan = document.getElementById('info-modal-apelido'); // <--- Novo Elemento
    const versionSpan = document.getElementById('info-modal-version');
    const adminsSpan = document.getElementById('info-modal-admins'); 
    const arbitroSpan = document.getElementById('info-modal-arbitro');
    const dataVersaoSpan = document.getElementById('info-modal-data-versao');

    const fecharModal = () => {
        modalOverlay.style.display = 'none';
    };

    gatilhoPainel.addEventListener('dblclick', () => {
        if (navigator.vibrate) navigator.vibrate(50);
        
        const jogadorLogado = localStorage.getItem('jogadorLogado') || 'Não identificado';
        
        // 1. Busca os dados completos do usuário logado na memória
        // O 'jogadorLogado' é o Nome Completo. Precisamos achar a chave (Apelido).
        let apelidoEncontrado = jogadorLogado;
        let dadosLogado = null;

        if (typeof jogadoresData !== 'undefined') {
            // Procura qual chave (apelido) tem esse nome completo
            const chave = Object.keys(jogadoresData).find(k => jogadoresData[k].nomeCompleto === jogadorLogado);
            if (chave) {
                apelidoEncontrado = chave; // Ex: "Adriano Feitosa"
                dadosLogado = jogadoresData[chave];
            }
        }

        // 2. Monta a lista de abreviações dos perfis ativos
        let textoAbreviacao = "Sócio"; // Padrão
        
        if (dadosLogado && dadosLogado.perfis) {
            const perfisAtivos = Object.keys(dadosLogado.perfis).filter(k => dadosLogado.perfis[k] === true);
            
            if (perfisAtivos.length > 0) {
                // Mapeia os nomes técnicos para as abreviações da configuração global
                const abreviacoes = perfisAtivos.map(perfil => {
                    if (typeof perfisConfigGlobal !== 'undefined' && perfisConfigGlobal[perfil]) {
                        return perfisConfigGlobal[perfil].abreviacao || perfil;
                    }
                    return perfil; // Fallback se não achar config
                });
                textoAbreviacao = abreviacoes.join(', ');
            }
        }

        // 3. Preenche na tela (Separado)
        userNameSpan.textContent = jogadorLogado.toUpperCase(); // Linha 1: ADRIANO GOMES FEITOSA
        
        if (apelidoSpan) {
            apelidoSpan.textContent = `${apelidoEncontrado} (${textoAbreviacao})`; // Linha 2: Adriano Feitosa (Prof)
        }

        versionSpan.textContent = VersaoSistema;
        dataVersaoSpan.textContent = DataVersaoSistema;

        // 4. Lista de Admins Dinâmica (Mantido seu código original)
        const listaAdminsDinamic = Object.values(jogadoresData).filter(j => {
            if (!j.perfis) return false;
            return Object.keys(j.perfis).some(pName => 
                j.perfis[pName] === true && perfisConfigGlobal[pName]?.permissoes?.super_admin === true
            );
        }).map(j => capitalizarNome(j.nomeCompleto));
        
        if (!listaAdminsDinamic.some(n => n.toUpperCase().includes("RONALDO TABORDA"))) {
            listaAdminsDinamic.push("Ronaldo Taborda (Master)");
        }
        adminsSpan.textContent = listaAdminsDinamic.join(', ') || "Nenhum definido"; 

        // 5. Lista de Árbitros Dinâmica (Mantido seu código original)
        const listaArbitrosDinamic = Object.values(jogadoresData).filter(j => {
            if (!j.perfis) return false;
            return Object.keys(j.perfis).some(pName => {
                const perfilAtivo = j.perfis[pName] === true;
                const nomeNormalizado = pName.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
                return perfilAtivo && nomeNormalizado === 'arbitro';
            });
        }).map(j => capitalizarNome(j.nomeCompleto));

        arbitroSpan.textContent = listaArbitrosDinamic.join(', ') || "Não definido"; 

        modalOverlay.style.display = 'flex';
    });
	
    // Listeners dos botões (Mantidos)
    // Listener do botão de Logout (Ajustado para manter tela Sobre aberta)
    logoutBtn.addEventListener('click', () => { 
        if (navigator.vibrate) { navigator.vibrate(50); }
        
        // NÃO fechamos mais o modal "Sobre" aqui.
        // Ele fica aberto no fundo. Se o usuário confirmar o logout, a página recarrega mesmo.
        // Se ele cancelar o logout, ele verá a tela "Sobre" novamente.
        
        if (typeof confirmarLogout === 'function') {
            confirmarLogout(); 
        } else {
            // Fallback caso não tenha função customizada
            if (confirm("Deseja realmente sair do sistema?")) {
                fazerLogout();
            }
        }
    });
    closeBtn.addEventListener('click', () => {
        if (navigator.vibrate) { navigator.vibrate(50); }
        fecharModal();
    });
    modalOverlay.addEventListener('click', (event) => {
        if (event.target === modalOverlay) {
            fecharModal();
        }
    });
}


document.addEventListener('DOMContentLoaded', function () {
    
    // ... (código do toggleSenha, código do FAB, etc.) ...

    // --- CÓDIGO DO PAINEL "SOBRE O SISTEMA" ---
    const gatilhoPainel = document.getElementById('VersaoSistema');
    // ... (mais código) ...
    if (gatilhoPainel && modalOverlay && closeBtn && logoutBtn) {
        // ... (toda a lógica de clique do painel) ...
        modalOverlay.addEventListener('click', (event) => {
            if (event.target === modalOverlay) {
                fecharModal();
            }
        });
    }
    // --- FIM DO BLOCO "SOBRE O SISTEMA" ---


    // ==========================================================
    // COLE O NOVO BLOCO AQUI
    // ==========================================================
    // Conecta os botões do novo modal de input de nome
    const btnConfirmarInput = document.getElementById('btnConfirmarInputNome');
    if (btnConfirmarInput) {
        btnConfirmarInput.onclick = confirmarNomeConvidado;
    }

    const btnCancelarInput = document.getElementById('btnCancelarInputNome');
    if (btnCancelarInput) {
        btnCancelarInput.onclick = cancelarNomeConvidado;
    }

    // Permite fechar clicando fora
    const modalInputOverlay = document.getElementById('modalInputNomeOverlay');
    if (modalInputOverlay) {
        modalInputOverlay.addEventListener('click', (event) => {
            if (event.target === modalInputOverlay) {
                cancelarNomeConvidado();
            }
        });
    }

    // Permite confirmar com "Enter"
    const inputNomeModal = document.getElementById('inputNomeConvidado'); 
    if (inputNomeModal) {
        inputNomeModal.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Impede o envio de formulário
                confirmarNomeConvidado(); 
            }
        });
    }
    // ==========================================================
    // FIM DO NOVO BLOCO
    // ==========================================================


}); // <--- ESTA É A LINHA FINAL DE TODO O BLOCO


</script>
	
	
<script>
	

// Ajuste manual da atualização de versão do Sistema ******

const VersaoSistema = 'v2.1.5'; // Versão atual do sistema     
const DataVersaoSistema = '12/02/2026';     

let vDesabilitarF12 = true; // deixar true para fazer o deploy    
let vAbrirSistema = true; // deixar true para fazer o deploy
let vPermitirExclusaoAposJogo = false; // Mude para true para permitir que usuários comuns excluam jogos passados durante os testes.

//******************************************************** 

let piramideInicioTorneio = null;    
let piramideFimTorneio = null;
let piramideAtivaGlobal = false; 

let vatualizarOpcoesHorario = true; // inicialmente atualizar o campo Horário 
//let vDomingoAnterior = null;
//let vDomingoAteAnterior = null;
let stringConfiguracaoAnterior = ""; // Nova memória universal

// Variáveis globais que são configuradas em configuracoes.html
window.DiasParaLimpar = undefined; // Ajuste conforme necessário (1,2,3,4,5,6). Ex: se DiasParaLimpar = 4, só é permitido fazer reserva em até 2 dias de antecedência.
let vLimparDiasAnteriores = false;
window.vDomingo = undefined; // Valor padrão: fechado, pois o clube não abre aos domingos ("aberto", "fechado").

const jogadoresRestritos = ["YURI HARDER", "EDUARDO BERGMAN","BIANCA KROKER","MANUELA KROKER","WILMAR KROKER"]; // jogadores que só tem acesso às quadra 1 e 2.


let quadrasInativas = new Set();
let reservasPorQuadra = {};
let quadraSelecionada = 'Quadra 1 - Coberta'; 
let duplasConfigGlobais = {}; 
let convidadoConfigGlobais = {};
let bloqueiosQuadra = {};
let horasParaExpirarConfig = 2; // Define um padrão de 2 horas
let vReservasPorConfirmacao = false; // Padrão: desligado
let edicaoOrganizadorAtiva = false;

//let quebraHorarioDomingoConfig = { ativa: true, quadras: {} };
let otimizacaoGlobal = { ativa: false, quadras: {} };

let exclusaoEmAndamento = false;
let agendamentoEmAndamento = false;
//let administradores = [];
let rankingDuplasAtivo = false;
let delegacaoEmAndamento = null; // Variável para guardar o contexto da delegação
let listenerJogadoresOnline = null; // Variável para controlar o monitoramento em tempo real

let modoResultado = 'placar'; // Controla se o modal está em modo Jogo Normal, W.O. ou Desistência
let isArbitroEditing = false; // Controla o fluxo de edição do árbitro

let clickTimer = null;
let notificacaoTimer;
let timerContadorExpiracao = null;
let listenerDetalhesReserva = null;
let listenerPlacarAoVivo = null;

let legendaTrigger = null;
let legendaConteudo = null;
let agendaTrigger = null;
let agendaConteudo = null;

// Variáveis para controlar o monitoramento em tempo real da Agenda
let agendaListenerRef = null;
let agendaCallback = null;


// Variáveis globais para o monitoramento de espectadores
let espectadorRef = null;
let contadorEspectadoresRef = null;
let contadorEspectadoresCallback = null;

// Variável global para mapear IDs de <select> para nomes de convidados formatados
let nomesConvidadosMap = {};
// Esta variável vai guardar qual <select> (jogador1, jogador2...) está sendo editado
let elementoSelectConvidadoAtual = null;

// Variável global para controlar a atualização do placar ao girar a tela
let funcaoAtualizarPlacarDetalhes = null;

// --- VARIÁVEIS GLOBAIS DE AUTOMAÇÃO ---
let debounceTimer = null; // O cronômetro do salvamento


let totalMensagensAtivas = 0; // Controla a quantidade de avisos para bloquear o clique

let ultimoSnapshotMsg = null; // Guarda os dados do Firebase na memória

// =================================================================
// === 1. LÓGICA DO PLACAR (Pontos e Games) ===
// =================================================================

// Estado inicial dos pontos do game atual
let estadoPontos = {
    j1: 0, // 0, 1(15), 2(30), 3(40), 4(Ad)
    j2: 0,
    tiebreakMode: false
};

const mapaPontos = { 0: '0', 1: '15', 2: '30', 3: '40', 4: 'Ad' };


// ---  Carrega os Horários Padrão e Especiais ---
let horariosGlobal = { Padrao: {}, Especiais: {} };


// --- Carrega a Configuração de Aulas --
let configAulasGlobal = {};


// --- VARIÁVEIS GLOBAIS DE PERFIS ---
let perfisConfigGlobal = {}; // Armazena as regras de cada perfil (o que pode fazer)


//***********************************************************************************************************************************************************************

if (vDesabilitarF12) {
  // Bloqueia o menu de contexto e o acesso ao console
  document.addEventListener('contextmenu', event => event.preventDefault());
  document.addEventListener('keydown', event => {
    if (event.key === "F12" || (event.ctrlKey && event.shiftKey && event.key === "I")) {
      event.preventDefault();
    }
  });
} else {
  // O código está comentado (não será executado)
  /*
  document.addEventListener('contextmenu', event => event.preventDefault());'
  document.addEventListener('keydown', event => {
    if (event.key === "F12" || (event.ctrlKey && event.shiftKey && event.key === "I")) {
      event.preventDefault();
    }
  });
  */
}


// Configuração do Firebase
const firebaseConfig = {
    apiKey: "SUA_API_KEY",
    authDomain: "agenda-5ce95.firebaseapp.com",
    projectId: "agenda-5ce95",
    storageBucket: "agenda-5ce95.appspot.com",
    messagingSenderId: "852007565195",
    appId: "1:852007565195:web:d7bd789d140858f53f618e"
};

// Inicialização do Firebase
const app = firebase.initializeApp(firebaseConfig);
const database = firebase.database();


// Configuração inicial do banco de dados
function inicializarEstruturaInicial() { 
    const estruturaInicial = {
        config: {
            DiasParaLimpar: 4, // Valor padrão
            vDomingo: "fechado", // Padrão fechado
            Quadras: {
                Quadra1: "liberada",
                Quadra2: "liberada",
                Quadra3: "liberada",
            },
        },
        reservas: {
            "Quadra 1 - Coberta": {},
            "Quadra 2 - Aberta": {},
            "Quadra 3 - Coberta": {},
        },
    };

    database.ref("sistemas").set(estruturaInicial)
        .then(() => {
            console.info("Estrutura inicial criada com sucesso no Firebase.");
        })
        .catch((error) => {
            console.error("Erro ao criar estrutura inicial no Firebase:", error);
        });
}

// ====== COLE ESTA NOVA FUNÇÃO NO LUGAR DA ANTIGA ======
// ====== SUBSTITUA NOVAMENTE a função atualizaLegenda POR ESTA ======
function atualizarLegenda(piramideAtiva) {
    const legendaContainer = document.getElementById('legenda'); // Usa o ID do container de conteúdo
    if (!legendaContainer) {
        console.error("Container da legenda (#legenda) não encontrado!");
        return;
    }

    // LÓGICA DE CORES DO TEMA (mantida)
    const isDarkMode = document.body.classList.contains('dark-mode');
    const cor1h = isDarkMode ? 'mediumseagreen' : 'lightgreen';
    const cor2h = isDarkMode ? 'CornflowerBlue' : 'lightblue';
    const corAula = isDarkMode ? '#CD5C5C' : 'lightcoral';
    const corPiramide = isDarkMode ? 'goldenrod' : '#FFEB99';

    // Limpa o conteúdo anterior e adiciona o título interno
    legendaContainer.innerHTML = '<strong style="font-size: 14px;">Legenda:</strong>';

    // Cria um ÚNICO div para conter todos os itens da legenda lado a lado
    const itensContainer = document.createElement('div');
    itensContainer.className = 'legenda-itens-linha-unica'; // Nova classe para estilização

    // Define os itens da legenda
    const itens = [
        { cor: cor1h, texto: '1 Hora' },
        { cor: cor2h, texto: '2 Horas' },
        { cor: corAula, texto: 'Aula' } // Ajuste o texto se precisar incluir "Bloqueado"
    ];

    // Adiciona Pirâmide APENAS se estiver ativa
    if (piramideAtiva) {
        itens.push({ cor: corPiramide, texto: 'Pirâmide' });
    }

    // Cria e adiciona cada item (ícone + texto) ao container
    itens.forEach(item => {
        const itemSpan = document.createElement('span');
        itemSpan.className = 'legenda-item'; // Classe para cada par ícone+texto
        itemSpan.innerHTML = `
            <span class="legenda-icone-cor" style="background-color: ${item.cor};"></span>
            <span class="legenda-texto">${item.texto}</span>
        `;
        itensContainer.appendChild(itemSpan);
    });

    // Adiciona o container com todos os itens ao container principal da legenda
    legendaContainer.appendChild(itensContainer);
}
// ====== FIM DA NOVA FUNÇÃO ======



function removerSessoesAntigas() {
    const usuariosRef = database.ref('sistemas/usuariosOnline');
    const agora = Date.now();
    const limiteTempo = 3 * 60 * 60 * 1000; //  sessões de mais de 3 horas serão excluídas

    console.log("⏳ Iniciando verificação de sessões antigas...");


    usuariosRef.once('value', snapshot => {
        const usuarios = snapshot.val();

        if (!usuarios) {
            console.log("✅ Nenhum usuário online encontrado.");
            return;
        }

        Object.entries(usuarios).forEach(([id, sessao]) => {
            const timestampSessao = sessao.timestamp || 0;
            const diff = agora - timestampSessao;

            if ((agora - timestampSessao) > limiteTempo) {
				console.warn(`🗑️ Sessão antiga detectada! Tentando remover ${id} (${sessao.usuario})`);

				database.ref(`sistemas/usuariosOnline/${id}`).remove()
					.then(() => {
						console.log(`✅ Sessão ${id} removida com sucesso do banco.`);
					})
					.catch((error) => {
						console.error(`❌ Erro ao remover sessão ${id}:`, error);
					});
			} else {
				console.log(`✅ Sessão ainda válida. Mantida no sistema.`);
			}
        });
    });
}




let githubToken = ''; // Variável global para armazenar o token

// Inicialização do sistema
function InicializarSistema() {
    return new Promise((resolve, reject) => {
        const sistemaRef = database.ref("sistemas"); 

        sistemaRef.on('value', (snapshot) => {
            const data = snapshot.val();

            if (data) {
                const minVersion = data.version;
				if (VersaoSistema !== minVersion) {
					const overlay = document.getElementById('versao-desatualizada-overlay');
					if (overlay) {
						overlay.querySelector('h1').textContent = 'Versão Desatualizada';
						overlay.querySelector('p').textContent = 'Por favor, feche e reabra o aplicativo para aplicar a atualização.';
						overlay.style.display = 'flex'; 
					}
					return; // Interrompe o carregamento
				}

                const config = data.config;
				
				// --- NOVO: Carrega os Horários Padrão e Especiais ---
				horariosGlobal = config.Horarios || { Padrao: {}, Especiais: {} };
				// ----------------------------------------------------
				
				// Aqui está o "segredo": Se config.Horarios.Aulas não existir, usamos {} (vazio)
                configAulasGlobal = config.Horarios?.Aulas || {};
				// ----------------------------------------------------
				
				// --- CARREGA AS REGRAS DOS PERFIS ---
				perfisConfigGlobal = config.Perfis || {}; 
				// ------------------------------------
				
				vReservasPorConfirmacao = config.ReservasPorConfirmacao || false; // Lê o interruptor do banco
				
				//vReservasPorConfirmacao = true;  //uso para testar as reservas por confirmação
				
				horasParaExpirarConfig = config.horasParaExpirar || 2; // Lê o valor do banco ou usa 2 como padrão
				edicaoOrganizadorAtiva = config.OrganizadorEdicao || false;
				
				//quebraHorarioDomingoConfig = config.QuebraDeHorarioDomingo || { ativa: true, quadras: {} }; 
				otimizacaoGlobal = config.OtimizacaoHorarios || { ativa: false, quadras: {} };
				
					
				githubToken = config.githubToken;
				
						
				verificarConvitesPendentes(data.reservas);
                verificarConfirmacoesResultado(data.reservas); 
				verificarDisputasArbitro(data.reservas);
				verificarNotificacoes(); 
			   
			   if (vAbrirSistema) {
				  // A verificação de manutenção só roda se a "chave mestra" do desenvolvedor estiver LIGADA
				  if (config && config.Abrir === false) {
					const overlay = document.getElementById('versao-desatualizada-overlay');
					if (overlay) {
						overlay.querySelector('h1').textContent = 'Sistema em Manutenção';
						overlay.querySelector('p').textContent = 'O sistema está passando por uma manutenção provisória. Por favor, tente novamente mais tarde.';
						overlay.style.display = 'flex';
					}
					return; // Interrompe o carregamento
				  }
				}
		        
				

                // Verifica se a pirâmide está ativa (em tempo real)
                const piramideAtiva = config?.Piramide?.ativa || false; // Valor padrão: false
				piramideAtivaGlobal = piramideAtiva;
				piramideInicioTorneio = config?.Piramide?.inicio || null;
				piramideFimTorneio = config?.Piramide?.fim || null;
                const duracaoSelect = document.getElementById('duracao');
                const piramideOption = duracaoSelect?.querySelector('option[value="3-piramide"]');

                if (piramideOption) {
                    piramideOption.style.display = piramideAtiva ? 'block' : 'none'; // Mostra ou oculta a opção "Pirâmide"
                }
                
                // Atualiza a legenda com base no estado da Pirâmide
                atualizarLegenda(piramideAtiva);
                
                if (piramideAtiva) {
                    window.config = window.config || {};
                    window.config.Piramide = config.Piramide;
                }

                if (config) {
                    window.DiasParaLimpar = config.DiasParaLimpar || 4;
                    //window.vDomingo = config.vDomingo || "fechado";
                    //window.vDomingoAte = config.vDomingoAte || "23:00"; // Valor padrão caso não esteja definido
					//window.vDomingo = config.vDomingo || "fechado";
					//window.vDomingoAte = config.vDomingoAte || "23:00";

					// --- NOVA LÓGICA DE DETECÇÃO UNIVERSAL ---
                    // Converte toda a configuração recebida em texto para comparar
                    const stringConfiguracaoAtual = JSON.stringify(config);

                    // Verifica se houve mudança desde a última vez
                    // A primeira verificação (string vazia) não conta, pois o sistema está carregando
                    if (stringConfiguracaoAnterior !== "" && stringConfiguracaoAtual !== stringConfiguracaoAnterior) {
                        console.log("♻️ Configuração alterada! Atualizando dropdown de horários...");
                        atualizarOpcoesHorario(); 
					// 2. O PULO DO GATO: Destrava a limpeza para que ela rode novamente agora
                        vLimparDiasAnteriores = false;
                    }

                    // Atualiza a memória para a próxima verificação
                    stringConfiguracaoAnterior = stringConfiguracaoAtual;
                    // ------------------------------------------
					
					duplasConfigGlobais = config.Duplas || {}; // Carrega a config de Duplas na variável global
					
				    convidadoConfigGlobais = config.Convidados || {}; // Carrega a config de Convidados
					
					rankingDuplasAtivo = config.Duplas?.Ranking || false;
					
					bloqueiosQuadra = config.Quadras?.Bloqueios || {};  // Carrega a config de Bloqueios
					
                    quadrasInativas.clear();
                    const quadras = config.Quadras || {};
                    if (quadras.Quadra1 === "interditada") quadrasInativas.add("Quadra 1 - Coberta");
                    if (quadras.Quadra2 === "interditada") quadrasInativas.add("Quadra 2 - Aberta");
                    if (quadras.Quadra3 === "interditada") quadrasInativas.add("Quadra 3 - Coberta");

                    // 2. AGORA CHAMAMOS A FUNÇÃO (LOCAL CORRETO)
                    //atualizarDatas();
					
					// --- TRAVA DE SEGURANÇA ---
                    // Verifica se o formulário está ABERTO. Se estiver, NÃO atualiza as datas
                    // para não resetar o que o usuário selecionou.
                    const formularioAberto = document.querySelector('.form-container.visible');
                    
                    if (!formularioAberto) {
                        atualizarDatas();
                    }
                    // --------------------------
					
					
					if (vatualizarOpcoesHorario) {
					  atualizarOpcoesHorario();
					  document.getElementById('quadra').selectedIndex = 0;
					  vatualizarOpcoesHorario = false;
					}
                }
            } else {
                inicializarEstruturaInicial();
            }

            let quadraInicial = quadraSelecionada || "Quadra 1 - Coberta";
            // Verifica se a quadra que tentaríamos abrir está interditada
            if (quadrasInativas.has(quadraInicial)) {
                // CORREÇÃO: A lista de alternativas agora inclui TODAS as quadras.
                const todasAsQuadras = ["Quadra 1 - Coberta", "Quadra 2 - Aberta", "Quadra 3 - Coberta"];

                // Encontra a primeira quadra da lista que NÃO está interditada
                const proximaDisponivel = todasAsQuadras.find(q => !quadrasInativas.has(q));

                if (proximaDisponivel) {
                    // Se achou alguma livre, usa ela
                    quadraInicial = proximaDisponivel;
                    quadraSelecionada = proximaDisponivel; // Atualiza a global também
                } else {
                    // Se NÃO achou nenhuma livre, aí sim bloqueia tudo
                    quadrasInativas.add("Quadra 1 - Coberta");
                    quadrasInativas.add("Quadra 2 - Aberta");
                    quadrasInativas.add("Quadra 3 - Coberta");

                    // (Seu código de bloqueio total visual...)
                    const selectQuadra = document.getElementById('quadra');
                    if (selectQuadra) {
                        selectQuadra.innerHTML = "";
                        const defaultOption = document.createElement('option');
                        defaultOption.value = "";
                        defaultOption.textContent = "Nenhuma quadra disponível";
                        selectQuadra.appendChild(defaultOption);
                    }
                    const tabelaContainer = document.querySelector('.tabela-container');
                    const header = document.querySelector('.header');
                    if (tabelaContainer) tabelaContainer.style.display = 'none';
                    if (header) header.style.display = 'none';

                    atualizarEstadoQuadras(); // Garante que tudo fique vermelho
                    mostrarNotificacao("Todas as quadras estão interditadas no momento.", 'error');
                    resolve();
                    return;
                }
            }

            document.querySelectorAll('.tab-button').forEach(button => {
                if (button.innerText.trim() === quadraInicial) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });

            const selectQuadra = document.getElementById('quadra');
			if (selectQuadra) {
				selectQuadra.innerHTML = "";

				const jogadorLogado = localStorage.getItem("jogadorLogado")?.toUpperCase();
				const isRestrito = jogadoresRestritos.includes(jogadorLogado);
				const todasQuadras = ["Quadra 1 - Coberta", "Quadra 2 - Aberta", "Quadra 3 - Coberta"];
				const quadrasAutorizadas = isRestrito
					? ["Quadra 1 - Coberta", "Quadra 2 - Aberta"]
					: todasQuadras;

				quadrasAutorizadas.forEach(quadra => {
					if (!quadrasInativas.has(quadra)) {
						const option = document.createElement('option');
						option.value = quadra;
						option.textContent = quadra;
						selectQuadra.appendChild(option); 
					}
				});

				// Esta linha foi restaurada para definir a quadra inicial
				selectQuadra.value = quadraInicial;
			}

            const tabelaContainer = document.querySelector('.tabela-container');
            const header = document.querySelector('.header');
            if (tabelaContainer) tabelaContainer.style.display = 'block';
            if (header) {
                header.style.display = 'block';
                header.innerText = quadraInicial;
            }

            atualizarEstadoQuadras();
			
			
            selecionarQuadra(quadraInicial);
			
			// ADICIONE ESTA LINHA PARA FORÇAR O RESET DO DROPDOWN
			//document.getElementById('quadra').selectedIndex = 0;
            resolve();

        }, (error) => {
            console.error("Erro ao carregar dados iniciais:", error);
            reject(error);
        });
    });
}





function atualizarEstadoQuadras() {
    // Atualiza o estado visual dos botões das abas
    document.querySelectorAll('.tab-button').forEach(button => {
        const quadraNome = button.innerText.trim();

        // Se a quadra estiver na lista de inativas, pinta de vermelho
        if (quadrasInativas.has(quadraNome)) {
            button.style.setProperty("background-color", "red", "important");
            button.style.setProperty("cursor", "not-allowed", "important");
            button.onclick = () => mostrarNotificacao(`A ${quadraNome} está interditada provisoriamente.`, 'error');

        } else {
            // Se estiver ativa, restaura o comportamento normal
            // (Nota: a classe .selected cuidará da cor verde se ela estiver selecionada)
            button.style.backgroundColor = '';
            button.style.cursor = 'pointer';
            // Restaura a função original de selecionar a quadra
            button.onclick = () => selecionarQuadra(button.getAttribute('data-nome-original') || quadraNome);
        }
    });

    // --- CORREÇÃO NO BOTÃO AGENDAR ---
    const todasIndisponiveis = ["Quadra 1 - Coberta", "Quadra 2 - Aberta", "Quadra 3 - Coberta"]
        .every(quadra => quadrasInativas.has(quadra));

    const selectQuadra = document.getElementById('quadra');
    // Verifica se o dropdown realmente não tem nenhuma opção válida selecionável
    const dropdownVazio = !selectQuadra || selectQuadra.options.length === 0 || selectQuadra.value === "";

    const botaoAgendar = document.getElementById('botaoAgendar');
    if (botaoAgendar) {
        // Se todas estiverem interditadas OU não tiver quadra selecionada no dropdown, desativa.
        const deveDesativar = todasIndisponiveis || dropdownVazio;

        botaoAgendar.disabled = deveDesativar;

        // Atualiza o visual do botão para refletir o estado
        botaoAgendar.style.opacity = deveDesativar ? "0.5" : "1";
        botaoAgendar.style.cursor = deveDesativar ? "not-allowed" : "pointer";
        botaoAgendar.title = deveDesativar ? "Não há quadras disponíveis para agendar" : "";
    }
}


function atualizarReservasQuadra(quadra) {
    limparTabela();
    const reservas = reservasPorQuadra[quadra];
    if (reservas) {
        const tabela = document.getElementById('tabelaCorpo');
        for (const key in reservas) {
            const { jogadores, dia, hora, duracao, borda } = reservas[key];
            const rowIndex = hora - 6;
            const colIndex = dia;

            // Ignorar sábado (coluna 6) das 21:00 às 23:00 e domingo (coluna 7) das 06:00 às 08:00
            if ((colIndex === 6 && hora >= 21 && hora <= 23) || (colIndex === 7 && hora >= 6 && hora <= 8)) {
                continue;
            }

            const cell = tabela.rows[rowIndex]?.cells[colIndex];
            if (cell) {
                cell.innerHTML = jogadores;
                cell.setAttribute("data-duracao", duracao);
                //cell.style.backgroundColor = jogadores.toLowerCase().includes('aula') ? 'lightcoral' :
                //    (duracao === 1 ? 'lightgreen' : 'lightblue');
                cell.style.backgroundColor = jogadores.toLowerCase().trim() === 'aula' ? 'lightcoral' :
					(duracao === 1 ? 'lightgreen' : 'lightblue');					

                // Configurar bordas para reservas de 1h ou 2h
                if (borda === '1h') {
                    cell.style.border = '2px solid black';
                } else if (borda === '2h') {
                    configurarBordasDuracao2(cell, tabela, rowIndex, colIndex);
                }
            }
        }
    }
}

// SUBSTITUA A FUNÇÃO configurarBordasDuracao2 INTEIRA POR ESTA:
function configurarBordasDuracao2(cell, tabela, rowIndex, colIndex) {
    // Define a cor: #555 se for escuro, #bbb se for claro (Cinza Médio)
    const isDark = document.body.classList.contains('dark-mode');
    const corBorda = isDark ? '2px solid #555' : '2px solid #666';

    if (cell.rowSpan > 1) {
        cell.style.borderTop = corBorda;
        cell.style.borderLeft = corBorda;
        cell.style.borderRight = corBorda;
        cell.style.borderBottom = corBorda;
    } else {
        cell.style.borderTop = corBorda;
        cell.style.borderLeft = corBorda;
        cell.style.borderRight = corBorda;
        cell.style.borderBottom = 'none';

        const cellNext = tabela.rows[rowIndex + 1]?.cells[colIndex];
        if (cellNext) {
            cellNext.style.borderTop = 'none';
            cellNext.style.borderLeft = corBorda;
            cellNext.style.borderRight = corBorda;
            cellNext.style.borderBottom = corBorda;
        }
    }
}




function verificarVersao() {
    const elementoVersao = document.getElementById('VersaoSistema');
    if (elementoVersao) {
        elementoVersao.textContent = `${VersaoSistema}`;
    } else {
        console.error('Elemento para exibir a versão não encontrado!');
    }
}




// SUBSTITUA SUA FUNÇÃO limparTabela POR ESTA VERSÃO CORRIGIDA
function limparTabela() {
    const tabela = document.getElementById('tabelaCorpo');
    if (!tabela) return;

    const linhas = tabela.rows;

    for (let i = 0; i < linhas.length; i++) {
        const celulas = linhas[i].cells;
        
        // Ajuste: Começa do j=1 (Segunda coluna) e vai até length-1 (Penúltima coluna)
        // Isso preserva a coluna 0 (Horário Esq) e a coluna 8 (Horário Dir)
        for (let j = 1; j < celulas.length - 1; j++) {
            const cell = celulas[j];

            // Proteção extra: Se por acaso a célula tiver a classe 'horario', ignora
            if (cell.classList.contains('horario')) continue;

            // 1. Limpa Conteúdo e Cores
            cell.innerHTML = "";
            cell.style.backgroundColor = "";
            cell.style.color = "";
            
            // 2. Limpa Bordas e Estilos Específicos
            cell.style.border = "";
            cell.style.verticalAlign = "";
            cell.style.boxSizing = "";
            cell.style.position = ""; 
            
            // --- CORREÇÃO: Reseta o Negrito ---
            cell.style.fontWeight = ""; 
            // ----------------------------------

            // 3. CORREÇÃO CRÍTICA DO DESLOCAMENTO (Manutenção > 2h)
            cell.rowSpan = 1; 
            cell.style.display = ""; // Garante que volte a aparecer

            // 4. Reseta Cursor
            cell.style.cursor = "default";
            cell.style.pointerEvents = "auto";

            // 5. Limpa Metadados
            delete cell.dataset.tipo;
            delete cell.dataset.professor;
            delete cell.dataset.duracao;
            delete cell.dataset.blocked;
            delete cell.dataset.motivo;
            delete cell.dataset.horarioInicio; // Garante limpeza completa
            delete cell.dataset.horarioFim;
            delete cell.dataset.data;
            
            cell.removeAttribute("data-duracao");
            cell.removeAttribute("data-blocked");
        }
    }
}

// Função para selecionar a quadra e carregar suas reservas
// EM "app-reservas - ativo.html" (Linha 4153)
// SUBSTITUA A FUNÇÃO 'selecionarQuadra' INTEIRA POR ESTA:

function selecionarQuadra(quadra) {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
	
	
	
    // Obtém o nome original da quadra
    const botoes = document.querySelectorAll('.tab-button');
    let nomeOriginal = null;

    botoes.forEach(button => {
        // Verifica se o botão corresponde ao nome exibido ou ao nome original
        if (
            button.getAttribute('data-nome-original') === quadra ||
            button.innerHTML.replace('<br>', '').trim() === quadra
        ) {
            nomeOriginal = button.getAttribute('data-nome-original');
            
            // Alerta com o label do botão clicado
            const labelBotao = button.textContent.trim(); // Obtém o texto do botão
            //alert(`Label do botão clicado: ${labelBotao}`);
        }
    });

    // alert(`quadra: ${quadra}`); 
    if (!nomeOriginal) {
        // Substitui quebras de linha e espaços múltiplos por um único espaço
        const quadraNormalized = quadra.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
        //console.log(`Valor ajustado de quadra: "${quadraNormalized}"`);
        //alert(`Valor ajustado de quadra: "${quadraNormalized}"`);
        // Verifica o nome normalizado
        if (quadraNormalized === "Quadra 1 - Coberta" || quadraNormalized === "Quadra 1 Coberta") {
            nomeOriginal = "Quadra 1 - Coberta";
        } else if (quadraNormalized === "Quadra 2 - Aberta" || quadraNormalized === "Quadra 2 Aberta") {
            nomeOriginal = "Quadra 2 - Aberta";
        } else if (quadraNormalized === "Quadra 3 - Coberta" || quadraNormalized === "Quadra 3 Coberta") {
            nomeOriginal = "Quadra 3 - Coberta"; 
        }
    }
	
    //nomeOriginal = "Quadra 3 - Coberta";
	
    //alert(`Quadra selecionada: ${nomeOriginal}`); // Alerta com o nome da quadra

    if (!nomeOriginal) {
        console.error('Quadra não encontrada:', quadra);
        return;
    }

    // Verifica se a quadra está interditada
    const isQuadraInterditada = quadrasInativas.has(nomeOriginal);

    
	if (isQuadraInterditada) {
		mostrarNotificacao(`A ${nomeOriginal} está interditada provisoriamente.`, 'error');
		return;
	}

    // Atualiza a quadra selecionada
    quadraSelecionada = nomeOriginal;
    
    // ==========================================================
    // ===== A MUDANÇA ESTÁ AQUI =====
    // ==========================================================
    // Em vez de .innerText, usamos .innerHTML para inserir os <span>s
    const headerElement = document.querySelector('.header');
    if (headerElement) {
        const partesNome = nomeOriginal.split(' - ');
        const main = partesNome[0]; // "Quadra 1"
        const sub = partesNome.length > 1 ? ` - ${partesNome[1]}` : ''; // " - Coberta"
        
        headerElement.innerHTML = `<span class="header-main">${main}</span><span class="header-sub">${sub}</span>`;
    }
    // ==========================================================
    // ===== FIM DA MUDANÇA =====
    // ==========================================================


    // Remove a classe 'selected' e estilo inline de todos os botões
    botoes.forEach(button => {
        button.classList.remove('selected');
        button.style.backgroundColor = ''; // Remove estilo inline
        button.style.color = ''; // Remove estilo inline
        button.style.border = ''; // Remove estilo inline
    });

    // Adiciona a classe 'selected' e estilo inline ao botão correspondente
    botoes.forEach(button => {
        if (button.getAttribute('data-nome-original') === nomeOriginal) {
            button.classList.add('selected'); // Aplica a classe 'selected' para quadra selecionada
            button.style.backgroundColor = '#228B22'; // Cor verde escuro para quadra selecionada
			button.style.color = 'white'; // Texto branco
            button.style.border = '2px solid #1A6418'; // Borda escura para quadra selecionada (apenas para a verde)
        }

        // Verifica se a quadra está interditada e aplica o estilo vermelho
        if (quadrasInativas.has(button.getAttribute('data-nome-original'))) {
            button.style.backgroundColor = 'red'; // Botão vermelho para quadras interditadas
            button.style.color = 'white'; // Texto branco
            button.style.border = ''; // Remove a borda para o botão vermelho 
        }
    });

    // Atualiza o estado do domingo após selecionar a quadra
    //atualizarEstadoDomingo();

    // Atualiza e exibe reservas para a quadra selecionada
    carregarReservas(nomeOriginal);
}



// =================================================================
// === NOVA FUNÇÃO: APLICAR GRADE DE AULAS (COM RESPEITO ÀS PRIORIDADES) ===
// =================================================================
// =================================================================
// === NOVA FUNÇÃO: APLICAR GRADE DE AULAS (COM RESPEITO ÀS PRIORIDADES) ===
// =================================================================
function aplicarGradeDeAulas(quadraNome) {
    let quadraKey = "";
    if (quadraNome.includes("Quadra 1")) quadraKey = "Quadra1";
    else if (quadraNome.includes("Quadra 2")) quadraKey = "Quadra2";
    else if (quadraNome.includes("Quadra 3")) quadraKey = "Quadra3";

    const dadosAula = configAulasGlobal[quadraKey];
    if (!dadosAula || !dadosAula.Ativo || !dadosAula.Grade) return;

    const tabela = document.getElementById('tabelaCorpo');
    const headerRow = document.getElementById('tabelaQuadra').rows[1]; 

    for (const key in dadosAula.Grade) {
        if (dadosAula.Grade[key] === true) {
            const [dia, hora] = key.split('_').map(Number);
            const rowIndex = hora - 6;
            
            if (tabela.rows[rowIndex] && tabela.rows[rowIndex].cells[dia]) {
                const cell = tabela.rows[rowIndex].cells[dia];

                // 1. Respeita fechamento e reservas existentes
                const estaFechado = cell.style.backgroundColor === 'rgb(242, 242, 242)' || 
                                    cell.style.backgroundColor === '#f2f2f2';
                
                // Se já tem conteúdo (reserva de aluno), não pinta de vermelho
                if (cell.innerHTML.trim() !== "") continue; 
                if (estaFechado) continue;

                // 2. Pinta a Grade Fixa
                cell.innerHTML = `<span style="display:none">GRADE_FIXA</span>Aula`; 
                cell.style.backgroundColor = 'lightcoral'; 
                cell.style.color = 'black'; 
                
                cell.style.pointerEvents = 'auto'; 
                
                // --- CURSOR SEMPRE PADRÃO (SETA) ---
                cell.style.cursor = 'default';
                cell.title = "";
                // -----------------------------------
                
                cell.dataset.blocked = "false"; 
                cell.dataset.tipo = "aula_fixa";
                cell.dataset.professor = dadosAula.Professor;
            }
        }
    }
}




function carregarReservas(quadra) {
    if (agendamentoEmAndamento) { return; } 
    celulasExcluidas.clear();
    reservasExcluidasFirebase.clear();

    const reservasRef = database.ref(`sistemas/reservas/${quadra}`);

    reservasRef.off('value'); 
    reservasRef.on('value', (snapshot) => {
        if (agendamentoEmAndamento) { return; } 
        
        // 1. ATUALIZA DADOS GLOBAIS
        reservasPorQuadra[quadra] = snapshot.val() || {};
        const reservas = snapshot.val();

        // 2. PREPARA A TABELA
        limparTabela();
        aplicarLimitesDeHorarioVisual();
        aplicarBloqueiosVisuais(quadra);
        
        if (typeof aplicarGradeDeAulas === 'function') {
            try { aplicarGradeDeAulas(quadra); } catch (e) { console.warn("Grade ainda não pronta"); }
        }

        if (reservas) {
            try {
                const tabela = document.getElementById('tabelaCorpo');
                const totalRows = tabela.rows.length;
                const totalCols = tabela.rows[0]?.cells.length || 0;

                // ============================================================
                // 1. MAPA DE MESCLAGEM (Manutenção E Aula)
                // ============================================================
                const mapaMesclagem = {}; 
                for (let d = 1; d <= 7; d++) {
                    for (let h = 6; h <= 23; h++) {
                        const key = `${d}_${h}`;
                        if (mapaMesclagem[key] && mapaMesclagem[key].pular) continue;

                        const r = reservas[key];
                        if (!r) continue;

                        const nomeRaw = (r.jogadores || "").toLowerCase().trim();

                        if (nomeRaw === 'manutencao' || nomeRaw === 'aula') {
                            let span = 1;
                            for (let nextH = h + 1; nextH <= 23; nextH++) {
                                const nextKey = `${d}_${nextH}`;
                                const nextR = reservas[nextKey];
                                const nextNome = nextR ? (nextR.jogadores || "").toLowerCase().trim() : "";
                                
                                if (nextNome === nomeRaw) {
                                    span++;
                                    mapaMesclagem[nextKey] = { pular: true };
                                } else { break; }
                            }
                            if (span > 1) mapaMesclagem[key] = { rowSpan: span, pular: false };
                        }
                    }
                }
                // ============================================================

                for (const key in reservas) {
                    const reserva = reservas[key]; 
                    if (!reserva) continue;

                    const nomeNormalizado = (reserva.jogadores || "").toLowerCase().trim();

                    // --- AULA CANCELADA ---
                    if (reserva.status === 'aula_cancelada') {
                        const { dia, hora } = reserva;
                        const rowIndex = hora - 6;
                        const colIndex = dia;
                        if (tabela.rows[rowIndex] && tabela.rows[rowIndex].cells[colIndex]) {
                            const cell = tabela.rows[rowIndex].cells[colIndex];
                            cell.style.backgroundColor = ""; 
                            cell.innerHTML = ""; 
                            cell.style.pointerEvents = "auto"; 
                            cell.style.cursor = "default"; 
                            delete cell.dataset.tipo;
                            delete cell.dataset.professor;
                        }
                        continue; 
                    }

                    if (typeof reserva.jogadores === 'undefined' || reserva.jogadores === null) continue;

                    // --- MANUTENÇÃO ---
                    if (nomeNormalizado === 'manutencao') {
                        const rowIndex = reserva.hora - 6;
                        const colIndex = reserva.dia;

                        if (mapaMesclagem[key] && mapaMesclagem[key].pular) {
                            if (tabela.rows[rowIndex] && tabela.rows[rowIndex].cells[colIndex]) {
                                tabela.rows[rowIndex].cells[colIndex].style.display = 'none';
                            }
                            continue; 
                        }
                        
                        if (tabela.rows[rowIndex] && tabela.rows[rowIndex].cells[colIndex]) {
                            const cell = tabela.rows[rowIndex].cells[colIndex];
                            const dadosMescla = mapaMesclagem[key];
                            const isDark = document.body.classList.contains('dark-mode');
                            
                            // Estilo BASE da Manutenção
                            cell.style.backgroundColor = isDark ? '#252525' : '#e9ecef';
                            cell.style.color = isDark ? '#999' : '#555'; // <--- A COR "ACIZENTADA" É ESTA
                            cell.style.border = isDark ? '2px solid #555' : '2px solid #666';
                            cell.style.boxSizing = "border-box";
                            cell.style.verticalAlign = 'middle'; 
                            cell.style.textAlign = 'center'; 
                            cell.dataset.tipo = 'manutencao';
                            cell.style.cursor = "default"; 

                            if (dadosMescla && dadosMescla.rowSpan > 1) {
                                const horaFim = reserva.hora + dadosMescla.rowSpan;
                                cell.rowSpan = dadosMescla.rowSpan;
                                cell.innerHTML = `<b>💦 Manutenção</b><br><span style="font-size:0.85em; opacity:0.8;">${reserva.hora}:00 - ${horaFim}:00</span>`;
                            } else {
                                cell.innerHTML = "<b>💦 Manutenção</b>"; 
                            }
                        }
                        continue; 
                    }

                    // --- PRESERVAÇÃO VISUAL ---
                    if (reserva.borda === undefined) {
                        const prevKey = `${reserva.dia}_${reserva.hora - 1}`;
                        const prevReserva = reservas[prevKey];
                        if (prevReserva && prevReserva.duracao > 1) continue; 
                    }

                    const { dia, hora, duracao } = reserva;
                    const rowIndex = hora - 6;
                    const colIndex = dia;

                    if (rowIndex >= 0 && rowIndex < totalRows && colIndex >= 0 && colIndex < totalCols) {
                        const cell = tabela.rows[rowIndex].cells[colIndex];
                        cell.rowSpan = 1; 
                        cell.style.display = ''; 
                        cell.setAttribute("data-duracao", duracao || "segunda-celula");
                        cell.style.cursor = "default";

                        // ============================================================
                        // --- AULA (AGORA COM A MESMA COR DA MANUTENÇÃO) ---
                        // ============================================================
                        if (nomeNormalizado === 'aula') {
							if (mapaMesclagem[key] && mapaMesclagem[key].pular) {
								cell.style.display = 'none';
								continue; 
							}

							const isDark = document.body.classList.contains('dark-mode');
							cell.style.backgroundColor = 'lightcoral';
							
							// --- AJUSTE PARA CONSISTÊNCIA VISUAL ---
							// Fixa a cor em preto e o negrito com prioridade máxima (!important)
							// Isso impede que o modo escuro mude a cor para cinza/branco.
							cell.style.setProperty('color', 'black', 'important');
							cell.style.setProperty('font-weight', 'bold', 'important');
							// ---------------------------------------

							cell.dataset.tipo = 'aula_extra';
							cell.style.cursor = "default"; 
							
							cell.style.boxSizing = "border-box";
							cell.style.verticalAlign = 'middle'; 
							cell.style.textAlign = 'center';     
							
							// Mantém a borda variando conforme o tema, ou pode fixar se preferir
							cell.style.border = isDark ? '2px solid #555' : '2px solid #666';

							if (mapaMesclagem[key] && mapaMesclagem[key].rowSpan > 1) {
								const horaFim = reserva.hora + mapaMesclagem[key].rowSpan;
								cell.rowSpan = mapaMesclagem[key].rowSpan;
								// O <b> aqui reforça o negrito no texto
								cell.innerHTML = `<b>🏃 Aula</b><br><span style="font-size:0.85em; opacity:0.8;">${reserva.hora}:00 - ${horaFim}:00</span>`;
							} else {
								cell.innerHTML = "<b>🏃 Aula</b>"; 
							}
							continue; 
						}
                        // ============================================================
                        
                        // --- JOGOS (Código original mantido) ---
                        if (vReservasPorConfirmacao === true && (reserva.status === 'pendente' || reserva.status === 'confirmada')) {
                             const { confirmacoes } = reserva;
                            const isDarkMode = document.body.classList.contains('dark-mode');
                            const corReserva1h = isDarkMode ? 'mediumseagreen' : 'lightgreen';
                            const corReserva2h = isDarkMode ? 'CornflowerBlue' : 'lightblue';
                            const corPiramide = isDarkMode ? 'goldenrod' : '#FFEB99';
                            let corFundo;
                            if (reserva.duracao === 1) corFundo = corReserva1h;
                            else if (reserva.duracao === 2) corFundo = corReserva2h;
                            else if (reserva.duracao === 3) corFundo = corPiramide;
                            
                            cell.style.backgroundColor = corFundo;
                            
                            const getStyledNames = (jogadoresArray, isPiramideGame) => {
                                if (!jogadoresArray || jogadoresArray.length === 0) return "";
                                let nomesHtml = [];
                                jogadoresArray.forEach(apelido => {
                                    let nomeParaExibir;
                                    const isConvidadoNomeado = apelido.trim().startsWith("Convidado - ");
                                    const isConvidadoGenerico = apelido.trim().toLowerCase() === 'convidado';

                                    if (isConvidadoNomeado || isConvidadoGenerico) {
                                        nomeParaExibir = "<strong><em>Convidado</em></strong>"; 
                                    } else {
                                        nomeParaExibir = apelido.trim();
                                        if (isPiramideGame) {
                                            const jogadorInfo = jogadoresData[nomeParaExibir];
                                            if (jogadorInfo && jogadorInfo.piramide && jogadorInfo.piramide !== "0") {
                                                const piramidePos = parseInt(jogadorInfo.piramide, 10);
                                                let displayRank = piramidePos;
                                                if (piramidePos >= 61) { displayRank = piramidePos - 60; }
                                                nomeParaExibir = `${displayRank} - ${apelido}`;
                                            }
                                        }
                                    } 
                                    
                                    let styles = '';
                                    const status = reserva.confirmacoes ? reserva.confirmacoes[apelido.trim()] : true;
                                    
                                    // Cores de status
                                    if (isConvidadoNomeado || isConvidadoGenerico) styles = `color: ${isDarkMode ? 'white' : 'black'};`;
                                    else if (status === true) styles = `color: ${isDarkMode ? 'white' : 'black'};`;
                                    else if (status === false) styles = `color: ${isDarkMode ? '#FFB74D' : '#EF6C00'};`;
                                    else if (status === 'recusado') styles = `color: red; text-decoration: line-through;`;

                                    // --- NOVO: NEGRITO PARA ORGANIZADOR (REGRAS ATUALIZADAS) ---
                                    if (reserva.organizador && apelido.trim().toLowerCase() === reserva.organizador.trim().toLowerCase()) {
                                        // Regra 1: Reservas de 2 Horas -> Sempre negrita
                                        if (reserva.duracao === 2) {
                                            styles += ' font-weight: 900;';
                                        }
                                        // Regra 2: Reservas de 1 Hora -> Negrita APENAS se houver mais de 1 jogador
                                        // (Se for 1h e jogar sozinho, não negrita)
                                        else if (reserva.duracao === 1 && jogadoresArray.length > 1) {
                                            styles += ' font-weight: 900;';
                                        }
                                    }
                                    // -------------------------------------------------------

                                    nomesHtml.push(`<span style="${styles}">${nomeParaExibir}</span>`);
                                });
                                return nomesHtml.join(isPiramideGame ? '<br>' : ', ');
                            };

                            const isPiramide = reserva.duracao === 3;
                            const todosOsJogadores = (reserva.jogadores_completo || reserva.jogadores).split(', ').map(j => j.trim());
                            let jogadoresParaExibir;

                            if (reserva.status === 'confirmada') {
                                jogadoresParaExibir = todosOsJogadores.filter(apelido => {
                                    const status = reserva.confirmacoes[apelido.trim()];
                                    const isConvidado = apelido.trim().toLowerCase() === 'convidado' || apelido.trim().startsWith("Convidado - ");
                                    return status === true || isConvidado;
                                });
                            } else { 
                                jogadoresParaExibir = todosOsJogadores;
                            }

                            let jogadoresParte1 = [];
                            let jogadoresParte2 = []; 

                            if (reserva.duracao > 1) { 
                                jogadoresParaExibir.forEach((jogador, index) => {
                                    if (index === 0 || index === 2) jogadoresParte1.push(jogador);
                                    else if (index === 1 || index === 3) jogadoresParte2.push(jogador);
                                });
                            } else { 
                                jogadoresParte1 = jogadoresParaExibir;
                            }
                            
                            cell.innerHTML = getStyledNames(jogadoresParte1, isPiramide);
                            
                            if (reserva.status === 'em_andamento' && reserva.borda) {
                                cell.style.position = 'relative'; 
                                cell.innerHTML = '<span class="live-indicator"></span>' + cell.innerHTML;
                            }
                            
                            //if (reserva.duracao === 2) configurarBordasDuracao2(cell, tabela, rowIndex, colIndex);
                            //else if (reserva.duracao === 1) cell.style.border = '2px solid black';
							// --- CORREÇÃO: Aplica borda grossa se for 2h OU Pirâmide (que é 3) ---
                            if (reserva.duracao === 2 || isPiramide) {
                                configurarBordasDuracao2(cell, tabela, rowIndex, colIndex);
                            }
                            else if (reserva.duracao === 1) {
                                cell.style.border = isDarkMode ? '2px solid #555' : '2px solid #666';
                            }
                            // --------------------------------------------------------------------
                            
                            if (reserva.duracao > 1) {
                                const cell2 = tabela.rows[rowIndex + 1]?.cells[colIndex];
                                if(cell2) {
                                    cell2.style.backgroundColor = corFundo;
                                    cell2.innerHTML = getStyledNames(jogadoresParte2, isPiramide);
                                    cell2.style.cursor = "default"; 
                                }
                            }
                        } else {
                            // Lógica antiga (sem confirmação)
                            const { jogadores, borda, confirmacoes } = reserva;
                            const isDarkMode = document.body.classList.contains('dark-mode');
                            const corReserva1h = isDarkMode ? 'mediumseagreen' : 'lightgreen';
                            const corReserva2h = isDarkMode ? 'CornflowerBlue' : 'lightblue';
                            const corPiramide = isDarkMode ? 'goldenrod' : '#FFEB99';
                            let corFundo;

                            const getJogadoresVisiveis = (listaJogadores, confirmacoesObj) => {
                                if (!confirmacoesObj) return listaJogadores;
                                const jogadoresArray = listaJogadores.split(', ').map(j => j.trim());
                                const filtrados = jogadoresArray.filter(apelido => confirmacoesObj[apelido] !== 'recusado');
                                return filtrados.join(', ');
                            };

                            const jogadoresVisiveis = getJogadoresVisiveis(jogadores, confirmacoes);
                            
                            if (reserva.duracao === 3 || (reservas[`${dia}_${hora - 1}`] && reservas[`${dia}_${hora - 1}`].duracao === 3)) {
                                corFundo = corPiramide;
                                cell.style.color = '';
                                const jogadoresArray = jogadoresVisiveis.split(', ');
                                
                                const jogadoresFormatados = jogadoresArray.map(apelido => {
                                    if (apelido.trim().startsWith("Convidado - ")) return "<strong><em>Convidado</em></strong>";
                                    const jogadorInfo = jogadoresData[apelido.trim()];
                                    if (jogadorInfo && jogadorInfo.piramide && jogadorInfo.piramide !== "0") {
                                        const piramidePos = parseInt(jogadorInfo.piramide, 10);
                                        let displayRank = piramidePos;
                                        if (piramidePos >= 61) { displayRank = piramidePos - 60; }
                                        return `${displayRank} - ${apelido}`;
                                    }
                                    return apelido;
                                });
                                cell.innerHTML = jogadoresFormatados.join('<br>');
                                
                                if (reserva.status === 'em_andamento' && reserva.borda) {
                                    cell.style.position = 'relative'; 
                                    cell.innerHTML = '<span class="live-indicator"></span>' + cell.innerHTML;
                                }
                            }
                            else {
                                corFundo = reserva.duracao === 1 ? corReserva1h : corReserva2h;
                                const jogadoresFormatados = jogadoresVisiveis.split(', ').map(j => {
                                    if (j.startsWith("Convidado - ")) return "<strong><em>Convidado</em></strong>";
                                    return j;
                                }).join(', ');
                                cell.innerHTML = jogadoresFormatados;
                                
                                if (reserva.status === 'em_andamento' && reserva.borda) {
                                    cell.style.position = 'relative'; 
                                    cell.innerHTML = '<span class="live-indicator"></span>' + cell.innerHTML;
                                }
                                cell.style.color = '';
                            }

                            cell.style.backgroundColor = corFundo;

                            if (borda === '1h') cell.style.border = isDarkMode ? '2px solid #555' : '2px solid #666';
                            else if (borda === '2h') configurarBordasDuracao2(cell, tabela, rowIndex, colIndex);

                            if (reserva.duracao > 1) {
                                const key2 = `${dia}_${hora + 1}`;
                                const reservaSegundaParte = reservas[key2];
                                if (reservaSegundaParte) {
                                    const cell2 = tabela.rows[rowIndex + 1]?.cells[colIndex];
                                    if (cell2) {
                                        const jogadoresVisiveisParte2 = getJogadoresVisiveis(reservaSegundaParte.jogadores, reservaSegundaParte.confirmacoes);
                                        
                                        if (reserva.duracao === 3) {
                                            const jogadoresArray2 = jogadoresVisiveisParte2.split(', ');
                                            const jogadoresFormatados2 = jogadoresArray2.map(apelido => {
                                                if (apelido.trim().startsWith("Convidado - ")) return "<strong><em>Convidado</em></strong>";
                                                const jogadorInfo = jogadoresData[apelido.trim()];
                                                if (jogadorInfo && jogadorInfo.piramide && jogadorInfo.piramide !== "0") {
                                                    const piramidePos = parseInt(jogadorInfo.piramide, 10);
                                                    let displayRank = piramidePos;
                                                    if (piramidePos >= 61) { displayRank = piramidePos - 60; }
                                                    return `${displayRank} - ${apelido}`;
                                                }
                                                return apelido;
                                            });
                                            cell2.innerHTML = jogadoresFormatados2.join('<br>');
                                        } else {
                                            const jogadoresFormatados2 = jogadoresVisiveisParte2.split(', ').map(j => {
                                                if (j.startsWith("Convidado - ")) return "<strong><em>Convidado</em></strong>";
                                                return j;
                                            }).join(', ');
                                            cell2.innerHTML = jogadoresFormatados2;
                                        }
                                        cell2.style.backgroundColor = corFundo;
                                        cell2.style.color = '';
                                        cell2.style.cursor = "default";  
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (error) { console.error(error); return; }
        } 
        configurarEventosDaTabela();
		
		// --- AQUI ESTÁ A CORREÇÃO MÁGICA ---
        // Toda vez que os dados do banco chegarem, recalculamos os horários
        // do dropdown se o formulário estiver aberto.
        if (typeof atualizarOpcoesHorario === 'function') {
            atualizarOpcoesHorario();
        }
        // -----------------------------------
		
    });
}






function validarDiaReserva(jogadores) {
    console.log("Iniciando validação da reserva...");

    // Se algum jogador for "aula" , retorna true imediatamente
    if (jogadores.some(jogador => {
        let nome = jogador.toLowerCase();
        //return nome.includes("aula");
		return nome.trim() === "aula";
    })) {
        console.log("Reserva identificada como 'aula'. Validação ignorada.");
        return true;
    }

    const duracao = document.getElementById('duracao').value;
    console.log("Duração selecionada:", duracao);

    const diaSelecionado = parseInt(document.getElementById('dia').value);
    const horaSelecionada = parseInt(document.getElementById('hora').value);
    console.log("Dia selecionado:", diaSelecionado, "Hora selecionada:", horaSelecionada);

    if (duracao === "3-piramide") {
        console.log("Modo Pirâmide detectado. Aplicando regras especiais.");
		
		// --- INÍCIO DA NOVA VALIDAÇÃO DE DATAS DO TORNEIO ---
        if (!piramideInicioTorneio || !piramideFimTorneio) {
            //alert("Não é possível agendar jogos da Pirâmide, pois as datas do torneio ainda não foram configuradas.");
			mostrarNotificacao("Não é possível agendar jogos da Pirâmide, pois as datas do torneio ainda não foram configuradas.", 'error');
            return false;
        }

        const hoje = new Date();
        hoje.setHours(0, 0, 0, 0);
        const diaDaSemanaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay();
        let diff = diaSelecionado - diaDaSemanaHoje;
        if (diff < 0) diff += 7;
        const dataDaReserva = new Date(hoje);
        dataDaReserva.setDate(hoje.getDate() + diff);

        const dataInicioObj = parseDateDDMMYYYY(piramideInicioTorneio);
        const dataFimObj = parseDateDDMMYYYY(piramideFimTorneio);

        if (!dataInicioObj || !dataFimObj) {
            //alert("Erro nas datas do torneio da Pirâmide. Contate o administrador.");
			mostrarNotificacao("Erro nas datas do torneio da Pirâmide. Contate o administrador.", 'error');
            return false;
        }
        
        dataFimObj.setHours(23, 59, 59, 999); // Garante que o dia final seja incluído na verificação

        if (dataDaReserva < dataInicioObj) {
            //alert(`O torneio da Pirâmide só começa em ${piramideInicioTorneio.replace(/-/g, '/')}.`);
			mostrarNotificacao(`O torneio da Pirâmide só começa em ${piramideInicioTorneio.replace(/-/g, '/')}.`, 'error');
            return false;
        }

        if (dataDaReserva > dataFimObj) {
            //alert(`O torneio da Pirâmide terminou em ${piramideFimTorneio.replace(/-/g, '/')}.`);
			mostrarNotificacao(`O torneio da Pirâmide terminou em ${piramideFimTorneio.replace(/-/g, '/')}.`, 'error');
            return false;
        }
        // --- FIM DA NOVA VALIDAÇÃO DE DATAS DO TORNEIO --- 

        if (jogadores.length !== 2) {
            //alert("Reservas da Pirâmide devem ter exatamente 2 jogadores.");
			mostrarNotificacao("Reservas da Pirâmide devem ter exatamente 2 jogadores.", 'error');
			limparCampos();
            return false;
        }
		
		const configPiramide = window.config?.Piramide; 
        if (!configPiramide || !configPiramide.ativa) {
            //alert("Configuração da Pirâmide não foi encontrada ou está desativada. Atualize a página.");
			mostrarNotificacao("Configuração da Pirâmide não foi encontrada ou está desativada. Atualize a página.", 'error');
            return false;
        }

        const quadraSelecionada = document.getElementById('quadra').value;
        let quadraConfig;
        let prefixoQuadra;

        if (quadraSelecionada.includes("1")) {
            quadraConfig = configPiramide["Quadra-1"];
            prefixoQuadra = "1-";
            if (!quadraConfig || !quadraConfig["Quadra-1-ativa"]) {
                //alert("Quadra 1 - Coberta está interditada para jogos da Pirâmide.");
				mostrarNotificacao("Quadra 1 - Coberta está interditada para jogos da Pirâmide.", 'error');
                return false;
            }
        } else if (quadraSelecionada.includes("2")) {
            quadraConfig = configPiramide["Quadra-2"];
            prefixoQuadra = "2-";
            if (!quadraConfig || !quadraConfig["Quadra-2-ativa"]) {
                //alert("Quadra 2 - Aberta está interditada para jogos da Pirâmide.");
				mostrarNotificacao("Quadra 2 - Aberta está interditada para jogos da Pirâmide.", 'error');
                return false;
            }
        } else if (quadraSelecionada.includes("3")) {
            quadraConfig = configPiramide["Quadra-3"];
            prefixoQuadra = "3-";
            if (!quadraConfig || !quadraConfig["Quadra-3-ativa"]) {
                //alert("Quadra 3 - Coberta está interditada para jogos da Pirâmide.");
				mostrarNotificacao("Quadra 3 - Coberta está interditada para jogos da Pirâmide.", 'error');
                return false; 
            }
        }

        if (!quadraConfig) {
            //alert("Configuração da quadra não encontrada.");
			mostrarNotificacao("Configuração da quadra não encontrada.", 'error');
            return false;
        }

        const diasSemana = [1, 2, 3, 4, 5];
        if (diasSemana.includes(diaSelecionado)) {
            if (!quadraConfig[prefixoQuadra + "DiasDeSemana"]) {
                //alert(`Reservas para jogos da Pirâmide na ${quadraSelecionada} não são permitidas durante a semana.`);
				mostrarNotificacao(`Reservas para jogos da Pirâmide na ${quadraSelecionada} não são permitidas durante a semana.`, 'error');
                return false;
            }
            if (quadraConfig[prefixoQuadra + "DiasDeSemana-exceto-17-19"]) {
                const horaFim = horaSelecionada + 2;
                if (horaSelecionada < 19 && horaFim > 17) {
                    //alert(`Reservas da Pirâmide na ${quadraSelecionada} são proibidas de segunda a sexta entre 17:00 e 19:00 (horário exclusivo para todos os sócios).`);
					mostrarNotificacao(`Reservas da Pirâmide na ${quadraSelecionada} são proibidas de segunda a sexta entre 17:00 e 19:00 (horário exclusivo para todos os sócios).`, 'error');
                    return false;
                }
            }
        }

        if (diaSelecionado === 6) {
            if (!quadraConfig[prefixoQuadra + "Sabado"]) {
                //alert(`Reservas para jogos da Pirâmide na ${quadraSelecionada} não são permitidas aos sábados.`);
				mostrarNotificacao(`Reservas para jogos da Pirâmide na ${quadraSelecionada} não são permitidas aos sábados.`, 'error');
                return false;
            }
            if (quadraConfig[prefixoQuadra + "Sabado-exceto-7-12"] && horaSelecionada >= 7 && horaSelecionada < 12) {
                //alert(`Reservas da Pirâmide na ${quadraSelecionada} são proibidas aos sábados entre 07:00 e 12:00 (horário exclusivo para todos os sócios).`);
				mostrarNotificacao(`Reservas da Pirâmide na ${quadraSelecionada} são proibidas aos sábados entre 07:00 e 12:00 (horário exclusivo para todos os sócios).`, 'error');
                return false;
            }
        }

        if (diaSelecionado === 7) {
            if (!quadraConfig[prefixoQuadra + "Domingo"]) {
                //alert(`Reservas para jogos da Pirâmide na ${quadraSelecionada} não são permitidas aos domingos.`);
				mostrarNotificacao(`Reservas para jogos da Pirâmide na ${quadraSelecionada} não são permitidas aos domingos.`, 'error');
                return false;
            }
            if (quadraConfig[prefixoQuadra + "Domingo-exceto-8-12"] && horaSelecionada >= 8 && horaSelecionada < 12) {
                //alert(`Reservas da Pirâmide na ${quadraSelecionada} são proibidas aos domingos entre 08:00 e 12:00 (horário exclusivo para todos os sócios).`);
				mostrarNotificacao(`Reservas da Pirâmide na ${quadraSelecionada} são proibidas aos domingos entre 08:00 e 12:00 (horário exclusivo para todos os sócios).`, 'error');
                return false;
            }
        }

        console.log("Todas as regras da Pirâmide foram validadas com sucesso.");
    } 
	
        console.log("Modo padrão detectado. Aplicando regras normais de reserva.");
	
	//alert('entrei na validaçao');
    
    const diasParaLimpar = window.DiasParaLimpar;
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0);

    let maxDiasPermitidos;
    switch (diasParaLimpar) {
        case 1: maxDiasPermitidos = 5; break;
        case 2: maxDiasPermitidos = 4; break;
        case 3: maxDiasPermitidos = 3; break;
        case 4: maxDiasPermitidos = 2; break;
        case 5: maxDiasPermitidos = 1; break;
        case 6: maxDiasPermitidos = 0; break;
        default:
            //alert("Erro: Configuração inválida de DiasParaLimpar.");
			mostrarNotificacao(`Erro: Configuração inválida de DiasParaLimpar.`, 'error');
            return false;
    }

    const ultimoDiaPermitido = new Date(hoje);
    ultimoDiaPermitido.setDate(hoje.getDate() + maxDiasPermitidos);

    const diferencaDias = (diaSelecionado - hoje.getDay() + 7) % 7;
    const dataSelecionada = new Date(hoje);
    dataSelecionada.setDate(hoje.getDate() + diferencaDias);

    
	
	if (dataSelecionada > ultimoDiaPermitido || dataSelecionada < hoje) {
		mostrarNotificacao(gerarMensagemErro(diasParaLimpar), 'error');
		// A linha "limparCampos()" foi movida para cá, junto da notificação
		limparCampos(); 
		return false;
	}

    return true;
}



async function validarSeTemReserva(jogadores) {
   

    // Se algum jogador for "aula" , retorna true imediatamente
    if (jogadores.some(jogador => {
        let nome = jogador.toLowerCase();
        return nome === "aula";
    })) {
        console.log("Reserva marcada como 'aula'. Validação interrompida.");
        return true;
    }

    return new Promise((resolve) => {
        let conflito = false;
        let jogadoresComConflito = [];

        const reservasRef = database.ref("sistemas/reservas");
        reservasRef.once("value").then((snapshot) => {
            const todasAsReservas = snapshot.val() || {};
            const agora = new Date();

            // Verificando reservas existentes
            for (const quadra in todasAsReservas) {
                const reservasDaQuadra = todasAsReservas[quadra];
                for (const key in reservasDaQuadra) {
                    let reserva = reservasDaQuadra[key];

                    // ===================================================================
                    // INÍCIO DA ATUALIZAÇÃO: Lógica para analisar a reserva completa
                    // ===================================================================
                    
                    // Pula para a próxima iteração se a reserva não tiver a propriedade 'borda'.
                    // Isso significa que é a segunda hora de uma reserva, que será analisada
                    // quando o loop encontrar a primeira hora (que contém todos os dados).
                    if (reserva.borda === undefined) {
                        continue;
                    }

                    // Monta a lista completa de jogadores da reserva, incluindo as horas seguintes
                    const jogadoresNaReservaCompleta = [];
                    jogadoresNaReservaCompleta.push(...(reserva.jogadores_completo || reserva.jogadores).split(',').map(j => j.trim()));

                    if (reserva.duracao > 1) {
                        const duracaoReal = reserva.duracao === 3 ? 2 : reserva.duracao;
                        for (let i = 1; i < duracaoReal; i++) {
                            const chaveProximaHora = `${reserva.dia}_${reserva.hora + i}`;
                            const reservaProximaHora = reservasDaQuadra[chaveProximaHora];
                            if (reservaProximaHora) {
                                jogadoresNaReservaCompleta.push(...(reservaProximaHora.jogadores_completo || reservaProximaHora.jogadores).split(',').map(j => j.trim()));
                            }
                        }
                    }
                    const jogadoresUnicosNaReserva = [...new Set(jogadoresNaReservaCompleta)];
					
					if (typeof reserva.jogadores === 'undefined' || reserva.jogadores === null) {
                        const erroMsg = `⚠️ Erro de Dados Encontrado!\n\nExiste uma reserva antiga ou corrompida que impede a validação do seu agendamento.\n\nPor favor, envie esta informação para o administrador:\n\n- Quadra: ${quadra}\n- Chave do Problema: ${key}`;
                        //alert(erroMsg);
						mostrarNotificacao(erroMsg, 'error');
                        conflito = true;
                        break;
                    }

                    // Agora, verifica se algum dos jogadores que estão tentando agendar está nesta reserva completa
                    jogadores.forEach(jogador => {
                        if (jogador === "Convidado") return;

                        if (jogadoresUnicosNaReserva.includes(jogador)) {
                            // Se encontrou o jogador, faz a verificação de horário
                            
                            if (reserva.confirmacoes && reserva.confirmacoes[jogador] === 'recusado') {
                                return; // Ignora se o jogador recusou o convite
                            }

                            const dataDaTabelaString = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${reserva.dia})`).textContent;
                            const [dia, mes, ano] = dataDaTabelaString.split('/');
                            const reservaDataHoraInicio = new Date(ano, mes - 1, dia, reserva.hora, 0, 0, 0);

                            // Lógica corrigida para calcular a duração real
                            const duracaoCorrigida = reserva.duracao === 3 ? 2 : parseInt(reserva.duracao, 10);
                            
                            const reservaDataHoraFim = new Date(reservaDataHoraInicio);
                            reservaDataHoraFim.setHours(reservaDataHoraInicio.getHours() + duracaoCorrigida);

                            // Se o horário final da reserva ainda estiver no futuro, marca como conflito.
                            if (reservaDataHoraFim > agora) {
                                conflito = true;
                                if (!jogadoresComConflito.includes(jogador)) {
                                    jogadoresComConflito.push(jogador);
                                }
                            }
                        }
                    });
                    // ===================================================================
                    // FIM DA ATUALIZAÇÃO
                    // ===================================================================
                }
                if (conflito) break;
            }

            if (conflito) {
                if (jogadoresComConflito.length > 0) {
                    const mensagem = jogadoresComConflito.length > 1
                        ? `Os jogadores ${jogadoresComConflito.join(", ")} ainda têm uma reserva ativa e não podem agendar outra antes de finalizá-la.`
                        : `O jogador ${jogadoresComConflito[0]} ainda tem uma reserva ativa e não pode agendar outra antes de finalizá-la.`;
                    mostrarNotificacao(mensagem, 'error'); // Alterado de alert para notificação
                }
                resolve(false);
            } else {
                resolve(true);
            }
        });
    });
}


function gerarMensagemErro(diasParaLimpar) { 
    let diasAntecedencia;
    switch (diasParaLimpar) {
        case 1: diasAntecedencia = 5; break;
        case 2: diasAntecedencia = 4; break;
        case 3: diasAntecedencia = 3; break;
        case 4: diasAntecedencia = 2; break;
        case 5: diasAntecedencia = 1; break;
        case 6: return "Só é permitido fazer reservas para o dia atual.";
        default: return "Valor de DiasParaLimpar inválido.";
    }
    //limparCampos();
    return `Não é permitido fazer reservas com mais de ${diasAntecedencia} dias de antecedência.`; 
}



// --- NOVA FUNÇÃO INTELIGENTE DE HORÁRIOS ---
// SUBSTITUA A FUNÇÃO ATUAL POR ESTA VERSÃO COMPLETA (FINAL)
function obterRegrasDeHorario(data) {
    // Formata a data para YYYY-MM-DD (usando hora local para evitar erro de fuso)
    const ano = data.getFullYear();
    const mes = String(data.getMonth() + 1).padStart(2, '0');
    const dia = String(data.getDate()).padStart(2, '0');
    const dataHojeStr = `${ano}-${mes}-${dia}`; 

    // 1. PRIORIDADE: Verifica Horários ESPECIAIS (Feriados, Recessos)
    const especiais = horariosGlobal.Especiais || {};
    
    for (const key in especiais) {
        const periodo = especiais[key];
        
        // Verifica se o período está ativo e se a data cai dentro dele
        if (periodo.ativo !== false && dataHojeStr >= periodo.inicio && dataHojeStr <= periodo.fim) {
            
            // Verifica se existe configuração específica para ESTE dia dentro do período
            const regraDia = periodo.dias ? periodo.dias[dataHojeStr] : null;
            
            if (regraDia) {
                // ACHOU! Retorna a regra do feriado e ignora o padrão da semana
                return {
                    status: regraDia.status, // 'aberto' ou 'fechado'
                    inicio: parseInt(regraDia.abertura?.split(':')[0]) || 6,
                    fim: parseInt(regraDia.fechamento?.split(':')[0]) || 23
                };
            }
        }
    }

    // 2. FALLBACK: Se não é feriado, usa o Horário PADRÃO da semana
    let diaSemana = data.getDay(); 
    if (diaSemana === 0) diaSemana = 7; // Ajusta Domingo (0 -> 7)

    const regraPadrao = horariosGlobal.Padrao ? horariosGlobal.Padrao[diaSemana] : null;
    
    if (regraPadrao) {
        return {
            status: regraPadrao.status,
            inicio: parseInt(regraPadrao.abertura?.split(':')[0]) || 6,
            fim: parseInt(regraPadrao.fechamento?.split(':')[0]) || 23
        };
    }

    // 3. SEGURANÇA: Se não tiver configuração nenhuma, usa o padrão antigo
    if (diaSemana === 7) return { status: 'fechado', inicio: 8, fim: 12 };
    return { status: 'aberto', inicio: 6, fim: 23 };
}




// =================================================================
// FUNÇÃO ATUALIZADA: GERA A LISTA DE HORÁRIOS (COM BLOQUEIO REAL)
// =================================================================
// =================================================================
// FUNÇÃO ATUALIZADA: GERA A LISTA DE HORÁRIOS (CORREÇÃO DE DURAÇÃO 1H)
// =================================================================
window.atualizarOpcoesHorario = function() {
    const elQuadra = document.getElementById('quadra');
    const elDia = document.getElementById('dia');
    const elHora = document.getElementById('hora');
    const elDuracao = document.getElementById('duracao');

    if (!elQuadra || !elDia || !elHora || !elDuracao) {
        console.error("[Agendamento] Elementos do formulário não encontrados.");
        return;
    }
    
    // ---------------------------------------------------------
    // 1. SMART LOCK (Prioridade Total: Clique na Tabela)
    // ---------------------------------------------------------
    if (window.horarioBloqueadoPelaTabela !== null && window.horarioBloqueadoPelaTabela !== undefined) {
        elHora.innerHTML = ''; 
        const horaFixa = parseInt(window.horarioBloqueadoPelaTabela);
        let duracaoValor = parseInt(elDuracao.value);
        if (isNaN(duracaoValor)) duracaoValor = 1; 
        const duracaoReal = elDuracao.value === '3-piramide' ? 2 : duracaoValor;

        const horaInicioStr = String(horaFixa).padStart(2, '0') + ":00";
        const horaFimStr = String(horaFixa + duracaoReal).padStart(2, '0') + ":00";
        
        const option = document.createElement('option');
        option.value = horaInicioStr;
        option.text = `${horaInicioStr} - ${horaFimStr}`;
        elHora.add(option);
        
        elHora.disabled = true;
        elHora.style.backgroundColor = "#e9ecef"; 
		
        const btnAddInterno = document.querySelector('.add-jogador');
        if (btnAddInterno) {
            btnAddInterno.style.pointerEvents = 'auto';
            btnAddInterno.style.opacity = '1';
        }
        
        // Garante que a duração tenha as opções, caso tenha vindo de um estado "Sem opções"
        if (elDuracao.innerHTML.includes("Sem opções")) {
            elDuracao.innerHTML = '<option value="1">1 hora</option><option value="2">2 horas</option><option value="3-piramide">Pirâmide</option>';
            elDuracao.value = "1";
        }

        console.log(`[Smart Lock] Horário fixado em: ${option.text}`);
        return; 
    }

    // 2. RESET DE SEGURANÇA (Para o botão +)
    elHora.disabled = false;
    elHora.style.backgroundColor = ""; 

    // 3. DADOS BÁSICOS E DATAS
    const quadraNome = elQuadra.value;
    const diaVal = parseInt(elDia.value);
    
    const hoje = new Date();
    const diaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay();
    let diff = diaVal - diaHoje;
    if (diff < 0) diff += 7;
    
    const dataSelecionada = new Date();
    dataSelecionada.setDate(hoje.getDate() + diff);
    dataSelecionada.setHours(0,0,0,0);

    const dataFormatada = dataSelecionada.toISOString().split('T')[0];
    const ehHoje = (diff === 0);
    const horaAtual = new Date().getHours();

    const regras = obterRegrasDeHorario(dataSelecionada);
    elHora.innerHTML = ''; 

    if (regras.status === 'fechado') {
        const option = document.createElement('option');
        option.text = "Fechado";
        elHora.add(option);
        elHora.disabled = true;
        elDuracao.innerHTML = '<option value="">Sem opções</option>';
        elDuracao.disabled = true; 
        return;
    }

    // 4. MAPA DE OCUPAÇÃO (Verifica Bloqueios, Aulas e Reservas)
    const numeroQuadra = quadraNome.match(/\d+/); 
    const quadraKeyFull = numeroQuadra ? `Quadra-${numeroQuadra[0]}` : 'Quadra-1'; 
    const bloqueioDoDia = (typeof bloqueiosQuadra !== 'undefined') ? bloqueiosQuadra[quadraKeyFull]?.[dataFormatada] : null;

    let quadraKeySimple = "Quadra1";
    if (quadraNome.includes("2")) quadraKeySimple = "Quadra2";
    else if (quadraNome.includes("3")) quadraKeySimple = "Quadra3";

    const configAula = (typeof configAulasGlobal !== 'undefined') ? configAulasGlobal[quadraKeySimple] : null;
    const reservasAtuais = (typeof reservasPorQuadra !== 'undefined') ? (reservasPorQuadra[quadraNome] || {}) : {};

    const horasOcupadasSet = new Set();
    const diaDaSemanaGrade = diaVal;

    for (const key in reservasAtuais) {
        const r = reservasAtuais[key];
        if (!r || r.status === 'aula_cancelada') continue;
        if (parseInt(r.dia) !== diaDaSemanaGrade) continue;
        const hInicio = parseInt(r.hora);
        let hDur = (r.duracao === '3-piramide' || r.duracao === 3) ? 2 : parseInt(r.duracao || 1);
        if (r.borda === undefined && hDur > 1) hDur = 1; 
        for (let k = 0; k < hDur; k++) horasOcupadasSet.add(hInicio + k);
    }

    // 5. CÁLCULO DOS HORÁRIOS LIVRES (Baseado na regra 1h)
    const slotsLivres1h = new Set();
    const inicioRegra = regras.inicio || 6;
    const fimRegra = regras.fim || 23;

    for (let h = inicioRegra; h < fimRegra; h++) {
        if (ehHoje && h < horaAtual) continue; 
        
        // Verifica Bloqueio Administrativo
        if (bloqueioDoDia && bloqueioDoDia.regras) {
            const inicioB = parseInt(bloqueioDoDia.regras.inicio.split(':')[0]);
            const fimB = parseInt(bloqueioDoDia.regras.fim.split(':')[0]);
            if (h >= inicioB && h < fimB) continue;
        }
        
        // Verifica Reservas
        if (horasOcupadasSet.has(h)) continue;
        
        // Verifica Grade de Aulas (Se não foi cancelada)
        if (configAula && configAula.Ativo && configAula.Grade) {
            const keyAula = `${diaDaSemanaGrade}_${h}`;
            if (configAula.Grade[keyAula] === true) {
                const res = reservasAtuais[keyAula];
                if (!res || res.status !== 'aula_cancelada') continue; 
            }
        }
        slotsLivres1h.add(h);
    }

    // 6. CHECK DE SEQUÊNCIA (O Cérebro da Lógica)
    // Verifica se existe pelo menos UM par de horas consecutivas (ex: 20h e 21h livres)
    let existeSequencia = false;
    for (let h of slotsLivres1h) {
        if (slotsLivres1h.has(h + 1)) {
            existeSequencia = true;
            break; 
        }
    }

    // 7. TRATAMENTO VISUAL DO CAMPO DURAÇÃO
    const btnAddInterno = document.querySelector('.add-jogador');

    if (slotsLivres1h.size === 0) {
        // CASO A: SEM HORÁRIOS (Lotação Total)
        elDuracao.innerHTML = '<option value="">Sem opções</option>';
        elDuracao.disabled = true;
        elDuracao.style.backgroundColor = "#e9ecef";
        elDuracao.style.color = "#6c757d";

        elHora.innerHTML = '<option value="">Sem horários</option>';
        elHora.disabled = true;

        if (btnAddInterno) {
            btnAddInterno.style.pointerEvents = 'none';
            btnAddInterno.style.opacity = '0.3';
        }
        return; // Sai da função aqui
    } else {
        // CASO B: TEM HORÁRIOS (Restaura o menu)
        
        // 1. Se estava bloqueado ("Sem opções"), restaura o HTML completo
        if (elDuracao.innerHTML.includes("Sem opções") || elDuracao.value === "") {
            elDuracao.innerHTML = '<option value="1">1 hora</option><option value="2">2 horas</option><option value="3-piramide">Pirâmide</option>';
            elDuracao.value = "1";
        }
        
        // 2. Destrava o campo (padrão)
        elDuracao.disabled = false;           
        elDuracao.style.backgroundColor = ""; 
        elDuracao.style.color = "";           

        // 3. Aplica a Lógica Inteligente (AQUI ESTAVA O ERRO ANTES)
        // Se não houver sequência (só tem buracos de 1h), esconde as opções de 2h/Pirâmide
        const op2h = elDuracao.querySelector('option[value="2"]');
        const opPiramide = elDuracao.querySelector('option[value="3-piramide"]');

        if (!existeSequencia) {
            // BLOQUEIA VISUALMENTE 2H E PIRÂMIDE
            if (op2h) op2h.style.display = 'none';
            if (opPiramide) opPiramide.style.display = 'none';
            
            // Se o usuário tinha 2h selecionado e trocou de dia para um lotado, força volta pra 1h
            if (elDuracao.value === '2' || elDuracao.value === '3-piramide') {
                elDuracao.value = '1';
            }
        } else {
            // LIBERA VISUALMENTE
            if (op2h) op2h.style.display = 'block';
            // Pirâmide depende também da config global
            if (opPiramide) {
                opPiramide.style.display = (typeof piramideAtivaGlobal !== 'undefined' && piramideAtivaGlobal) ? 'block' : 'none';
            }
        }

        if (btnAddInterno) {
            btnAddInterno.style.pointerEvents = 'auto';
            btnAddInterno.style.opacity = '1';
        }

        // 4. Trava final para Modos Especiais (Manutenção/Aula)
        // Esses modos exigem 1h fixa, então travamos o campo independente da sequência
        const ehModoRestrito = (window.modoAtual === 'manutencao' || window.modoAtual === 'aula');
        if (ehModoRestrito) {
            elDuracao.disabled = true;
            elDuracao.style.backgroundColor = "#e9ecef";
        }
    }

    // 8. GERA LISTA DE HORÁRIOS FINAL
    let duracaoValor = parseInt(elDuracao.value) || 1;
    const duracaoAtual = elDuracao.value === '3-piramide' ? 2 : duracaoValor;
    
    const listaOrdenada = Array.from(slotsLivres1h).sort((a, b) => a - b);
    let encontrouHorario = false;

    listaOrdenada.forEach(h => {
        // Filtra: Só mostra o horário X se o horário X+1 também estiver livre (caso seja reserva de 2h)
        if (duracaoAtual > 1 && !slotsLivres1h.has(h + 1)) return;
        
        const option = document.createElement('option');
        const hFmt = h.toString().padStart(2, '0') + ":00";
        const hFim = (h + duracaoAtual).toString().padStart(2, '0') + ":00";
        option.value = hFmt;
        option.text = `${hFmt} - ${hFim}`;
        elHora.add(option);
        encontrouHorario = true;
    });

    // Segurança final caso o filtro tenha removido tudo
    if (!encontrouHorario) {
        const option = document.createElement('option');
        option.text = "Sem horários";
        elHora.add(option);
        elHora.disabled = true;
    }
};





function esconderOpcoesLongas(elSelect) {
    const op2 = elSelect.querySelector('option[value="2"]');
    const opPiramide = elSelect.querySelector('option[value="3-piramide"]');
    if (op2) op2.style.display = 'none';
    if (opPiramide) opPiramide.style.display = 'none';
    // Se estiver selecionado algo inválido, volta pra 1h
    if (elSelect.value === '2' || elSelect.value === '3-piramide') {
        elSelect.value = '1';
    }
}



// Substitua sua função inteira por esta
window.adicionarJogador = function() {
    if (navigator.vibrate) { 
        navigator.vibrate(50);
    }

    // 1. Antes de tudo, verifica se o ÚLTIMO campo visível está preenchido
    // Buscamos o último select que foi adicionado ao container
    const todosSelects = document.querySelectorAll('select[id^="jogador"]');
    const ultimoSelect = todosSelects[todosSelects.length - 1];

    if (ultimoSelect && (ultimoSelect.value === "" || !ultimoSelect.value)) {
        mostrarNotificacao("<b>⚠️ Atenção:</b><br>Preencha o nome do jogador anterior antes de adicionar outro.", 'warning');
        return; // <--- PONTO CRÍTICO: Bloqueia a criação do novo campo
    }

    if (jogadorCount < 4) {
        jogadorCount++;
        const jogadoresContainer = document.getElementById('jogadoresContainer');

        const newDiv = document.createElement('div');
        newDiv.className = 'form-row';

        const label = document.createElement('label');
        label.setAttribute('for', `jogador${jogadorCount}`);
        label.textContent = 'Jogador:';

        const novoSelect = document.createElement('select');
        novoSelect.id = `jogador${jogadorCount}`;
        novoSelect.name = `jogador${jogadorCount}`;
        novoSelect.setAttribute('onchange', 'handleConvidadoSelect(this)');
        
        const primeiroSelect = document.getElementById('jogador1');
        if (primeiroSelect) {
            novoSelect.innerHTML = primeiroSelect.innerHTML;
        }

        const jogadoresJaSelecionados = [];
        for (let i = 1; i < jogadorCount; i++) {
            const selectAnterior = document.getElementById(`jogador${i}`);
            if (selectAnterior && selectAnterior.value && selectAnterior.value !== "Convidado") {
                jogadoresJaSelecionados.push(selectAnterior.value);
            }
        }

        jogadoresJaSelecionados.forEach(apelido => {
            const optionToRemove = novoSelect.querySelector(`option[value="${apelido}"]`);
            if (optionToRemove) {
                optionToRemove.remove();
            }
        });
        
        newDiv.appendChild(label);
        newDiv.appendChild(novoSelect);
        jogadoresContainer.appendChild(newDiv);

        novoSelect.focus();
    }
};



// SUBSTITUA SUA FUNÇÃO 'atualizarTabela' PELA VERSÃO ABAIXO
// SUBSTITUA A FUNÇÃO atualizarTabela INTEIRA POR ESTA VERSÃO
// Esta versão mantém TODAS as suas validações originais (400+ linhas)
// Apenas removemos a "blitz" que causava o erro ao clicar em Agendar.

async function atualizarTabela() {

    if (navigator.vibrate) { navigator.vibrate(50); }
	
	// =========================================================
    // === TRAVA DE SEGURANÇA: IMPEDE AGENDAR SEM HORÁRIO ===
    // =========================================================
    const inputHora = document.getElementById('hora');
    // Verifica se o valor está vazio ou se o campo está desabilitado com erro
    if (!inputHora || inputHora.value === "" || inputHora.value === "Sem horários" || inputHora.value === "Fechado") {
        mostrarNotificacao("<b>⚠️ Atenção:</b><br>Não há horários disponíveis para realizar um agendamento nesta data.", 'warning');
        return; // <--- PONTO CRÍTICO: Interrompe a função aqui mesmo!
    }
    // =========================================================

    // --- CORREÇÃO: REMOVIDO BLOCO QUE TRAVAVA O PROFESSOR ---
    // Removemos toda a lógica de window.decisaoProfessor aqui.
    // O sistema agora confia que se você preencheu o formulário, é para salvar.
    
    const diaSelecionado = parseInt(document.getElementById('dia').value, 10);
    //const hoje = new Date();
    //const diaDaSemanaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay(); 
    //const isReservaParaHoje = (diaSelecionado === diaDaSemanaHoje);
    
    // Declaração da quadra para uso nas validações
    const quadra = document.getElementById('quadra').value;

    let jogadores = []; 

    // --- COLETA DOS JOGADORES (Lógica Original Restaurada) ---
    for (let i = 1; i <= jogadorCount; i++) {
        let jogadorSelect = document.getElementById(`jogador${i}`);
        if (jogadorSelect) {
            let apelido = jogadorSelect.value; 
            if (apelido === "Convidado" && nomesConvidadosMap[jogadorSelect.id]) {
                jogadores.push(nomesConvidadosMap[jogadorSelect.id]);
            } else if (apelido) {
                jogadores.push(apelido);
            }
        }
    }

	// Limpa o mapa para a próxima reserva
	nomesConvidadosMap = {};

    //if (jogadores.length === 0) { alert('Selecione pelo menos 1 jogador.'); return; }
	if (jogadores.length === 0) { mostrarNotificacao('Selecione pelo menos 1 jogador.', 'error'); return; }
    
    const jogadorLogado = localStorage.getItem('jogadorLogado');
    //const isAdmin = jogadorLogado === "RONALDO TABORDA";
    
    // Verificação de segurança para Aulas Automáticas (Legado da v82 - MANTIDO)
    const isAula = jogadores.some(j => j.toLowerCase() === "aula");

	if (isAula) {
		// NOVA VALIDAÇÃO: Usa o sistema de permissões e checa a quadra
		const isProfessor = verificarPermissao('gestor_aulas');
		const isDono = isUsuarioProfessor(quadra); // Verifica se ele é dono da quadra selecionada no dropdown

		if (!isProfessor && !isUsuarioAdmin()) {
			mostrarNotificacao("Você não tem permissão de Professor para agendar aulas.", 'error');
			limparCampos();
			return;
		}
		
		// Se for professor, mas estiver tentando agendar na quadra errada
		if (isProfessor && !isDono && !isUsuarioAdmin()) {
			mostrarNotificacao("Você não é o professor responsável por esta quadra.", 'error');
			limparCampos();
			return;
		}
    } else {
        // Se não for uma aula (jogo normal), um Admin pode agendar para qualquer um.
        // Um usuário comum só pode agendar se ele mesmo estiver na lista de jogadores.
        if (!isUsuarioAdmin()) {
            // Lógica corrigida para verificar se o apelido selecionado corresponde ao nome completo do usuário logado.
            const jogadorEstaNaReserva = jogadores.some(apelidoSelecionado => {
                const infoJogador = jogadoresData[apelidoSelecionado];
                if (infoJogador) {
                    return infoJogador.nomeCompleto.toLowerCase() === jogadorLogado.toLowerCase();
                }
                return false;
            });

            if (!jogadorEstaNaReserva) {
				mostrarNotificacao("Você não pode fazer uma reserva sem constar nela. Por favor, inclua seu nome na lista.", 'error');
				limparCampos();
				return;
			}
        }
    }
	
	
	//const quadra = document.getElementById('quadra').value;
    const dia = parseInt(document.getElementById('dia').value, 10);
    const horaSelecionada = parseInt(document.getElementById('hora').value, 10);
    const duracao = parseInt(document.getElementById('duracao').value);
	
	
	//const isApenasConvidado = jogadores.length === 1 && jogadores[0] === "Convidado";
	const isApenasConvidado = jogadores.length > 0 && jogadores.every(j => j.startsWith("Convidado"));
    if (isApenasConvidado) {
        mostrarNotificacao("Reservas não podem conter apenas Convidados. É necessário um sócio acompanhando.", 'error');
        limparCampos();
        return;
    }

    //const isConvidado = jogadores.includes("Convidado");
	const isConvidado = jogadores.some(j => j.startsWith("Convidado"));
	if (isConvidado) {
		// Agora, em vez de buscar no banco, usamos a variável global.
		const convidadoConfig = convidadoConfigGlobais;

		if (!convidadoConfig) {
			//alert("Configurações do convidado não encontradas.");
			mostrarNotificacao("Configurações do convidado não encontradas.", 'error');
			return;
		}

		// Verifica se todas as quadras estão desativadas OU todos os dias estão desativados
		if (
			(!convidadoConfig.Quadra1 && !convidadoConfig.Quadra2 && !convidadoConfig.Quadra3) || // Todas as quadras desativadas
			(!convidadoConfig.DiasDeSemana && !convidadoConfig.FimDeSemana) // Todos os dias desativados
		) {
			//alert("Convidados não podem jogar, pois todas as quadras ou todos os dias estão desativados para não sócios.");
			mostrarNotificacao("Convidados não podem jogar, pois todas as quadras ou todos os dias estão desativados para não sócios.", 'error');
			return;
		}

		// Verifica se a quadra selecionada é permitida para o convidado
		const quadraPermitida = convidadoConfig[`Quadra${quadra.split(' ')[1]}`];
		if (!quadraPermitida) {
			// Monta a mensagem informando quais quadras são permitidas
			const quadrasPermitidas = [];
			if (convidadoConfig.Quadra1) quadrasPermitidas.push("Quadra 1 - Coberta");
			if (convidadoConfig.Quadra2) quadrasPermitidas.push("Quadra 2 - Aberta");
			if (convidadoConfig.Quadra3) quadrasPermitidas.push("Quadra 3 - Coberta");

			const mensagemQuadras = quadrasPermitidas.length > 0
				? `Convidados só podem utilizar as seguintes quadras: ${quadrasPermitidas.join(", ")}.`
				: "Convidados não podem utilizar nenhuma quadra.";
			limparCampos();
			//alert(mensagemQuadras);
			mostrarNotificacao(mensagemQuadras, 'error');
			return;
		}

		// Verifica os dias permitidos para o convidado
		const diaDaSemana = dia >= 1 && dia <= 5; // Segunda a sexta
		const fimDeSemana = dia === 6 || dia === 7; // Sábado e domingo

		if (!convidadoConfig.DiasDeSemana && !convidadoConfig.FimDeSemana) {
			//alert("Convidados não podem fazer reservas em nenhum dia.");
			mostrarNotificacao("Convidados não podem fazer reservas em nenhum dia.", 'error');
			limparCampos();
			return;
		}

		if (!convidadoConfig.DiasDeSemana && diaDaSemana) {
			//alert("Convidados só podem fazer reservas no fim de semana (sábado e domingo).");
			mostrarNotificacao("Convidados só podem fazer reservas no fim de semana (sábado e domingo).", 'error');
			limparCampos();
			return;
		}

		if (!convidadoConfig.FimDeSemana && fimDeSemana) {
			//alert("Convidados só podem fazer reservas durante a semana (segunda a sexta).");
			mostrarNotificacao("Convidados só podem fazer reservas durante a semana (segunda a sexta).", 'error');
			limparCampos();
			return;
		}
	}

    
    //const duracao = parseInt(document.getElementById('duracao').value);
	//if (duracao === 2 && (jogadores.length < 2 || jogadores.length > 4)) { alert('Reservas de 2 horas precisam ter no mínimo 2 e no máximo 4 jogadores.'); return; }
	if (duracao === 2 && (jogadores.length < 2 || jogadores.length > 4)) {
		mostrarNotificacao('Reservas de 2h devem ter no mínimo 2 e no máximo 4 jogadores.', 'error');
		return;
	}
    //const quadra = document.getElementById('quadra').value;
	//if (quadrasInativas.has(quadra)) { alert(`A ${quadra} está interditada provisoriamente.`); limparCampos(); return; }
		if (quadrasInativas.has(quadra)) {
		mostrarNotificacao(`A ${quadra} está interditada provisoriamente.`, 'error');
		limparCampos();
		return;
	}
    //const dia = parseInt(document.getElementById('dia').value, 10);
    //const horaSelecionada = parseInt(document.getElementById('hora').value, 10);
    if (!validarDiaReserva(jogadores)) { limparCampos(); return; }
    const reservaValida = await validarSeTemReserva(jogadores);
    if (!reservaValida) { return; }
	//const isRegraDuplasOk = await validarRegraDeDuplas(jogadores, quadra, dia, horaSelecionada, duracao);
    //if (!isRegraDuplasOk) { limparCampos(); return; }
	const resultadoDuplasOk = await validarRegraDeDuplas(jogadores, quadra, dia, horaSelecionada, duracao);
	if (resultadoDuplasOk !== true) { 
		mostrarNotificacao(resultadoDuplasOk, 'warning'); 
		//limparCampos();
		return;
	}
    

	const resultadoOtimizacao = validarOtimizacaoHorario(dia, horaSelecionada, duracao, quadra);
    if (resultadoOtimizacao !== true) {
        mostrarNotificacao(resultadoOtimizacao, 'warning');
        //limparCampos();
        return;
    }
    
    let reservaSalvaComSucesso = false;
    agendamentoEmAndamento = true;
	
	try {
	
	    const dataCompletaParaGravar = calcularDataDoDiaSelecionado(dia);
		
        const reservasRef = database.ref(`sistemas/reservas/${quadra}`);
        const key1 = `${dia}_${horaSelecionada}`;
        const key2 = `${dia}_${horaSelecionada + 1}`;
        const snapshot = await reservasRef.once('value');
        const reservas = snapshot.val() || {};
        const loopDuracao = duracao === 3 ? 2 : duracao;
        
        // --- CORREÇÃO 1: Check de Colisão que ignora 'aula_cancelada' ---
        for (let i = 0; i < loopDuracao; i++) {
            const horarioChave = `${dia}_${horaSelecionada + i}`; 
            const reservaExistente = reservas[horarioChave];
            
			if (reservaExistente && reservaExistente.status !== 'aula_cancelada') {
				
				// False = Ocupado previamente (Passado)
				const msgErro = obterMensagemDeConflito(reservaExistente, false);
				
				mostrarNotificacao(msgErro, 'error');
				
				selecionarQuadra(quadra); // Atualiza o fundo para você ver o bloqueio
				
				// --- CORREÇÃO AQUI (Use este bloco de 3 linhas) ---
				document.querySelector('.form-container').classList.remove('visible');
				document.getElementById('formBackdrop').classList.remove('visible');
				document.getElementById('fab-toggle-form').classList.remove('active');
				// --------------------------------------------------
				
				agendamentoEmAndamento = false;
				return; // Para tudo aqui
			}
            // ---------------------------------------------------------------- 
        }
        // --- LÓGICA DO ORGANIZADOR ---
        const organizadorApelido = Object.keys(jogadoresData).find(apelido => jogadoresData[apelido].nomeCompleto === jogadorLogado) || jogadorLogado;

        // --- CORREÇÃO 2: Helper para Transação (Permite sobrescrever aula_cancelada) ---
        const transactionUpdate = (currentData, newData) => {
            if (currentData === null || currentData.status === 'aula_cancelada') {
                return newData;
            }
            return undefined; // Abortar se estiver ocupado por outra coisa
        };
        // --------------------------------------------------------------------------

        if (vReservasPorConfirmacao === false) {
            // Lógica para quando o sistema de confirmação está DESLIGADO
            if (duracao === 1) {
                const reservaData = { jogadores: jogadores.join(', '), dia, hora: horaSelecionada, duracao, borda: '1h', organizador: organizadorApelido }; 
                await runTransaction(reservasRef.child(key1), current => transactionUpdate(current, reservaData));
            } else if (duracao === 2 || duracao === 3) {
                let jogadoresParte1 = "", jogadoresParte2 = "";
                if (jogadores.length === 1) {
                    jogadoresParte1 = jogadores[0]; jogadoresParte2 = jogadores[0];
                } else {
                    const parte1Array = [], parte2Array = [];
                    if (jogadores.length >= 1) parte1Array.push(jogadores[0]);
                    if (jogadores.length >= 2) parte2Array.push(jogadores[1]);
                    if (jogadores.length >= 3) parte1Array.push(jogadores[2]);
                    if (jogadores.length >= 4) parte2Array.push(jogadores[3]);
                    jogadoresParte1 = parte1Array.join(', '); jogadoresParte2 = parte2Array.join(', ');
                }
                const reservaData1 = { jogadores: jogadoresParte1, dia, hora: horaSelecionada, duracao, borda: '2h', organizador: organizadorApelido }; 
                let reservaData2;
                if (duracao === 3) {
                    reservaData2 = { jogadores: jogadoresParte2, dia, hora: horaSelecionada + 1, organizador: organizadorApelido }; 
                } else {
                    reservaData2 = { jogadores: jogadoresParte2, dia, hora: horaSelecionada + 1, duracao, organizador: organizadorApelido }; 
                }
                
                await runTransaction(reservasRef.child(key1), current => transactionUpdate(current, reservaData1));
                try {
                    await runTransaction(reservasRef.child(key2), current => transactionUpdate(current, reservaData2));
                } catch (err2) {
                    await reservasRef.child(key1).remove(); throw err2;
                }
            }
        } else {
            // Lógica para quando o sistema de confirmação está LIGADO
            const isPiramide = document.getElementById('duracao').value === '3-piramide';
            const outrosJogadores = jogadores.filter(j => j !== organizadorApelido);
			
            //const restoSaoConvidados = outrosJogadores.length > 0 && outrosJogadores.every(j => j.toLowerCase() === 'convidado');
			// --- CORREÇÃO 1: Aceita "Convidado" com nome como auto-confirmado ---
            const restoSaoConvidados = outrosJogadores.length > 0 && outrosJogadores.every(j => j.trim().startsWith("Convidado"));
            
            // Recalcula isReservaParaHoje dentro do escopo seguro se não tiver no topo
            const diaSel = parseInt(document.getElementById('dia').value, 10);
            const h = new Date();
            const ds = h.getDay() === 0 ? 7 : h.getDay();
            const isHoje = (diaSel === ds);

            if (isHoje || isAula || jogadores.length === 1 || isPiramide || restoSaoConvidados) {
				console.log("Executando agendamento direto (Reserva para hoje ou caso de exceção)...");
                
                const confirmacoesAuto = {};
                jogadores.forEach(j => confirmacoesAuto[j] = true); 

                const reservaMetadataDireta = { 
                    jogadores_completo: jogadores.join(', '), 
                    status: 'confirmada', 
                    organizador: organizadorApelido, 
                    confirmacoes: confirmacoesAuto,
                    dataCompleta: dataCompletaParaGravar // <--- O PULO DO GATO (Adicionado aqui)
                };

                if (duracao === 1) {
                    const reservaData = { 
                        jogadores: jogadores.join(', '), 
                        dia, 
                        hora: horaSelecionada, 
                        duracao, 
                        borda: '1h', 
                        dataCompleta: dataCompletaParaGravar, // <--- GARANTIA EXTRA
                        ...reservaMetadataDireta 
                    }; 
                    await runTransaction(reservasRef.child(key1), current => transactionUpdate(current, reservaData));
                } else if (duracao === 2 || duracao === 3) {
                    let jogadoresParte1 = "", jogadoresParte2 = "";
                    if (jogadores.length === 1) {
                        jogadoresParte1 = jogadores[0]; jogadoresParte2 = jogadores[0];
                    } else {
                        const parte1Array = [], parte2Array = [];
                        if (jogadores.length >= 1) parte1Array.push(jogadores[0]);
                        if (jogadores.length >= 2) parte2Array.push(jogadores[1]);
                        if (jogadores.length >= 3) parte1Array.push(jogadores[2]);
                        if (jogadores.length >= 4) parte2Array.push(jogadores[3]);
                        jogadoresParte1 = parte1Array.join(', '); jogadoresParte2 = parte2Array.join(', ');
                    }
                    
                    const reservaData1 = { 
                        jogadores: jogadoresParte1, 
                        dia, 
                        hora: horaSelecionada, 
                        duracao, 
                        borda: '2h', 
                        dataCompleta: dataCompletaParaGravar, // <--- GARANTIA EXTRA
                        ...reservaMetadataDireta 
                    }; 
                    
                    let reservaData2;
                    if (duracao === 3) {
                        reservaData2 = { 
                            jogadores: jogadoresParte2, 
                            dia, 
                            hora: horaSelecionada + 1, 
                            dataCompleta: dataCompletaParaGravar, // <--- GARANTIA EXTRA
                            ...reservaMetadataDireta 
                        }; 
                    } else {
                        reservaData2 = { 
                            jogadores: jogadoresParte2, 
                            dia, 
                            hora: horaSelecionada + 1, 
                            duracao, 
                            dataCompleta: dataCompletaParaGravar, // <--- GARANTIA EXTRA
                            ...reservaMetadataDireta 
                        }; 
                    }
                    await runTransaction(reservasRef.child(key1), current => transactionUpdate(current, reservaData1));
                    try {
                        await runTransaction(reservasRef.child(key2), current => transactionUpdate(current, reservaData2));
                    } catch (err2) {
                        await reservasRef.child(key1).remove(); throw err2;
                    }
                }
            } 
			  else {
                // Caso contrário, a reserva fica PENDENTE de confirmação (já inclui organizador na 'reservaMetadata')
                console.log("Executando agendamento pendente de confirmação...");
                const confirmacoes = {};
                jogadores.forEach(apelido => {
                    // --- CORREÇÃO 2: Convidados não precisam confirmar ---
                    if (apelido.trim().startsWith("Convidado")) {
                        confirmacoes[apelido] = true;
                    } else {
                        confirmacoes[apelido] = (apelido === organizadorApelido);
                    }
                });
				
                const expiraEm = Date.now() + (horasParaExpirarConfig * 3600000);
			
                const reservaMetadata = { jogadores_completo: jogadores.join(', '), status: 'pendente', organizador: organizadorApelido, expiraEm: expiraEm, confirmacoes: confirmacoes };

                
                if (duracao === 1) {
                    const reservaData = { 
                        jogadores: jogadores.join(', '), 
                        dia, 
                        hora: horaSelecionada, 
                        duracao, 
                        borda: '1h', 
                        dataCompleta: dataCompletaParaGravar, // <--- ADICIONADO
                        ...reservaMetadata 
                    };
                    await runTransaction(reservasRef.child(key1), current => transactionUpdate(current, reservaData));
                } else if (duracao === 2) {
                    let jogadoresPrimeiraHora = "", jogadoresSegundaHora = "";
                    if (jogadores.length === 2) {
                        jogadoresPrimeiraHora = jogadores[0];
                        jogadoresSegundaHora = jogadores[1];
                    } else {
                        jogadoresPrimeiraHora = jogadores.slice(0, 2).join(', ');
                        jogadoresSegundaHora = jogadores.slice(2).join(', ');
                    }
                    
                    const reservaPendente1 = { 
                        jogadores: jogadoresPrimeiraHora, 
                        dia, 
                        hora: horaSelecionada, 
                        duracao, 
                        borda: '2h', 
                        dataCompleta: dataCompletaParaGravar, // <--- ADICIONADO
                        ...reservaMetadata 
                    };
                    
                    const reservaPendente2 = { 
                        jogadores: jogadoresSegundaHora, 
                        dia, 
                        hora: horaSelecionada + 1, 
                        dataCompleta: dataCompletaParaGravar, // <--- ADICIONADO
                        ...reservaMetadata, 
                        duracao 
                    }; 
                    
                    await runTransaction(reservasRef.child(key1), current => transactionUpdate(current, reservaPendente1));
                    try {
                        await runTransaction(reservasRef.child(key2), current => transactionUpdate(current, reservaPendente2));
                    } catch (err2) {
                        await reservasRef.child(key1).remove(); throw err2;
                    }
                }
            }
        }
        reservaSalvaComSucesso = true;
   	
	} catch (error) {
	    console.error("Erro ao atualizar tabela:", error); 
		mostrarNotificacao(error.message, 'error'); 
		
		// --- CORREÇÃO AQUI (Use o mesmo bloco) ---
		document.querySelector('.form-container').classList.remove('visible');
		document.getElementById('formBackdrop').classList.remove('visible');
		document.getElementById('fab-toggle-form').classList.remove('active');
		// -----------------------------------------
				
	} finally {
		agendamentoEmAndamento = false; 
	}

   
    if (reservaSalvaComSucesso) {
        // --- INÍCIO DA NOVA LÓGICA DE NOTIFICAÇÃO UNIFICADA ---

        const isPiramide = document.getElementById('duracao').value === '3-piramide';
        
		// 1. Captura a lista de nomes reais dos convidados
        const listaConvidados = jogadores.filter(j => j.trim().startsWith("Convidado"));
        const qtdConvidados = listaConvidados.length;
        const temConvidado = qtdConvidados > 0;
        // -----------------------------------------------------
		
        const organizadorApelido = Object.keys(jogadoresData).find(apelido => jogadoresData[apelido].nomeCompleto === jogadorLogado);
        const outrosJogadores = jogadores.filter(j => j !== organizadorApelido);
		
        //const restoSaoConvidados = outrosJogadores.length > 0 && outrosJogadores.every(j => j.toLowerCase() === 'convidado');
		// --- CORREÇÃO 3: Ajuste na notificação para convidados nomeados ---
        const restoSaoConvidados = outrosJogadores.length > 0 && outrosJogadores.every(j => j.trim().startsWith("Convidado"));
        
        // Recalcula isReservaParaHoje
        const diaSel = parseInt(document.getElementById('dia').value, 10);
        const h = new Date();
        const ds = h.getDay() === 0 ? 7 : h.getDay();
        const isHoje = (diaSel === ds);

        const precisaConfirmacao = vReservasPorConfirmacao && !isHoje && !isAula && jogadores.length > 1 && !isPiramide && !restoSaoConvidados;
        
        let mensagemFinal = '';
        let tipoFinal = '';

        // 1. Define a mensagem principal e a cor
        if (precisaConfirmacao) {
            //mensagemFinal = '<b>Reserva pré-agendada!</b><br>Os outros jogadores precisam confirmar a participação para que o horário seja garantido.';
			mensagemFinal = '<b>Reserva pré-agendada!</b><br><br>Os outros jogadores precisam confirmar a participação para que o horário seja garantido.';
            tipoFinal = 'warning'; // AMARELO para pendente
        } else {
            mensagemFinal = 'Reserva efetuada com sucesso!';
            tipoFinal = 'success'; // VERDE para sucesso direto
        }

        // 2. Adiciona informações extras à mensagem principal, se necessário
        // 2. Notificação de Cobrança por Nome (Melhorada)
        // 2. Notificação de Cobrança por Nome (Com Soma Total)
        if (temConvidado) {
            const tituloFinanceiro = qtdConvidados > 1 ? 'Convidados' : 'Convidado';
            let listaNomesHtml = "";
            let valorTotal = qtdConvidados * 50; // Faz o cálculo automático
            
            listaConvidados.forEach(nomeBruto => {
                // Limpa o prefixo para exibir apenas o nome
                const nomeLimpo = nomeBruto.replace(/^Convidado[:\s-]{1,}/i, '').trim();
                listaNomesHtml += `• ${nomeLimpo}: R$ 50,00<br>`;
            });

            mensagemFinal += `<br><br><b>${tituloFinanceiro}:</b><br>${listaNomesHtml}`;
            
            // Adiciona a soma total se houver mais de um convidado
            if (qtdConvidados > 1) {
                mensagemFinal += `<b>Total a pagar: R$ ${valorTotal},00</b><br>`;
            } else {
                mensagemFinal += `<b>Total a pagar: R$ 50,00</b><br>`; 
            }

            mensagemFinal += `<span style="font-size: 0.85em; color: #666;">Pagar diretamente ao Toni</span><br>`;
            mensagemFinal += `<br><span style="font-size: 0.85em; opacity: 0.8;"><i>Sujeito a cancelamento em até 4h antes se um sócio solicitar.</i></span>`;
        }
        
        if (isPiramide) {
            mensagemFinal += "<br><br><b>Lembretes (Pirâmide):</b><br>• Informar no grupo sobre o jogo.<br>• Taxa de R$ 5,00 por jogador (PIX para Edemar).";
        }

        // 3. Mostra a notificação completa uma única vez
        mostrarNotificacao(mensagemFinal, tipoFinal);

        // --- FIM DA NOVA LÓGICA DE NOTIFICAÇÃO UNIFICADA ---
    }
    
    limparCampos();
    selecionarQuadra(quadra);
	
	// Fecha o painel do formulário e o fundo escuro após o agendamento
    const fabToggleBtn = document.getElementById('fab-toggle-form');
    const formContainer = document.querySelector('.form-container');
    const formBackdrop = document.getElementById('formBackdrop'); // <--- NOVO

    if (formContainer && fabToggleBtn && formContainer.classList.contains('visible')) {
        formContainer.classList.remove('visible');
        if (formBackdrop) formBackdrop.classList.remove('visible'); // <--- NOVO
        fabToggleBtn.classList.remove('active'); 
    }
}





function capitalizarNome(nome) {
    if (!nome) return ""; // Retorno seguro para strings vazias ou nulas

    return nome.split(' ')
               .map(palavra => palavra.charAt(0).toUpperCase() + palavra.slice(1).toLowerCase()) // <-- ADICIONADO .toLowerCase() AQUI
               .join(' ');
}

// --- NOVA FUNÇÃO GLOBAL DE FORMATAÇÃO INTELIGENTE ---
// Substitui as versões locais dentro de gerarPlacarHtml e atualizarNomesPlacarAoVivo
function formatarNomeInteligente(nomeCompletoRaw, apelidoRaw, isHorizontal) {
    const nomeCompleto = capitalizarNome(nomeCompletoRaw || apelidoRaw);
    const apelido = capitalizarNome(apelidoRaw);
    
    // Se não for horizontal (celular em pé), retorna só o apelido
    if (!isHorizontal) return apelido;

    // Lógica Inteligente (Palavra por Palavra)
    const apelidoWords = apelido.split(' ');
    const todasPalavrasPresentes = apelidoWords.every(word => 
        nomeCompleto.toLowerCase().includes(word.toLowerCase())
    );

    if (todasPalavrasPresentes) {
        // Caso A: As palavras do apelido estão no nome
        let nomeFinal = nomeCompleto;
        apelidoWords.forEach(word => {
            const regex = new RegExp(`\\b${word}\\b`, 'gi');
            nomeFinal = nomeFinal.replace(regex, '<b>$&</b>');
        });
        return nomeFinal;
    } else {
        // Caso B: O apelido é diferente
        return `${nomeCompleto} (<b>${apelido}</b>)`;
    }
}




// Variável global para rastrear células já excluídas
const celulasExcluidas = new Set();


// SUBSTITUA SUA FUNÇÃO 'excluirReserva' PELA VERSÃO ABAIXO
async function excluirReserva(horaIndex, diaIndex) {
    try {
        const jogadorLogado = localStorage.getItem('jogadorLogado');
       
		if (!jogadorLogado) {
			mostrarNotificacao("<b>⚠️ Atenção:</b><br>Não foi possível identificar o jogador logado.", 'error');
			return;
		}

        const quadraAtual = quadraSelecionada;
        const horaClicada = horaIndex + 6;
        const reservasDaQuadraAtual = reservasPorQuadra[quadraAtual] || {};

        let keyPrincipal = `${diaIndex}_${horaClicada}`;
        let reservaPrincipal = reservasDaQuadraAtual[keyPrincipal];

        const keyAnterior = `${diaIndex}_${horaClicada - 1}`;
        const reservaAnterior = reservasDaQuadraAtual[keyAnterior];
        
        if (reservaAnterior && reservaAnterior.duracao > 1 && reservaPrincipal && reservaPrincipal.borda === undefined) {
            keyPrincipal = keyAnterior;
            reservaPrincipal = reservaAnterior;
        }

        if (!reservaPrincipal) {
            return;
        }
        
        const reserva1 = reservaPrincipal;
        const key1 = keyPrincipal;
        const key2 = `${diaIndex}_${reserva1.hora + 1}`;
        const reserva2 = (reserva1.duracao > 1) ? reservasDaQuadraAtual[key2] : null;

        let temPermissao = false;
        const apelidoJogadorLogado = Object.keys(jogadoresData).find(
            apelido => jogadoresData[apelido].nomeCompleto.toLowerCase() === jogadorLogado.toLowerCase()
        ) || jogadorLogado;
        
        // Verifica Tipos Especiais
        const nomeDaReserva = (reserva1.jogadores_completo || reserva1.jogadores).toLowerCase().trim();
        const isAula = nomeDaReserva === 'aula';
        const isManutencao = nomeDaReserva === 'manutencao' || reserva1.tipo === 'manutencao';
        
        const isProfessorDono = verificarPermissao('gestor_aulas') && isUsuarioProfessor(quadraAtual);
        const isManutencaoUser = verificarPermissao('controle_quadras');

        // --- LÓGICA DE PERMISSÃO ---
        if (isManutencao) {
            if (isManutencaoUser || isUsuarioAdmin()) {
                temPermissao = true;
            } else {
                mostrarNotificacao("<b>⚠️ Atenção:</b><br><br>Apenas a equipe de manutenção pode remover bloqueios.", 'warning');
            }
        } else if (isAula) {
			if (isProfessorDono || isUsuarioAdmin() || reserva1.organizador === apelidoJogadorLogado) { 
				temPermissao = true; 
			} else { 
				mostrarNotificacao("<b>⚠️ Atenção:</b><br><br>Apenas o professor ou Admin podem excluir aulas.", 'warning');
			}
		} else if (vReservasPorConfirmacao === true && reserva1.status === 'pendente') {
            if (isUsuarioAdmin() || reserva1.organizador === apelidoJogadorLogado || isProfessorDono) { temPermissao = true; } 
            else {  
			   mostrarNotificacao("<b>⛔ Atenção:</b><br><br>Apenas o organizador ou Admin podem excluir reserva pendente.", 'warning');
			}
        } else {
            // Reserva Normal ou Pirâmide
            let jogadoresNaReserva = (reserva1.jogadores_completo || reserva1.jogadores).split(', ').map(j => j.trim());
            if (reserva2) {
                const j2 = (reserva2.jogadores_completo || reserva2.jogadores).split(', ').map(j => j.trim());
                jogadoresNaReserva = [...new Set([...jogadoresNaReserva, ...j2])];
            }
            const statusDoJogador = reserva1.confirmacoes ? reserva1.confirmacoes[apelidoJogadorLogado] : undefined;
            
            if (isUsuarioAdmin() || isProfessorDono || (jogadoresNaReserva.includes(apelidoJogadorLogado) && statusDoJogador !== 'recusado')) {
                temPermissao = true;
            } else {
                if (statusDoJogador === 'recusado') {
					mostrarNotificacao("<b>⚠️ Atenção:</b><br><br>Você não pode excluir uma reserva que já recusou.", 'error');
                } else {
					mostrarNotificacao("<b>⚠️ Atenção:</b><br><br>Apenas jogadores da reserva podem excluí-la!", 'error');
                }
            }
        }

        if (temPermissao) {
            const dataReserva = document.getElementById('tabelaQuadra').rows[1].cells[diaIndex-1]?.textContent.trim().replace(/\//g, '-');
            const duracaoDaReserva = reserva1.duracao === 3 ? 2 : reserva1.duracao;
            const horaFinal = reserva1.hora + duracaoDaReserva;
            const horarioFormatado = `${String(reserva1.hora).padStart(2, '0')}:00 - ${String(horaFinal).padStart(2, '0')}:00`;
            
            let listaJogadoresParaLog;
            
            if (reserva1.jogadores_completo) {
                listaJogadoresParaLog = reserva1.jogadores_completo.split(',').map(j => j.trim());
            } else {
                listaJogadoresParaLog = reserva1.jogadores.split(',').map(j => j.trim());
                if (reserva1.duracao > 1 && reserva2 && reserva2.jogadores) {
                    const jogadoresParte2 = reserva2.jogadores.split(',').map(j => j.trim());
                    listaJogadoresParaLog = [...listaJogadoresParaLog, ...jogadoresParte2];
                }
                listaJogadoresParaLog = [...new Set(listaJogadoresParaLog)];
            }

            // CORREÇÃO 1: COR VERDE NA PIRÂMIDE
            if (reserva1.duracao === 3) {
                if (!reserva1.confirmacoes) reserva1.confirmacoes = {};
                listaJogadoresParaLog.forEach(player => {
                    reserva1.confirmacoes[player] = true;
                });
            }

            let duracaoTexto = reserva1.duracao === 1 ? "1 Hora" : "2 Horas";
            if(reserva1.duracao === 3) duracaoTexto = "2 Horas - Pirâmide";

            const jogadoresComPosicao = listaJogadoresParaLog.map(apelido => {
                return { apelido: apelido, posicao: "0" };
            });
            
            // CORREÇÃO 2: LÓGICA DINÂMICA DE SUFIXO
            let sufixoPerfis = "";
            const dadosUsuarioLogado = Object.values(jogadoresData).find(j => j.nomeCompleto === jogadorLogado);

            if (dadosUsuarioLogado && dadosUsuarioLogado.perfis) {
                const perfisAtivos = Object.keys(dadosUsuarioLogado.perfis).filter(k => dadosUsuarioLogado.perfis[k] === true);
                const listaFormatada = perfisAtivos.map(nomePerfil => {
                    const configPerfil = perfisConfigGlobal[nomePerfil];
                    return (configPerfil && configPerfil.abreviacao) ? configPerfil.abreviacao : nomePerfil;
                });
                
                if (listaFormatada.length > 0) {
                    sufixoPerfis = ` (${listaFormatada.join(', ')})`;
                }
            }
            
            if (sufixoPerfis === "") {
                 if (isUsuarioAdmin()) sufixoPerfis = " (Admin)";
                 else if (isProfessorDono) sufixoPerfis = " (Prof)";
            }

            const usuarioParaLog = `${jogadorLogado}${sufixoPerfis}`;
            
            let motivoLog = "Excluído manualmente"; 
            if (isAula) motivoLog = "Aula Extra cancelada pelo Professor"; 
            if (isManutencao) motivoLog = "Manutenção cancelada pela Equipe";

            let logData = {
                quadra: quadraAtual,
                horario: horarioFormatado,
                jogadores: jogadoresComPosicao,
                usuario: usuarioParaLog,
                duracao: duracaoTexto,
                data: dataReserva,
                motivo: motivoLog
            };

            // =================================================================
            // CORREÇÃO 3: STATUS E ORGANIZADOR
            // =================================================================
            if (reserva1.status) {
                logData.statusNoMomentoDaExclusao = reserva1.status;
            } else if (reserva1.duracao === 3) {
                logData.statusNoMomentoDaExclusao = "Aguardando";
            }

            if (reserva1.resultado) logData.resultado = reserva1.resultado;
			
            // --- AQUI ESTÁ A MUDANÇA: Usa a nova função de tradução ---
            if (reserva1.confirmacoes) {
                logData.confirmacoes = traduzirConfirmacoesParaLog(reserva1.confirmacoes);
            }
            // ----------------------------------------------------------
            
            if (reserva1.organizador) {
                logData.organizadorDaReserva = reserva1.organizador;
            } else if (reserva1.duracao === 3 && listaJogadoresParaLog.length > 0) {
                logData.organizadorDaReserva = listaJogadoresParaLog[0];
            }
            // =================================================================
			
            registrarExclusao(logData); 
            
            const criarExcecao = (h) => ({
                status: 'aula_cancelada',
                responsavel: reserva1.organizador || "Sistema",
                dataCancelamento: new Date().toISOString(),
                dia: diaIndex,
                hora: h
            });

            const deveRestaurarH1 = verificarSeEhGradeFixa(quadraAtual, diaIndex, reserva1.hora) && !isManutencao;
            const valorH1 = deveRestaurarH1 ? criarExcecao(reserva1.hora) : null;

            const updates = {};
            updates[`sistemas/reservas/${quadraAtual}/${key1}`] = valorH1;

            if (reserva1.duracao > 1) {
                const hora2 = reserva1.hora + 1;
                const deveRestaurarH2 = verificarSeEhGradeFixa(quadraAtual, diaIndex, hora2) && !isManutencao;
                const valorH2 = deveRestaurarH2 ? criarExcecao(hora2) : null;
                
                updates[`sistemas/reservas/${quadraAtual}/${key2}`] = valorH2;
            }

            database.ref().update(updates);
            
            if (isAula) mostrarNotificacao('Aula Extra cancelada com sucesso!', 'success');
            else if (isManutencao) mostrarNotificacao('Manutenção cancelada e horário liberado!', 'success');
            else mostrarNotificacao('Reserva excluída com sucesso!', 'success');
        }
    
	} catch (error) {
        console.error("❌ Erro fatal durante a exclusão:", error);
        mostrarNotificacao("<b>⚠️ Erro:</b><br>Ocorreu um problema inesperado durante a exclusão.", 'error');
    }
}





// Função para limpar o conteúdo da célula 
function limparCelula(celula) {
    if (celula) {
        celula.innerHTML = ""; // Limpa o conteúdo da célula
        celula.style.backgroundColor = ""; // Restaura a cor de fundo
        celula.style.border = "1px solid #ddd"; // Restaura a borda padrão
        celula.removeAttribute('data-duracao'); // Remove o atributo de duração

        // Remover rowSpan apenas se a reserva for de 2 horas e tiver apenas um jogador
        if (celula.rowSpan === 2) {
            celula.rowSpan = 1; // Restaura o rowSpan para o padrão
        }
		
		// --- INÍCIO DA CORREÇÃO ADICIONADA AQUI ---
        // Garante a remoção completa dos dados de bloqueio "fantasmas"
        celula.removeAttribute('data-blocked');
        celula.removeAttribute('data-motivo');
        celula.removeAttribute('data-horario-inicio');
        celula.removeAttribute('data-horario-fim');
        celula.removeAttribute('data-data');
        // --- FIM DA CORREÇÃO ---
    }
}

const reservasExcluidasFirebase = new Set();

function excluirReservaFirebase(horaSelecionada, diaIndex, quadra) {
    const key = `${diaIndex}_${horaSelecionada}`;

    if (!reservasExcluidasFirebase.has(key)) {
        reservasExcluidasFirebase.add(key);
        database.ref(`sistemas/reservas/${quadra}/${key}`).remove()
            .then(() => {
                reservasExcluidasFirebase.delete(key);
            })
            .catch((error) => console.error(`Erro ao remover a reserva do Firebase: ${error}`));
    }
}



// SUBSTITUA A FUNÇÃO limparCampos POR ESTA VERSÃO QUE DESTRAVA TUDO
// SUBSTITUA A FUNÇÃO limparCampos POR ESTA VERSÃO QUE DESTRAVA TUDO
function limparCampos() {

    // --- NOVO: Reseta a trava de horário fixo ---
    window.horarioBloqueadoPelaTabela = null; 
    // -------------------------------------------
    
    // --- CORREÇÃO DO ERRO: Libera todas as quadras sempre que limpar o formulário ---
    if (typeof liberarTodasQuadras === 'function') {
        liberarTodasQuadras(); 
    }
    // -------------------------------------------------------------------------------

    // 1. REMOVE O MODO MANUTENÇÃO (Restaura o visual padrão)
    const formContainer = document.querySelector('.form-container');
    if (formContainer) formContainer.classList.remove('modo-manutencao');

    // 2. Reseta os campos extras de jogadores
    const jogadoresContainer = document.getElementById('jogadoresContainer');
    if (jogadoresContainer) {
        while (jogadoresContainer.children.length > 1) {
            jogadoresContainer.removeChild(jogadoresContainer.lastChild); 
        }
    }
    
    jogadorCount = 1; 

    // 3. Reseta inputs do formulário
    const form = document.getElementById('dataForm');
    if (form) form.reset();
    
    // --- CORREÇÃO IMPORTANTE: DESTRAVA O JOGADOR 1 ---
    const elJog1 = document.getElementById('jogador1');
    if (elJog1) {
        elJog1.disabled = true;           // Desabilita totalmente a entrada
        elJog1.style.pointerEvents = 'none'; // Impede cliques e foco
        elJog1.style.backgroundColor = '#f0f0f0'; // Cor de desabilitado
        elJog1.style.color = '#666';      // Texto acinzentado
    }
    
    // --- CORREÇÃO IMPORTANTE: DESTRAVA A DURAÇÃO ---
    const elDur = document.getElementById('duracao');
    if (elDur) {
        elDur.value = '1';
        elDur.disabled = false; // Garante que volta a ser editável
        
        // --- ATUALIZAÇÃO (Apenas estas 3 linhas foram ajustadas) ---
        elDur.style.backgroundColor = ''; // Remove fundo cinza
        elDur.style.color = '';           // Remove texto cinza (volta pro preto)
        elDur.style.opacity = '';         // Remove qualquer opacidade residual
        // -----------------------------------------------------------

        // Restaura a opção de pirâmide se estiver escondida
        const opPiramide = elDur.querySelector('option[value="3-piramide"]');
        if (opPiramide) opPiramide.style.display = (typeof piramideAtivaGlobal !== 'undefined' && piramideAtivaGlobal) ? 'block' : 'none'; 
    }

    // 4. Destrava os outros campos principais
    ['quadra', 'dia', 'hora'].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.disabled = false;            
            el.style.backgroundColor = ""; 
            el.style.color = "";            
        }
    });

    // 5. Remove opções "Aula" que ficaram perdidas nos selects
    document.querySelectorAll('select[id^="jogador"]').forEach(select => {
        const aulaOption = select.querySelector("option[value='aula']");
        if (aulaOption) {
            aulaOption.remove();
        }
    });

    // 6. Restaura Títulos e Labels para o padrão "Novo Agendamento"
    const formTitle = document.querySelector('.form-header h3');
    if (formTitle) formTitle.textContent = 'Novo Agendamento';

    const labelResp = document.querySelector('label[for="jogador1"]');
    if (labelResp) labelResp.textContent = 'Jogador:';
    
    // 7. Restaura o Botão Agendar para o padrão
    const btnAgendar = document.getElementById('botaoAgendar');
    if (btnAgendar) {
        // Clona para remover listeners antigos e limpar textos
        const novoBtn = btnAgendar.cloneNode(true);
        btnAgendar.parentNode.replaceChild(novoBtn, btnAgendar);
        
        novoBtn.id = 'botaoAgendar';
        novoBtn.textContent = 'Agendar';
        
        // Reconecta a função padrão
        if (typeof atualizarTabela === 'function') novoBtn.onclick = atualizarTabela;
    }
}




function atualizarDatas() {
  
  // --- INÍCIO DA NOVA IMPLEMENTAÇÃO ---
  // 1. Pega a configuração de dias de antecedência
  const diasParaLimpar = window.DiasParaLimpar || 4; // Padrão de 4 (resultando em 2 dias) se falhar
  let maxDiasPermitidos;
  
  // 2. Converte a configuração 'DiasParaLimpar' no número de dias futuros permitidos
  // (Esta lógica foi copiada da função validarDiaReserva)
  switch (diasParaLimpar) {
      case 1: maxDiasPermitidos = 5; break; // 6 dias no total (Hoje + 5)
      case 2: maxDiasPermitidos = 4; break; // 5 dias no total (Hoje + 4)
      case 3: maxDiasPermitidos = 3; break; // 4 dias no total (Hoje + 3)
      case 4: maxDiasPermitidos = 2; break; // 3 dias no total (Hoje + 2)
      case 5: maxDiasPermitidos = 1; break; // 2 dias no total (Hoje + 1)
      case 6: maxDiasPermitidos = 0; break; // 1 dia no total (Hoje)
      default: maxDiasPermitidos = 2; // Padrão de 3 dias caso algo falhe
  }

  // 3. Prepara os elementos e os nomes dos dias
  const diaSelect = document.getElementById('dia');
  diaSelect.innerHTML = ''; // Limpa o dropdown para garantir
  
  // Nomes dos dias na ordem do JS (0=Domingo, 1=Segunda... 6=Sábado)
  const nomesDias = ["Domingo", "Segunda-Feira", "Terça-Feira", "Quarta-Feira", "Quinta-Feira", "Sexta-Feira", "Sábado"];
  
  // Pega o índice do dia de hoje (0=Dom, 1=Seg... 6=Sab)
  const hojeIndex = new Date().getDay();

  // 4. Loop para preencher o dropdown apenas com os dias permitidos
  for (let i = 0; i <= maxDiasPermitidos; i++) {
      const diaIndex = (hojeIndex + i) % 7; // Calcula o índice do dia (0-6)
      
      // Converte o índice (0-6) para o valor (1-7) usado pelo sistema
      // (Domingo=0 -> 7, Segunda=1 -> 1, ..., Sábado=6 -> 6)
      const valorDia = (diaIndex === 0) ? 7 : diaIndex; 

      const option = document.createElement('option');
      option.value = valorDia;
      option.textContent = nomesDias[diaIndex];

      if (i === 0) {
          option.selected = true; // Seleciona o dia de hoje por padrão
      }
      
      diaSelect.appendChild(option);
  }
  // --- FIM DA NOVA IMPLEMENTAÇÃO ---


  // --- INÍCIO DA LÓGICA ORIGINAL (PARA O CABEÇALHO DA TABELA) ---
  const dataInicio = new Date();
  
  let diaDaSemana = dataInicio.getDay(); 
  const dias = document.querySelectorAll("th");
  //let vAtualizarDatas = 1; 

  const linhaDatas = dias[0].parentNode.nextElementSibling;

  try {
    if (!vLimparDiasAnteriores) { 
            LimparDiasAnteriores();
            vLimparDiasAnteriores = true; // Define como falso após a primeira execução
    }
  } catch (error){
        console.error("Erro ao limpar dias anteriores:", error);
    }

  //alert(`dia da semana: ${diaDaSemana}`);
  
  switch (DiasParaLimpar) {
  //switch (vAtualizarDatas) {
    case 1: 
      switch (diaDaSemana) {
        case 0: preencherCeldas(dataInicio, [1, 2, 3, 4, 5, -1, 0], linhaDatas); break;
        case 1: preencherCeldas(dataInicio, [0, 1, 2, 3, 4, 5, -1], linhaDatas); break;
        case 2: preencherCeldas(dataInicio, [-1, 0, 1, 2, 3, 4, 5], linhaDatas); break;
        case 3: preencherCeldas(dataInicio, [5, -1, 0, 1, 2, 3, 4], linhaDatas); break;
        case 4: preencherCeldas(dataInicio, [4, 5, -1, 0, 1, 2, 3], linhaDatas); break;
        case 5: preencherCeldas(dataInicio, [3, 4, 5, -1, 0, 1, 2], linhaDatas); break;
        case 6: preencherCeldas(dataInicio, [2, 3, 4, 5, -1, 0, 1], linhaDatas); break;
      }
      break;
    case 2:
      switch (diaDaSemana) {
        case 0: preencherCeldas(dataInicio, [1, 2, 3, 4, -2, -1, 0], linhaDatas); break;
        case 1: preencherCeldas(dataInicio, [0, 1, 2, 3, 4, -2, -1], linhaDatas); break;
        case 2: preencherCeldas(dataInicio, [-1, 0, 1, 2, 3, 4, -2], linhaDatas); break;
        case 3: preencherCeldas(dataInicio, [-2, -1, 0, 1, 2, 3, 4], linhaDatas); break;
        case 4: preencherCeldas(dataInicio, [4, -2, -1, 0, 1, 2, 3], linhaDatas); break;
        case 5: preencherCeldas(dataInicio, [3, 4, -2, -1, 0, 1, 2], linhaDatas); break;
        case 6: preencherCeldas(dataInicio, [2, 3, 4, -2, -1, 0, 1], linhaDatas); break;
      }
      break;
    case 3:
      switch (diaDaSemana) {
        case 0: preencherCeldas(dataInicio, [1, 2, 3, -3, -2, -1, 0], linhaDatas); break;
        case 1: preencherCeldas(dataInicio, [0, 1, 2, 3, -3, -2, -1], linhaDatas); break;
        case 2: preencherCeldas(dataInicio, [-1, 0, 1, 2, 3, -3, -2], linhaDatas); break;
        case 3: preencherCeldas(dataInicio, [-2, -1, 0, 1, 2, 3, -3], linhaDatas); break;
        case 4: preencherCeldas(dataInicio, [-3, -2, -1, 0, 1, 2, 3], linhaDatas); break;
        case 5: preencherCeldas(dataInicio, [3, -3, -2, -1, 0, 1, 2], linhaDatas); break;
        case 6: preencherCeldas(dataInicio, [2, 3, -3, -2, -1, 0, 1], linhaDatas); break;
      }
      break;
    case 4:
      switch (diaDaSemana) {
        case 0: preencherCeldas(dataInicio, [1, 2, -4, -3, -2, -1, 0], linhaDatas); break;
        case 1: preencherCeldas(dataInicio, [0, 1, 2, -4, -3, -2, -1], linhaDatas); break;
        case 2: preencherCeldas(dataInicio, [-1, 0, 1, 2, -4, -3, -2], linhaDatas); break;
        case 3: preencherCeldas(dataInicio, [-2, -1, 0, 1, 2, -4, -3], linhaDatas); break;
        case 4: preencherCeldas(dataInicio, [-3, -2, -1, 0, 1, 2, -4], linhaDatas); break;
        case 5: preencherCeldas(dataInicio, [-4, -3, -2, -1, 0, 1, 2], linhaDatas); break;
        case 6: preencherCeldas(dataInicio, [2, -4, -3, -2, -1, 0, 1], linhaDatas); break;
      }
      break;
    case 5:
      switch (diaDaSemana) {
        case 0: preencherCeldas(dataInicio, [1, -5, -4, -3, -2, -1, 0], linhaDatas); break;
        case 1: preencherCeldas(dataInicio, [0, 1, -5, -4, -3, -2, -1], linhaDatas); break;
        case 2: preencherCeldas(dataInicio, [-1, 0, 1, -5, -4, -3, -2], linhaDatas); break;
        case 3: preencherCeldas(dataInicio, [-2, -1, 0, 1, -5, -4, -3], linhaDatas); break;
        case 4: preencherCeldas(dataInicio, [-3, -2, -1, 0, 1, -5, -4], linhaDatas); break;
        case 5: preencherCeldas(dataInicio, [-4, -3, -2, -1, 0, 1, -5], linhaDatas); break;
        case 6: preencherCeldas(dataInicio, [-5, -4, -3, -2, -1, 0, 1], linhaDatas); break; 
      }
      break;
    case 6:
      switch (diaDaSemana) {
        case 0: preencherCeldas(dataInicio, [-6, -5, -4, -3, -2, -1, 0], linhaDatas); break;
        case 1: preencherCeldas(dataInicio, [0, -6, -5, -4, -3, -2, -1], linhaDatas); break;
        case 2: preencherCeldas(dataInicio, [-1, 0, -6, -5, -4, -3, -2], linhaDatas); break;
        case 3: preencherCeldas(dataInicio, [-2, -1, 0, -6, -5, -4, -3], linhaDatas); break;
        case 4: preencherCeldas(dataInicio, [-3, -2, -1, 0, -6, -5, -4], linhaDatas); break;
        case 5: preencherCeldas(dataInicio, [-4, -3, -2, -1, 0, -6, -5], linhaDatas); break;
        case 6: preencherCeldas(dataInicio, [-5, -4, -3, -2, -1, 0, -6], linhaDatas); break;
      }
      break;
	  case 7:
      switch (diaDaSemana) {
        case 0: preencherCeldas(dataInicio, [-6, -5, -4, -3, -2, -1, 0], linhaDatas); break;
        case 1: preencherCeldas(dataInicio, [0, -6, -5, -4, -3, -2, -1], linhaDatas); break;
        case 2: preencherCeldas(dataInicio, [-1, 0, -6, -5, -4, -3, -2], linhaDatas); break;
        case 3: preencherCeldas(dataInicio, [-2, -1, 0, -6, -5, -4, -3], linhaDatas); break;
        case 4: preencherCeldas(dataInicio, [-3, -2, -1, 0, -6, -5, -4], linhaDatas); break;
        case 5: preencherCeldas(dataInicio, [-4, -3, -2, -1, 0, -6, -5], linhaDatas); break;
        case 6: preencherCeldas(dataInicio, [-5, -4, -3, -2, -1, 0, -6], linhaDatas); break;
      }
      break;
  }
  // --- FIM DA LÓGICA ORIGINAL ---
}




function preencherCeldas(dataInicio, ajustes, linhaDatas) {
    // 1. Configuração de dias permitidos
    let maxDiasPermitidos = 0;
    const diasConfig = window.DiasParaLimpar || 4; 

    switch (diasConfig) {
        case 1: maxDiasPermitidos = 5; break;
        case 2: maxDiasPermitidos = 4; break;
        case 3: maxDiasPermitidos = 3; break;
        case 4: maxDiasPermitidos = 2; break;
        case 5: maxDiasPermitidos = 1; break;
        case 6: maxDiasPermitidos = 0; break;
        default: maxDiasPermitidos = 2;
    }

    // Datas de controle
    const dataLimite = new Date();
    dataLimite.setHours(0, 0, 0, 0);
    dataLimite.setDate(dataLimite.getDate() + maxDiasPermitidos);

    const hojeZero = new Date();
    hojeZero.setHours(0, 0, 0, 0);

    // Pega a linha de cima (Dias da Semana)
    const linhaNomesDias = linhaDatas.previousElementSibling;

    // Loop pelas colunas
    for (let i = 0; i < ajustes.length; i++) {
        let novaData = new Date(dataInicio);
        novaData.setDate(dataInicio.getDate() + ajustes[i]);
        
        const dataCheck = new Date(novaData);
        dataCheck.setHours(0, 0, 0, 0);

        // Formata data: 14/01/2026
        const diaMes = String(novaData.getDate()).padStart(2, '0');
        const mes = String(novaData.getMonth() + 1).padStart(2, '0');
        const ano = novaData.getFullYear();
        
        // Escreve SOMENTE a data na célula de baixo (mantendo o original)
        linhaDatas.children[i].innerHTML = `${diaMes}/${mes}/${ano}`;
        
        // --- LÓGICA DE BLOQUEIO VISUAL ---
        if (dataCheck < hojeZero || dataCheck > dataLimite) {
            // Pinta a data (em baixo)
            linhaDatas.children[i].classList.add('dia-bloqueado-visual');
            linhaDatas.children[i].title = "Indisponível para agendamento";

            // Pinta o nome do dia (em cima)
            // CORREÇÃO: Usamos [i + 1] porque a linha de cima tem a coluna "Horários" no índice 0
            if (linhaNomesDias && linhaNomesDias.children[i + 1]) {
                linhaNomesDias.children[i + 1].classList.add('dia-bloqueado-visual');
                linhaNomesDias.children[i + 1].title = "Indisponível para agendamento";
            }

        } else {
            // Remove o cinza da data
            linhaDatas.children[i].classList.remove('dia-bloqueado-visual');
            linhaDatas.children[i].title = "";

            // Remove o cinza do nome do dia
            if (linhaNomesDias && linhaNomesDias.children[i + 1]) {
                linhaNomesDias.children[i + 1].classList.remove('dia-bloqueado-visual');
                linhaNomesDias.children[i + 1].title = "";
            }
        }
    }
}






// SUBSTITUA A SUA FUNÇÃO INTEIRA PELA VERSÃO FINAL ABAIXO
// SUBSTITUA A SUA FUNÇÃO INTEIRA PELA VERSÃO FINAL ABAIXO
async function LimparDiasAnteriores() {
    console.log("🟢 Iniciando LimparDiasAnteriores com Verificação de Data Real...");
    const reservasParaExcluir = [];
    const updates = {};
    let operacaoSucesso = true;

    try {
        const dataAtual = new Date();
        dataAtual.setHours(0, 0, 0, 0);
        const quadras = ["Quadra 1 - Coberta", "Quadra 2 - Aberta", "Quadra 3 - Coberta"];

        // 1. CARREGAMENTO EM LOTE
        const snapshots = await Promise.all(
            quadras.map(q => database.ref(`sistemas/reservas/${q}`).once('value'))
        );
        
        const dadosCompletos = {};
        quadras.forEach((q, i) => {
            dadosCompletos[q] = snapshots[i].val() || {};
        });

        for (const quadra of quadras) {
            const reservasDaQuadra = dadosCompletos[quadra];
            const chavesIgnoradas = new Set(); 

            // Varre do dia 0 (hoje) até o limite configurado
            for (let dia = 2; dia <= DiasParaLimpar; dia++) {
                const dataCalculadaLoop = new Date(dataAtual);
                dataCalculadaLoop.setDate(dataAtual.getDate() - dia);
                const diaIndex = dataCalculadaLoop.getDay() === 0 ? 7 : dataCalculadaLoop.getDay();

                for (let hora = 6; hora <= 22; hora++) {
                    const key = `${diaIndex}_${hora}`;
                    
                    if (chavesIgnoradas.has(key)) continue;

                    const reserva = reservasDaQuadra[key];

                    if (!reserva) continue;

                    // --- LÓGICA DE DATA REAL (A CORREÇÃO) ---
                    let dataRealDaReservaFormatada;
                    
                    if (reserva.dataCompleta) {
                        // Se a reserva tem data gravada, CONFIAMOS NELA.
                        // Formato esperado YYYY-MM-DD -> Convertendo para DD-MM-YYYY para o Log
                        const partesData = reserva.dataCompleta.split('-');
                        dataRealDaReservaFormatada = `${partesData[2]}-${partesData[1]}-${partesData[0]}`; 
                    } else {
                        // Fallback para reservas antigas: Assume que é do passado calculado pelo loop
                        dataRealDaReservaFormatada = dataCalculadaLoop.toLocaleDateString('pt-BR').replace(/\//g, '-');
                    }
                    // ----------------------------------------

                    // CASO 1: PENDÊNCIA DA PIRÂMIDE
                    if (reserva.status === 'resultado_pendente' && reserva.duracao === 3 && reserva.resultado) {
                        console.warn(`⏳ Auto-confirmando resultado pendente em ${quadra} (${key}).`);
                        chavesIgnoradas.add(`${diaIndex}_${hora + 1}`);

                        const novoStatus = 'finalizada'; 
                        let jogadoresArray;
                        if (reserva.jogadores_completo) {
                            jogadoresArray = reserva.jogadores_completo.split(',').map(j => j.trim());
                        } else {
                            const segundaReserva = reservasDaQuadra[`${diaIndex}_${hora + 1}`];
                            jogadoresArray = [reserva.jogadores, segundaReserva?.jogadores].filter(Boolean).map(j => j.trim());
                        }
                        
                        const horarioFormatado = `${hora.toString().padStart(2, '0')}:00 - ${(hora + 2).toString().padStart(2, '0')}:00`;
                        const jogadoresComPosicao = jogadoresArray.map(apelido => ({
                            apelido: apelido,
                            posicao: getDisplayRank(jogadoresData[apelido.trim()]?.piramide) || "0"
                        }));

                        let logData = {
                            exclusao: new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo', day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }).replace(',', ''),
                            quadra: quadra, 
                            data: dataRealDaReservaFormatada, // <--- USA A DATA CORRETA
                            horario: horarioFormatado, 
                            duracao: "2 Horas - Pirâmide",
                            jogadores: jogadoresComPosicao, 
                            usuario: "SISTEMA",
                            motivo: "Resultado confirmado e reserva limpa automaticamente por decurso de prazo.",
                            statusNoMomentoDaExclusao: novoStatus, 
                            organizadorDaReserva: reserva.organizador,
                            confirmacoes: traduzirConfirmacoesParaLog(reserva.confirmacoes), 
                            resultado: reserva.resultado
                        };
                        reservasParaExcluir.push(logData);

                        const rankUpdates = processarTrocaDeRanking(reserva); 
                        Object.assign(updates, rankUpdates);
                        
                        updates[`sistemas/reservas/${quadra}/${key}`] = null;
                        updates[`sistemas/reservas/${quadra}/${diaIndex}_${hora + 1}`] = null;
                    } 
                    
                    // CASO 2: LIMPEZA DE RESERVA NORMAL / AULA / MANUTENÇÃO
                    else if (reserva.borda) {
                        
                        let jogadoresArray;
                        if (reserva.jogadores_completo) {
                            jogadoresArray = reserva.jogadores_completo.split(',').map(j => j.trim());
                        } else {
                            let jogadoresCombinados = reserva.jogadores;
                            if (reserva.duracao > 1) {
                                const segundaReserva = reservasDaQuadra[`${diaIndex}_${hora + 1}`];
                                if (segundaReserva?.jogadores) {
                                    jogadoresCombinados += `, ${segundaReserva.jogadores}`;
                                }
                            }
                            jogadoresArray = [...new Set(jogadoresCombinados.split(',').map(j => j.trim()))];
                        }

                        const isManutencao = jogadoresArray.some(j => j.toLowerCase().includes('manutencao'));
                        const isAula = jogadoresArray.some(j => j.toLowerCase() === 'aula');
                        
                        let duracaoCalculada = 1;

                        if (isManutencao || isAula) {
                            for (let h = hora + 1; h <= 22; h++) {
                                const nextKey = `${diaIndex}_${h}`;
                                const nextR = reservasDaQuadra[nextKey];
                                if (!nextR) break;
                                const nextJogadores = (nextR.jogadores_completo || nextR.jogadores || "").toLowerCase();
                                const nextIsManut = nextJogadores.includes('manutencao');
                                const nextIsAula = nextJogadores === 'aula';
                                
                                if ((isManutencao && nextIsManut) || (isAula && nextIsAula)) {
                                    duracaoCalculada++;
                                    chavesIgnoradas.add(nextKey);
                                } else {
                                    break;
                                }
                            }
                        } else {
                            if (reserva.duracao === 2 || reserva.duracao === 3) duracaoCalculada = 2;
                            if (duracaoCalculada > 1) chavesIgnoradas.add(`${diaIndex}_${hora + 1}`);
                        }

                        const horarioFormatado = `${hora.toString().padStart(2, '0')}:00 - ${(hora + duracaoCalculada).toString().padStart(2, '0')}:00`;
                        
                        let duracaoTexto = `${duracaoCalculada} Hora${duracaoCalculada > 1 ? 's' : ''}`;
                        if (reserva.duracao === 3) duracaoTexto = "2 Horas - Pirâmide";
                        
                        let jogadoresComPosicao = jogadoresArray.map(apelido => ({
                            apelido: apelido,
                            posicao: getDisplayRank(jogadoresData[apelido.trim()]?.piramide) || "0"
                        }));

                        let motivoLog = "Limpeza automática de reserva antiga";
                        
                        if (isAula) {
                            const professor = reserva.organizador || "Ronaldo";
                            jogadoresComPosicao = [{ apelido: "Aula Extra - Prof. " + professor, posicao: "0" }];
                            motivoLog = "Aula Extra finalizada e limpa automaticamente pelo sistema";
                        }

                        if (isManutencao) {
                            const responsavel = reserva.organizador || "Erick";
                            jogadoresComPosicao = [{ apelido: "Manutençao - Resp. " + responsavel, posicao: "0" }];
                            motivoLog = "Manutenção excluida automaticamente pelo Sistema";
                        }

                        let logData = {
                            exclusao: new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo', day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }).replace(',', ''),
                            quadra: quadra, 
                            data: dataRealDaReservaFormatada, // <--- USA A DATA CORRETA
                            horario: horarioFormatado, 
                            duracao: duracaoTexto,
                            jogadores: jogadoresComPosicao, 
                            usuario: "SISTEMA", 
                            motivo: motivoLog 
                        };
                        
                        if (!isManutencao && !isAula) {
                            if (reserva.organizador) {
                                logData.organizadorDaReserva = reserva.organizador;
                            } else if (jogadoresArray.length > 0) {
                                logData.organizadorDaReserva = jogadoresArray[0];
                            }

                            if (reserva.confirmacoes) {
                                logData.confirmacoes = traduzirConfirmacoesParaLog(reserva.confirmacoes);
                            }
                            
                            if (reserva.status) {
                                logData.statusNoMomentoDaExclusao = reserva.status;
                            }
                        }
                        
                        if (reserva.resultado) logData.resultado = reserva.resultado;
                        if (reserva.resultadoDuplas) logData.resultadoDuplas = reserva.resultadoDuplas;
                        
                        reservasParaExcluir.push(logData);

                        for (let i = 0; i < duracaoCalculada; i++) {
                            const hAtual = hora + i;
                            updates[`sistemas/reservas/${quadra}/${diaIndex}_${hAtual}`] = null;
                        }
                    }
                    
                    // CASO 3: LIMPEZA DE EXCEÇÃO DE AULA FIXA
                    else if (reserva.status === 'aula_cancelada') {
                        console.log(`🧹 Removendo exceção de aula antiga em ${quadra} (${key}).`);
                        updates[`sistemas/reservas/${quadra}/${key}`] = null;
                    }
                }
            }
        }

        if (Object.keys(updates).length > 0) {
            await database.ref().update(updates);
        }
        
        if (reservasParaExcluir.length > 0) {
            await registrarExclusao(reservasParaExcluir);
        } else if (Object.keys(updates).length === 0) {
            console.log("ℹ️ Nenhuma reserva antiga para remover ou confirmar.");
        }

    } catch (erro) {
        console.error(`⚠️ ERRO na função LimparDiasAnteriores: ${erro.message}`);
        operacaoSucesso = false;
    } finally {
        console.log(operacaoSucesso ? "✅ Operação de limpeza concluída" : "⚠️ Operação de limpeza concluída com erros");
    }
}




// As variáveis globais permanecem as mesmas
let jogadoresData = {};
let jogadoresListener = null;


// Função principal que gerencia o carregamento (Cache + Tempo Real)
function carregarJogadores() {
    return new Promise((resolve, reject) => {
        const jogadoresRef = database.ref("sistemas/cadastro/jogadores");
        let primeiraExecucao = true;

        // 1. TENTATIVA RÁPIDA: Cache Local
        const cacheLocal = localStorage.getItem('jogadoresDataCache');
        if (cacheLocal) {
            try {
                console.log("⚡ [Cache] Carregando jogadores da memória local...");
                const dadosCache = JSON.parse(cacheLocal);
                // Preenche a tela imediatamente com o que tem no cache
                processarEPreencherJogadores(dadosCache);
                // Libera o sistema para abrir, não esperamos o Firebase!
                resolve();
                primeiraExecucao = false; // Marca que já resolvemos a promessa
            } catch (e) {
                console.warn("⚠️ Cache local inválido, aguardando Firebase.");
            }
        }

        // 2. CONEXÃO TEMPO REAL: Mantém o sistema atualizado
        // Usamos .on() para garantir que adições/edições futuras reflitam na hora.
        if (jogadoresListener) {
             jogadoresRef.off('value', jogadoresListener);
        }

        jogadoresListener = jogadoresRef.on('value', (snapshot) => {
            const todosJogadores = snapshot.val() || {};

            // Verifica se os dados novos são diferentes do que já temos na tela
            // para evitar redesenhar tudo sem necessidade.
            const cacheAtual = localStorage.getItem('jogadoresDataCache');
            const dadosMudaram = JSON.stringify(todosJogadores) !== cacheAtual;

            if (dadosMudaram) {
                console.log("♻️ [Firebase] Novos dados de jogadores recebidos. Atualizando...");
                // Atualiza o cache para a próxima vez
                localStorage.setItem('jogadoresDataCache', JSON.stringify(todosJogadores));
                // Atualiza a tela em tempo real
                processarEPreencherJogadores(todosJogadores);
            } else {
                 console.log("✅ [Firebase] Dados já estão atualizados.");
            }

            // Se não tinha cache, esta é a primeira vez que carregamos, então liberamos o sistema agora.
            if (primeiraExecucao) {
                resolve();
                primeiraExecucao = false;
            }
        }, (error) => {
            console.error("Erro no listener de jogadores:", error);
            if (primeiraExecucao) reject(error);
        });
    });
}

// Função auxiliar que faz o trabalho pesado de atualizar a interface
// Ela é chamada tanto pelo Cache (rápido) quanto pelo Firebase (atualização)
function processarEPreencherJogadores(todosJogadores) {
    const duracaoSelect = document.getElementById('duracao');
    const jogadorLogadoNome = localStorage.getItem('jogadorLogado');

    // 1. Atualiza a memória interna global
    jogadoresData = {};
    Object.keys(todosJogadores).forEach((nome) => {
        const jogador = todosJogadores[nome];
        jogadoresData[jogador.apelido] = {
			nomeCompleto: nome,
			piramide: jogador.piramide || "0",
			niver: jogador.niver || "",
			perfis: jogador.perfis || {},
            socio: jogador.socio || ""
		};
    });

    // 2. Prepara a lista filtrada (lógica da Pirâmide)
    // ... (MANTENHA AQUI A MESMA LÓGICA DE FILTRO QUE VOCÊ JÁ TINHA) ...
    // Copiei sua lógica original para garantir que nada mude no comportamento.
    let jogadoresParaExibir = { ...todosJogadores };
    const duracao = duracaoSelect ? duracaoSelect.value : "";

    if (duracao === "3-piramide") {
        const jogadorLogadoApelido = Object.keys(jogadoresData).find(apelido => jogadoresData[apelido].nomeCompleto === jogadorLogadoNome);
        const jogadorLogadoInfo = jogadorLogadoApelido ? jogadoresData[jogadorLogadoApelido] : null;

        if (!jogadorLogadoInfo || !jogadorLogadoInfo.piramide || jogadorLogadoInfo.piramide === "0") {
            // Evita mostrar notificação repetida se for apenas uma atualização de fundo
            // mostrarNotificacao("Você não participa da Pirâmide...", 'error');
            jogadoresParaExibir = {};
        } else {
            const posLogado = parseInt(jogadorLogadoInfo.piramide, 10);
            let oponentesValidos = {};
            if (posLogado >= 61) {
                Object.keys(todosJogadores).forEach(nome => {
                   if (parseInt(todosJogadores[nome].piramide, 10) >= 61) oponentesValidos[nome] = todosJogadores[nome];
                });
            } else {
                 // ... (sua lógica de desafio da pirâmide masculina) ...
                 const nomeCompletoLogado = jogadoresData[jogadorLogadoApelido].nomeCompleto;
                 Object.keys(todosJogadores).forEach(nomeOponente => {
                    const oponente = todosJogadores[nomeOponente];
                    const posOponente = parseInt(oponente.piramide, 10);
                    if (!posOponente || posOponente > 60 || posOponente === posLogado) return;
                    const limiteLogado = encontrarLinha(posLogado);
                    const euPossoDesafiar = (posLogado - limiteLogado) <= posOponente && posOponente < posLogado;
                    const limiteOponente = encontrarLinha(posOponente);
                    const oponentePodeMeDesafiar = (posOponente - limiteOponente) <= posLogado && posLogado < posOponente;
                    if (euPossoDesafiar || oponentePodeMeDesafiar) oponentesValidos[nomeOponente] = oponente;
                });
                if (todosJogadores[nomeCompletoLogado]) oponentesValidos[nomeCompletoLogado] = todosJogadores[nomeCompletoLogado];
            }
            jogadoresParaExibir = oponentesValidos;
        }
    }

    // 3. Atualiza visualmente todos os dropdowns na tela
    const selectsParaPreencher = [];
    document.querySelectorAll('select[id^="jogador"]').forEach(select => selectsParaPreencher.push(select));
    if (!jogadorLogadoNome && document.getElementById("jogadorSelect")) {
        selectsParaPreencher.push(document.getElementById("jogadorSelect"));
    }

    selectsParaPreencher.forEach(select => {
        const valorJaSelecionado = select.value;
        // Limpa e recria as opções
        select.innerHTML = '<option value="">Selecione um jogador</option>';
        Object.keys(jogadoresParaExibir).forEach((nome) => {
            const jogador = jogadoresParaExibir[nome];
            const option = document.createElement('option');
            option.value = jogador.apelido;
            option.textContent = nome;
            select.appendChild(option);
        });
        
        // Tenta manter a seleção anterior se ela ainda for válida
        if (valorJaSelecionado && select.querySelector(`option[value='${valorJaSelecionado}']`)) {
            select.value = valorJaSelecionado;
        }
        
        // >>> COLE ESTE BLOCO NOVO AQUI EMBAIXO: <<<
        // Se for o dropdown de Login e estiver vazio, tenta pegar o último usado
        else if (select.id === 'jogadorSelect') {
            const ultimoUser = localStorage.getItem('ultimoUsuarioLogado');
            if (ultimoUser) {
                // O localStorage guarda o Nome Completo, mas o select usa o Apelido (Key).
                // Vamos encontrar qual apelido pertence a esse Nome Completo.
                const apelidoEncontrado = Object.keys(jogadoresData).find(
                    key => jogadoresData[key].nomeCompleto === ultimoUser
                );
                
                if (apelidoEncontrado) {
                    select.value = apelidoEncontrado;
                }
            }
        }
        // ------------------------------------------
    });
}


// Variáveis para guardar os "vigias" das quadras (para poder desligar se precisar)
let monitoresQuadras = {};

/**
 * Inicia o monitoramento de todas as quadras para detectar jogos AO VIVO.
 * Atualiza visualmente as abas (botões) correspondentes.
 */
function iniciarMonitoramentoJogosAoVivo() {
    const quadras = ["Quadra 1 - Coberta", "Quadra 2 - Aberta", "Quadra 3 - Coberta"];

    quadras.forEach(quadra => {
        if (monitoresQuadras[quadra]) {
            database.ref(`sistemas/reservas/${quadra}`).off('value', monitoresQuadras[quadra]);
        }

        const monitorCallback = (snapshot) => {
            const reservas = snapshot.val() || {};
            // Verifica se ALGUMA reserva nesta quadra está 'em_andamento'
            // Adicionei 'r &&' para segurança contra dados nulos
            const temJogoAoVivo = Object.values(reservas).some(r => r && r.status === 'em_andamento');

            if (temJogoAoVivo) {
                 // ESTE É O LOG "DEDO-DURO"
                 console.log(`🔴 [Monitor] Jogo AO VIVO detectado na ${quadra}! Acendendo luz.`);
            }

            atualizarIndicadorAba(quadra, temJogoAoVivo);
        };

        database.ref(`sistemas/reservas/${quadra}`).on('value', monitorCallback);
        monitoresQuadras[quadra] = monitorCallback;
    });
}

/**
 * Liga ou desliga a classe .live-game no botão da quadra específica.
 */
function atualizarIndicadorAba(nomeQuadra, isLive) {
    const botoes = document.querySelectorAll('.tab-button');
    botoes.forEach(botao => {
        // Compara com o nome original da quadra (para funcionar mesmo se o texto do botão mudou no celular)
        if (botao.getAttribute('data-nome-original') === nomeQuadra) {
            if (isLive) {
                botao.classList.add('live-game');
            } else {
                botao.classList.remove('live-game');
            }
        }
    });
}

window.onload = function () {
    // INÍCIO DO CRONÔMETRO GERAL
    console.time("⏱️ Tempo Total de Inicialização");

    console.log("✅ Página carregada - Chamando verificarVersao()");
    verificarVersao();
    // [REMOVIDO DAQUI] removerSessoesAntigas();
    let jogadorLogado = localStorage.getItem('jogadorLogado');
    let loginScreen = document.getElementById('loginScreen');
    let contentElement = document.getElementById('content');
    let loadingElement = document.getElementById('loading');

    // Esconde as telas principais por padrão para evitar "piscar" na tela
    loginScreen.style.display = 'none';
    contentElement.style.display = 'none';

    console.log("🔄 Chamando carregarJogadores()");
    // INÍCIO CRONÔMETRO JOGADORES
    console.time("📦 Jogadores");

    carregarJogadores(jogadorLogado).then(() => {
        //console.timeEnd("📦 Jogadores");
        console.log("✅ Jogadores carregados!");

        // INÍCIO CRONÔMETRO SISTEMA
        console.time("⚙️ Sistema");

        InicializarSistema().then(() => {
            console.timeEnd("⚙️ Sistema");
            console.log("✅ Sistema inicializado!");

            limparReservasExpiradas(); // limpa as reservas nao confirmadas.

            // Esconde a tela de carregamento
            if (loadingElement) loadingElement.style.display = 'none';

            if (jogadorLogado) {
                // Se o usuário está logado, mostra o conteúdo principal
                contentElement.style.display = 'block';
                // E checa se é seu aniversário
                checarAniversario();
            } else {
                // Se o usuário não está logado, mostra a tela de login
                document.getElementById('pageOverlay').style.display = 'block';
                loginScreen.style.display = 'block';
            }

            // FIM DO CRONÔMETRO GERAL (Tela liberada)
            console.timeEnd("⏱️ Tempo Total de Inicialização");
			
			// [NOVO] Agonda a faxina para 5 segundos depois que a tela já abriu.
            // Isso tira peso da inicialização sem perder a funcionalidade.
            setTimeout(() => {
                console.log("🧹 Executando faxina de sessões antigas em segundo plano...");
                removerSessoesAntigas();
            }, 5000);
			
			// [NOVO] Inicia o monitoramento das abas AO VIVO
            // Espera 1.5s para não atrapalhar a abertura imediata da tela
            setTimeout(() => {
                 console.log("🔴 [Background] Iniciando monitoramento de jogos AO VIVO nas abas...");
                 iniciarMonitoramentoJogosAoVivo();
            }, 1500);


            // Lógica de sessão online (continua a mesma)
            if (jogadorLogado) {
                const sessionId = localStorage.getItem("sessionId") || Math.random().toString(36).substr(2, 9);
                localStorage.setItem("sessionId", sessionId);
                const userStatusRef = database.ref(`sistemas/usuariosOnline/${sessionId}`);
                userStatusRef.set({
                    sessionId: sessionId,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    usuario: jogadorLogado
                });
                userStatusRef.onDisconnect().remove();
            } else {
                const sessionId = localStorage.getItem("sessionId") || Math.random().toString(36).substr(2, 9);
                localStorage.setItem("sessionId", sessionId);
                const userStatusRef = database.ref(`sistemas/usuariosOnline/${sessionId}`);
                userStatusRef.set({
                    sessionId: sessionId,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    usuario: 'primeiro acesso'
                });
                userStatusRef.onDisconnect().remove();
            }

        }).catch(error => {
            console.error("❌ Erro ao inicializar o sistema:", error);
            if (loadingElement) loadingElement.style.display = 'none'; // Esconde o loading também em caso de erro
            console.timeEnd("⏱️ Tempo Total de Inicialização"); // Para o cronômetro em caso de erro também
        });
    }).catch(error => {
        console.error("❌ Erro ao carregar jogadores:", error);
        if (loadingElement) loadingElement.style.display = 'none'; // Esconde o loading também em caso de erro
    });
};





document.addEventListener('DOMContentLoaded', () => {
//alert('entrei no addEventListener');
    const tabelaContainer = document.querySelector('.tabela-container');
    const horariosColuna = document.querySelectorAll('#tabelaCorpo td:first-child, #tabelaCorpo td:last-child');
    let isExpanded = false;

    // Ajusta os horários em telas pequenas
    const ajustarHorariosCelular = () => {
        const larguraTela = window.innerWidth;

        if (larguraTela <= 600) { // Verifica se a tela é pequena
            horariosColuna.forEach(celula => {
                if (celula.textContent.includes(' - ')) {
                    const horarios = celula.textContent.split(' - ');
                    celula.innerHTML = `${horarios[0]}<br>${horarios[1]}`; // Quebra os horários em linhas
                }
            });
        }
    };

    // Chamada inicial ao carregar a página
    ajustarHorariosCelular();

// Listener para alterar layout ao clicar duas vezes
// ==========================================================
    // --- FUNÇÃO DE DUPLO CLIQUE (FINAL: COM CALÇO DE ROLAGEM) ---
    // ==========================================================
// ==========================================================
    // --- FUNÇÃO DE DUPLO CLIQUE (VERSÃO FINAL: CORREÇÃO DE ROLAGEM) ---
    // ==========================================================
    tabelaContainer.addEventListener('dblclick', (event) => {
        const target = event.target;
        // Verifica clique válido
        if (!((target.tagName === 'TH' || target.tagName === 'TD') && target.innerText.includes('Horários'))) {
            return;
        }

        tabelaContainer.classList.toggle('fullscreen');
        
        const header = document.getElementById('app-header'); 
        const tabContainer = document.querySelector('.tab-container'); 

        if (tabelaContainer.classList.contains('fullscreen')) {
            // --- MODO TELA CHEIA (ATIVADO) ---
            
            // 1. Esconde a barra do topo
            if (header) header.style.display = 'none'; 

            // 2. Botões colados no teto
            if (tabContainer) {
                tabContainer.style.top = '0px'; 
                tabContainer.style.zIndex = '9001'; 
            }

            // 3. Tabela com altura DINÂMICA (dvh)
            tabelaContainer.style.top = '60px';
            
            // Tenta usar 'dvh' (Dynamic Viewport Height) para celulares modernos
            // Se o navegador for antigo, o CSS fallback (se houver) ou o cálculo padrão assume.
            // O 'calc' garante que a tabela ocupe o espaço restante.
            tabelaContainer.style.height = 'calc(100dvh - 60px)'; 
            
            // Fallback para navegadores que não entendem dvh (usa vh normal)
            if (!CSS.supports('height: 100dvh')) {
                 tabelaContainer.style.height = 'calc(100vh - 60px)';
            }

            // 4. O "SUPER CALÇO": Aumentamos para 300px
            // Isso garante que 22h, 23h e Rodapé passem longe da barra do navegador
            tabelaContainer.style.paddingBottom = '300px'; 
            
            // 5. Força a rolagem a funcionar
            tabelaContainer.style.overflowY = 'scroll'; 
            tabelaContainer.style.webkitOverflowScrolling = 'touch'; // Fluidez no iPhone

        } else {
            // --- MODO NORMAL (RESTAURADO) ---
            
            if (header) header.style.display = 'flex'; 

            if (tabContainer) {
                tabContainer.style.top = '50px'; 
                tabContainer.style.zIndex = ''; 
            }

            tabelaContainer.style.top = '105px';
            tabelaContainer.style.height = 'calc(100vh - 105px)';
            
            // Remove o calço e configurações extras
            tabelaContainer.style.paddingBottom = '0px';
            tabelaContainer.style.overflowY = ''; 
        }
    });
	
	
	const header = document.querySelector('.header'); // Seleciona o título da quadra
    let tapCount = 0; // Contador de toques
    let lastTapTime = 0; // Tempo do último toque

    header.addEventListener('click', () => {
        const currentTime = new Date().getTime();
        const tapInterval = 300; // Intervalo máximo entre toques (em milissegundos)

        // Verifica se o tempo entre os toques é menor que o intervalo definido
        if (currentTime - lastTapTime < tapInterval) {
            tapCount++;
        } else {
            tapCount = 1; // Reseta o contador se o intervalo for maior
        }

        lastTapTime = currentTime;

        // Se o usuário tocar 3 vezes no título
        if (tapCount === 3) {
            tapCount = 0; // Reseta o contador
            confirmarLogout(); // Chama a função de confirmação de logout
        }
    });

    // Nova funcionalidade: Ajusta os nomes dos botões para celular
    const ajustarNomesBotoes = () => {
        const larguraTela = window.innerWidth;
        const botoes = document.querySelectorAll('.tab-button');

        botoes.forEach(botao => {
            const nomeOriginal = botao.getAttribute('data-nome-original'); // Recupera o nome original
            if (!nomeOriginal) {
                botao.setAttribute('data-nome-original', botao.innerHTML); // Armazena o nome original uma única vez
            }

            if (larguraTela <= 600) {
                // Ajuste para celular: quebra o texto em duas linhas
                const partesNome = botao.getAttribute('data-nome-original').split(' - ');
                if (partesNome.length === 2) {
                    botao.innerHTML = `${partesNome[0]}<br>${partesNome[1]}`;
                }
            } else {
                // Ajuste para computador: restaura o nome original
                botao.innerHTML = botao.getAttribute('data-nome-original');
            }
        });
    };

    // Ajuste inicial e ao redimensionar a tela
    ajustarNomesBotoes();
    window.addEventListener('resize', ajustarNomesBotoes);
	
	window.addEventListener('resize', atualizarNomesPlacarAoVivo);
    window.addEventListener('orientationchange', atualizarNomesPlacarAoVivo);
	
});





function fazerLogin() {
    if (navigator.vibrate) { navigator.vibrate(50); }
    
    let jogadorSelect = document.getElementById('jogadorSelect');
    let jogadorSelecionado = jogadorSelect.value; // Apelido selecionado
    let senhaInput = document.getElementById("acesso_user");
    let senhaDigitada = senhaInput.value;
    let loginScreen = document.getElementById('loginScreen');
    let contentElement = document.getElementById('content');

    if (!jogadorSelecionado || !senhaDigitada) {
        mostrarNotificacao("Por favor, selecione um jogador e digite a senha.", 'error');
        return;
    }

    // Busca o nome completo e os perfis do jogador
    const jogadoresRef = database.ref("sistemas/cadastro/jogadores");
    jogadoresRef.once('value', (snapshot) => {
        const jogadores = snapshot.val();
        let nomeCompleto = '';
        let dataNascimento = '';
        let perfisFormatados = '';

        // Encontra o jogador pelo apelido
        Object.keys(jogadores).forEach((nome) => {
            if (jogadores[nome].apelido === jogadorSelecionado) {
                nomeCompleto = nome;
                dataNascimento = jogadores[nome].niver ? jogadores[nome].niver.replace(/\//g, "") : "";
                
                // --- NOVO: Coleta os perfis ativos ---
                const perfisDoJogador = jogadores[nome].perfis || {};
                const listaPerfis = Object.keys(perfisDoJogador).filter(p => perfisDoJogador[p] === true);
                
                if (listaPerfis.length > 0) {
                    perfisFormatados = `<br><span style="font-size: 0.9em; color: #666;">(${listaPerfis.join(', ')})</span>`;
                } else {
                    perfisFormatados = `<br><span style="font-size: 0.9em; color: #999;">(Sócio)</span>`;
                }
            }
        });

        if (!nomeCompleto) {
            mostrarNotificacao("Jogador não encontrado.", 'error');
            return;
        }

        // Verifica a senha
        if (senhaDigitada !== dataNascimento) {
            const mensagem = "<b>🔒 Senha inválida!</b><br>Tente novamente ou entre em contato com o administrador.<br>Ronaldo Taborda.";
            mostrarNotificacao(mensagem, 'error');
            senhaInput.value = "";
            return;
        }

        // --- INÍCIO DA ALTERAÇÃO ---
        // Adicionamos a variável 'perfisFormatados' na mensagem
        const mensagem = `Você selecionou o jogador:<br><b>${nomeCompleto}</b>${perfisFormatados}<br><br>Deseja continuar?`;

        const acaoAoConfirmar = () => {
            localStorage.setItem('jogadorLogado', nomeCompleto);
            
            // >>> ADICIONE ESTA LINHA AQUI: <<<
            localStorage.setItem('ultimoUsuarioLogado', nomeCompleto); 
            // ---------------------------------

            document.getElementById('pageOverlay').style.display = 'none';
            loginScreen.style.display = 'none';
            contentElement.style.display = 'block';
            
            atualizarCabecalhoUsuario(); 
            
            atualizarPrimeiroAcesso(nomeCompleto); 
            checarAniversario();
        };
		
		

        // Chama o modal de confirmação (VERDE)
        mostrarConfirmacao(mensagem, acaoAoConfirmar, null, 'success');

        jogadorSelect.value = '';
        senhaInput.value = '';
        // --- FIM DA ALTERAÇÃO ---
    
    }).catch(error => {
        console.error("Erro ao acessar o banco de dados:", error);
        mostrarNotificacao("Erro ao acessar o banco de dados. Tente novamente mais tarde.", 'error');
    });
}



function confirmarLogout() {
    const jogadorLogado = localStorage.getItem('jogadorLogado');
    let perfisFormatados = '';

    // 1. Busca os dados do jogador na memória para pegar os perfis
    if (jogadorLogado && typeof jogadoresData !== 'undefined') {
        const dadosLogado = Object.values(jogadoresData).find(j => j.nomeCompleto === jogadorLogado);
        
        if (dadosLogado && dadosLogado.perfis) {
            // Filtra apenas os perfis ativos (true)
            const ativos = Object.keys(dadosLogado.perfis).filter(k => dadosLogado.perfis[k] === true);
            
            if (ativos.length > 0) {
                perfisFormatados = `<br><span style="font-size: 0.9em; color: #666;">(${ativos.join(', ')})</span>`;
            } else {
                perfisFormatados = `<br><span style="font-size: 0.9em; color: #999;">(Sócio)</span>`;
            }
        } else {
            perfisFormatados = `<br><span style="font-size: 0.9em; color: #999;">(Sócio)</span>`;
        }
    }

    // 2. Prepara a mensagem com os perfis incluídos
    const mensagem = `Você está logado como:<br><b>${jogadorLogado}</b>${perfisFormatados}<br><br>Deseja realmente sair do sistema?`;
    
    const acaoLogout = () => {
        fazerLogout(); 
    };

    // 3. Chama o modal de confirmação (Azul Primário)
    mostrarConfirmacao(mensagem, acaoLogout, null, 'primary'); 
}


function fazerLogout() {
    localStorage.removeItem('jogadorLogado'); // Remove o jogador logado do localStorage
    window.location.reload(); // Recarrega a página para voltar à tela de login
	window.scrollTo(0, 0); 
}


// 🚀 Atualiza a lista de jogadores quando a duração for alterada
document.addEventListener("DOMContentLoaded", function () {
    const duracaoSelect = document.getElementById('duracao');

    if (duracaoSelect) {
        duracaoSelect.addEventListener('change', function() {
            
            // --- INÍCIO DA VALIDAÇÃO DE PERMISSÃO PIRÂMIDE ---
            if (this.value === '3-piramide') {
                const jogadorLogadoNome = localStorage.getItem('jogadorLogado');
                let participa = false;
                
                if (jogadorLogadoNome && jogadoresData) {
                    // Busca o apelido/chave do jogador logado
                    const apelidoLogado = Object.keys(jogadoresData).find(
                        apelido => jogadoresData[apelido].nomeCompleto === jogadorLogadoNome
                    );
                    
                    if (apelidoLogado) {
                        const info = jogadoresData[apelidoLogado];
                        // Verifica se tem ranking válido (existe e não é "0")
                        if (info && info.piramide && info.piramide !== "0") {
                            participa = true;
                        }
                    }
                }

                if (!participa) {
                    mostrarNotificacao("Atenção: Você não está inscrito no torneio da Pirâmide.", 'error');
                }
            }
            // --- FIM DA VALIDAÇÃO ---

            carregarJogadores(); // Recarrega os jogadores ao mudar a duração
        });
    } else {
        console.warn("⚠️ Elemento #duracao não encontrado. O evento de mudança não foi adicionado.");
    }

    // Adicionando verificação para "Rildo Santos"
    const jogador1Select = document.getElementById("jogador1");

    if (jogador1Select) {
		let valorAntesDaMudanca = jogador1Select.value;

		// Passo 1: Guarda o valor atual toda vez que o menu é aberto
		jogador1Select.addEventListener('mousedown', function() {
			valorAntesDaMudanca = this.value;
		});

		// Passo 2: Lida com a lógica de mudança de forma inteligente
		jogador1Select.addEventListener('change', function() {
			const rildoSelecionado = this.value === "Rildo";
			const aulaOption = this.querySelector("option[value='aula']");

			if (rildoSelecionado) {
				// Passo 3: Reverte a seleção visual temporariamente.
				// Isso força o navegador a sempre ver uma "mudança" no próximo passo.
				this.value = valorAntesDaMudanca;

				// Define as ações para os botões do modal
				const selecionarOpcaoAula = () => {
					const currentAulaOption = this.querySelector("option[value='aula']");
					if (!currentAulaOption) {
						const novaAulaOption = document.createElement("option");
						novaAulaOption.value = "aula";
						novaAulaOption.textContent = "Aula";
						this.appendChild(novaAulaOption);
					}
					this.value = 'aula'; // Define o valor final como 'aula'
				};

				const selecionarOpcaoJogo = () => {
					const currentAulaOption = this.querySelector("option[value='aula']");
					if (currentAulaOption) currentAulaOption.remove();
					this.value = 'Rildo'; // Define o valor final como 'Rildo'
				};

				// Passo 4: Chama o modal customizado
				mostrarConfirmacaoCustomizada(
					"A reserva do professor Rildo é para uma Aula ou um Jogo?",
					selecionarOpcaoAula,
					selecionarOpcaoJogo,
					'Aula',
					'Jogo'
				);

			} else {
				// Se outro jogador for selecionado, apenas remove a opção "Aula"
				if (aulaOption) aulaOption.remove();
			}
		});
	} else {
		console.warn("⚠️ Elemento #jogador1 não encontrado. O evento de mudança não foi adicionado.");
	}
});


// Função simplificada de log
// Substitua sua função inteira por esta
async function registrarExclusao(logData) {
  // 1. Compatibilidade com o processamento em lote (preservada)
  if (Array.isArray(logData)) {
    return registrarExclusaoEmLote(logData);
  }

  const token = githubToken;
  const usuarioGit = 'clube-olimpico';
  const repo = 'Reservas';
  const caminhoArquivo = 'logs/reservas-excluidas.json';
  const url = `https://api.github.com/repos/${usuarioGit}/${repo}/contents/${caminhoArquivo}`;

  try {
    let response = await fetch(url, {
      headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
    });

    if (!response.ok) throw new Error(`Erro ao buscar arquivo: ${response.status}`);
    
    let fileData = await response.json();
    let logs = [];
    if (fileData.content) {
      try {
        //logs = JSON.parse(atob(fileData.content.replace(/\s/g, ''))) || [];
		//logs = JSON.parse(atob(fileData.content)) || [];
		logs = JSON.parse(b64_to_utf8(fileData.content)) || [];
      } catch (e) { console.warn('Falha ao decodificar logs existentes, iniciando novo', e); }
    }

    // --- INÍCIO DA CORREÇÃO ---
    // Cria o novo registro de log com a data de exclusão e o resto dos dados
    const novoLog = {
      exclusao: new Date().toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }).replace(',', ''),
      ...logData // Adiciona todos os dados do objeto que recebemos (quadra, horario, jogadores, status, etc.)
    };
    
    // Converte a duração para o formato de texto, se necessário
    if (typeof novoLog.duracao === 'number') {
        novoLog.duracao = novoLog.duracao === 3 ? "2 Horas - Pirâmide" : novoLog.duracao === 2 ? "2 Horas" : "1 Hora";
    }

    logs.push(novoLog);
    // --- FIM DA CORREÇÃO ---

    response = await fetch(url, {
      method: 'PUT',
      headers: { 'Authorization': `token ${token}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: `Exclusão registrada: ${logData.quadra} - ${logData.data} ${logData.horario}`,
        content: utf8_to_b64(JSON.stringify(logs, null, 2)),
        sha: fileData.sha
      })
    });

    if (!response.ok) throw new Error(`Falha no upload: ${response.status}`);
    console.log('✅ Log registrado com sucesso');

  } catch (erro) {
    // Lógica de fallback para localStorage (preservada)
    console.error('❌ Erro ao salvar log:', erro);
    const logsFallback = JSON.parse(localStorage.getItem('logs_fallback') || '[]');
    const novoLogFallback = {
        exclusao: new Date().toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }).replace(',', ''),
        ...logData
    };
    logsFallback.push(novoLogFallback);
    localStorage.setItem('logs_fallback', JSON.stringify(logsFallback));
  }
}


// Função adicional (NOVA) - não substitui nada, apenas complementa
async function registrarExclusaoEmLote(logs) {
  const token = githubToken;
  const usuarioGit = 'clube-olimpico';
  const repo = 'Reservas';
  const caminhoArquivo = 'logs/reservas-excluidas.json';
  const url = `https://api.github.com/repos/${usuarioGit}/${repo}/contents/${caminhoArquivo}`; 

  try {
    // Obter versão atual do arquivo
    let response = await fetch(url, {
      headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
    });
    
    if (!response.ok) throw new Error(`Erro ao buscar arquivo: ${response.status}`);
    
    const fileData = await response.json();
    let logsExistentes = [];
    if (fileData.content) {
      try {
        //logsExistentes = JSON.parse(atob(fileData.content)) || [];
		logsExistentes = JSON.parse(b64_to_utf8(fileData.content)) || [];
      } catch (e) {
        console.warn('Falha ao decodificar logs existentes', e);
      }
    }

    // Combinar com os novos logs
    const todosLogs = [...logsExistentes, ...logs];

    // Enviar atualização
    response = await fetch(url, {
      method: 'PUT',
      headers: { 'Authorization': `token ${token}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: `Exclusões em lote: ${logs.length} reservas`,
        content: utf8_to_b64(JSON.stringify(todosLogs, null, 2)),
        sha: fileData.sha
      })
    });

    if (!response.ok) throw new Error(`Falha no upload: ${response.status}`);
    console.log(`✅ ${logs.length} logs registrados em lote`);
  } catch (erro) {
    console.error('❌ Erro ao salvar logs em lote:', erro);
    // Fallback para localStorage
    const logsFallback = JSON.parse(localStorage.getItem('logs_fallback') || '[]');
    logs.forEach(log => logsFallback.push(log));
    localStorage.setItem('logs_fallback', JSON.stringify(logsFallback));
  }
}

// Função para atualizar o valor "primeiro acesso"
function atualizarPrimeiroAcesso(jogadorLogado) {
    const sessionId = localStorage.getItem("sessionId");
    if (sessionId) {
        const userStatusRef = database.ref(`sistemas/usuariosOnline/${sessionId}`);
        // Atualiza o valor do usuário para o nome do jogador
        userStatusRef.update({ usuario: jogadorLogado })
            .then(() => console.log("✅ Valor de 'primeiro acesso' atualizado para:", jogadorLogado))
            .catch(error => console.error("❌ Erro ao atualizar 'primeiro acesso':", error));
    } else {
        console.error("❌ SessionId não encontrado. Não foi possível atualizar 'primeiro acesso'.");
    }
}

// Substitua a sua função pela versão original e funcional
async function validarRegraDeDuplas(jogadores, quadraSelecionada, dia, hora, duracao) {
    console.clear();
    console.log("--- INICIANDO VALIDAÇÃO DE DUPLAS ---");
    console.log(`Dados recebidos: Quadra=${quadraSelecionada}, DiaSemana=${dia}, HoraInício=${hora}, Duração=${duracao}h`);

    const duplasConfig = duplasConfigGlobais;

    if (!duplasConfig || !duplasConfig.ativa) {
        return true; // Regra global desativada
    }
    if (jogadores.some(j => j.toLowerCase() === 'aula')) {
        return true; // Regra não se aplica a aulas
    }

    const quadraKey = `Quadra-${quadraSelecionada.split(' ')[1]}`;
    const configDaQuadra = duplasConfig[quadraKey];

    if (!configDaQuadra || !configDaQuadra[`${quadraKey}-ativa`]) {
        return true; // Regra desativada para esta quadra
    }

    // Lógica de data para flexibilização
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0); 
    const diaDaSemanaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay();
    let diff = dia - diaDaSemanaHoje;
    if (diff < 0) {
        diff += 7;
    }
    const dataDaReserva = new Date(hoje);
    dataDaReserva.setDate(hoje.getDate() + diff);
    const dataFormatadaParaChave = `${dataDaReserva.getFullYear()}-${String(dataDaReserva.getMonth() + 1).padStart(2, '0')}-${String(dataDaReserva.getDate()).padStart(2, '0')}`;
    
    // Lógica de Exceções (Datas Especiais) - tem prioridade
    const excecao = duplasConfig.DatasEspeciais?.[quadraKey]?.[dataFormatadaParaChave];
	
    if (excecao && excecao.regras) {
        const horarioInicioRegra = parseInt((excecao.regras.inicio || "0:00").split(':')[0]);
        const horarioFimRegra = parseInt((excecao.regras.fim || "0:00").split(':')[0]);
        const horarioFimReserva = hora + duracao;

        
        if (hora < horarioFimRegra && horarioFimReserva > horarioInicioRegra) {
		    
            if (jogadores.includes("Convidado")) {
				const mensagem = `<b>Regra de Exceção para Duplas</b><br><br>Na data ${dataFormatadaParaChave.split('-').reverse().join('/')} (${excecao.descricao || 'Data Especial'}), o horário das ${excecao.regras.inicio} às ${excecao.regras.fim} na ${quadraSelecionada} é exclusivo para jogos entre sócios.<br><br><b>Regras para este horário:</b><br>• Apenas jogos de duplas (4 jogadores).<br>• Não é permitida a inclusão de convidados.<br><br><i>Para agendar com menos de 4 sócios, tente novamente no dia da reserva, caso o horário ainda esteja disponível.</i>`;
				return mensagem;
			}
			
			
            
            if (dataDaReserva > hoje) {
                if (jogadores.length !== 4) {
                    const mensagem = `<b>Regra de Exceção para Duplas</b><br><br>Na data ${dataFormatadaParaChave.split('-').reverse().join('/')} (${excecao.descricao || 'Data Especial'}), o horário das ${excecao.regras.inicio} às ${excecao.regras.fim} na ${quadraSelecionada} é exclusivo para jogos entre sócios.<br><br><b>Regras para este horário:</b><br>• Apenas jogos de duplas (4 jogadores).<br>• Não é permitida a inclusão de convidados.<br><br><i>Para agendar com menos de 4 sócios, tente novamente no dia da reserva, caso o horário ainda esteja disponível.</i>`;
					return mensagem;
                }
            }
        }
        return true;
    }

    // Lógica para Regras Semanais
    const diaDaSemana = dia >= 1 && dia <= 5;
    const sabado = dia === 6;
    const domingo = dia === 7;
    let diaConfigKey, nomeDoPeriodo, inicioKey, fimKey;

    if (diaDaSemana) {
        diaConfigKey = `${quadraKey.split('-')[1]}-DiasDeSemana`;

        const configDiasEspecificos = configDaQuadra.DiasDeSemanaConfig;
        if (!configDaQuadra[diaConfigKey] || !configDiasEspecificos) {
            return true;
        }
        const diaSemanaMap = { 1: 'segunda', 2: 'terca', 3: 'quarta', 4: 'quinta', 5: 'sexta' };
        if (!configDiasEspecificos[diaSemanaMap[dia]]) {
            return true; 
        }
        
        const diasAtivosNomes = [];
        if (configDiasEspecificos.segunda) diasAtivosNomes.push("Segunda-feira");
        if (configDiasEspecificos.terca) diasAtivosNomes.push("Terça-feira");
        if (configDiasEspecificos.quarta) diasAtivosNomes.push("Quarta-feira");
        if (configDiasEspecificos.quinta) diasAtivosNomes.push("Quinta-feira");
        if (configDiasEspecificos.sexta) diasAtivosNomes.push("Sexta-feira");
        
        if (diasAtivosNomes.length < 5) {
            nomeDoPeriodo = `nos seguintes dias: ${diasAtivosNomes.join(', ')}`;
        } else {
            nomeDoPeriodo = "durante a semana";
        }

    } else if (sabado) {
        diaConfigKey = `${quadraKey.split('-')[1]}-Sabado`;
        nomeDoPeriodo = "aos Sábados";
    } else if (domingo) {
        diaConfigKey = `${quadraKey.split('-')[1]}-Domingo`;
        nomeDoPeriodo = "aos Domingos";
    } else {
        return true;
    }

    if (!configDaQuadra[diaConfigKey]) {
        return true;
    }

    inicioKey = `${diaConfigKey}-Inicio`;
    fimKey = `${diaConfigKey}-Fim`;
    const horarioInicioRegra = parseInt((configDaQuadra[inicioKey] || "0:00").split(':')[0]);
    const horarioFimRegra = parseInt((configDaQuadra[fimKey] || "0:00").split(':')[0]);
    const horarioFimReserva = hora + duracao;

    if (hora < horarioFimRegra && horarioFimReserva > horarioInicioRegra) {
	
        if (jogadores.includes("Convidado")) {
			const mensagem = `**Horário Prioritário para Duplas**<br><br>No horário das ${configDaQuadra[inicioKey]} às ${configDaQuadra[fimKey]} ${nomeDoPeriodo}, a quadra é exclusiva para jogos entre sócios.<br><br><b>Regras:</b><br>• Apenas jogos de duplas (4 jogadores).<br>• Não é permitida a inclusão de convidados.<br><br><i>Para agendar com menos sócios, tente no dia da reserva.</i>`;
			return mensagem;
		}
	
        if (dataDaReserva > hoje) {
			if (jogadores.length !== 4) {
				const mensagem = `**Horário Prioritário para Duplas**<br><br>No horário das ${configDaQuadra[inicioKey]} às ${configDaQuadra[fimKey]} ${nomeDoPeriodo}, a quadra é exclusiva para jogos entre sócios.<br><br><b>Regras:</b><br>• Apenas jogos de duplas (4 jogadores).<br>• Não é permitida a inclusão de convidados.<br><br><i>Para agendar com menos sócios, tente no dia da reserva.</i>`;
			    return mensagem;
			}
		}
    }

    console.log("VALIDAÇÃO OK: A reserva passou por todas as regras de Duplas.");
    return true; 
}


function aplicarBloqueiosVisuais(quadra) {
    const quadraKey = `Quadra-${quadra.split(' ')[1]}`;
    if (!bloqueiosQuadra || !bloqueiosQuadra[quadraKey]) {
        return; 
    }
    const bloqueiosDaQuadra = bloqueiosQuadra[quadraKey];
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0);
    const diaDaSemanaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay();

    for (let dia = 1; dia <= 7; dia++) {
        let diff = dia - diaDaSemanaHoje;
        if (diff < 0) diff += 7;
        const dataDaReserva = new Date(hoje);
        dataDaReserva.setDate(hoje.getDate() + diff);
        const dataFormatada = `${dataDaReserva.getFullYear()}-${String(dataDaReserva.getMonth() + 1).padStart(2, '0')}-${String(dataDaReserva.getDate()).padStart(2, '0')}`;
        const bloqueioDoDia = bloqueiosDaQuadra[dataFormatada];

        if (bloqueioDoDia && bloqueioDoDia.regras) {
            const tabela = document.getElementById('tabelaCorpo');
            const inicioBloqueio = parseInt(bloqueioDoDia.regras.inicio.split(':')[0]);
            const fimBloqueio = parseInt(bloqueioDoDia.regras.fim.split(':')[0]);

            for (let hora = inicioBloqueio; hora < fimBloqueio; hora++) {
                const rowIndex = hora - 6;
                if (tabela.rows[rowIndex]) {
                    const cell = tabela.rows[rowIndex].cells[dia];
                    if (cell) {
                        cell.innerHTML = "";
                        cell.style.backgroundColor = 'lightcoral';
                        cell.style.cursor = 'help';
                        
                        // --- INÍCIO DA CORREÇÃO ---
                        // Armazena os dados do bloqueio diretamente na célula
                        const motivo = bloqueioDoDia.descricao || "Uso interno do clube";
                        cell.dataset.blocked = "true";
                        cell.dataset.motivo = motivo;
                        cell.dataset.horarioInicio = bloqueioDoDia.regras.inicio;
                        cell.dataset.horarioFim = bloqueioDoDia.regras.fim;
                        cell.dataset.data = dataFormatada.split('-').reverse().join('/');
                        // Remove o onclick daqui
                        // --- FIM DA CORREÇÃO ---
                        
                        cell.style.borderTop = "1px solid #bbb";
                        cell.style.borderBottom = "1px solid #bbb";
                        cell.style.borderLeft = "1px solid #bbb";
                        cell.style.borderRight = "1px solid #bbb";
                    }
                }
            }
        }
    }
}



function parseDateDDMMYYYY(dateString) {
    if (!dateString) return null;
    const parts = dateString.split('-');
    if (parts.length !== 3) return null;
    // new Date(ano, mês - 1, dia)
    return new Date(parts[2], parts[1] - 1, parts[0]);
}

/**
 * Calcula em qual linha da pirâmide um jogador da categoria masculina está.
 * @param {number} posicao - A posição do jogador no ranking.
 * @returns {number} - O número da linha.
 */
function encontrarLinha(posicao) {
    if (posicao <= 0) return 0;
    // Fórmula matemática para encontrar a linha em uma pirâmide numérica
    return Math.ceil((-1 + Math.sqrt(1 + 8 * posicao)) / 2);
}


// Função para alternar entre os temas
function toggleTheme() {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    const body = document.body;
    body.classList.toggle('dark-mode');

    // Salva a preferência do tema no localStorage
    if (body.classList.contains('dark-mode')) {
        localStorage.setItem('theme', 'dark');
    } else {
        localStorage.setItem('theme', 'light');
    }

    // CHAMA A FUNÇÃO PARA REDESENHAR A LEGENDA COM AS CORES CERTAS
    atualizarLegenda(piramideAtivaGlobal);

    // FORÇA O REDESENHO DA PLANILHA PARA APLICAR AS NOVAS CORES
    carregarReservas(quadraSelecionada); 
}

// Roda todo o código de tema depois que a página carregar
document.addEventListener('DOMContentLoaded', function() {
    // Função para aplicar o tema salvo
    function applyTheme() {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-mode');
        }
    }

    // Primeiro, aplica o tema que já estava salvo
    applyTheme();

    // Depois, adiciona o evento de clique ao botão
    document.getElementById('theme-toggle-button').addEventListener('click', toggleTheme);
});


// SUBSTITUA SUA FUNÇÃO 'verificarConvitesPendentes' PELA VERSÃO ABAIXO
function verificarConvitesPendentes(todasAsReservas) {
    if (vReservasPorConfirmacao === false) {
        return; 
    }

    const jogadorLogadoCompleto = localStorage.getItem('jogadorLogado');
    // --- LINHA DE SEGURANÇA ADICIONADA ---
    if (!jogadorLogadoCompleto) return; // Se não há ninguém logado, não faz nada.

    const jogadorLogadoApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto === jogadorLogadoCompleto
    );

    const modalConvites = document.getElementById('modalConvites');
    const listaConvites = document.getElementById('lista-convites');

    if (!listaConvites || !modalConvites) return;
    listaConvites.innerHTML = '';
    modalConvites.style.display = 'none';
    
    if (!todasAsReservas || !jogadorLogadoApelido) return;

    let encontrouConvite = false;
	
	// ==========================================================
    // ===== A CORREÇÃO ESTÁ AQUI (Mapa de Nomes de Dias) =====
    // ==========================================================
    const nomesDiasMap = {
        1: "Segunda-Feira", 2: "Terça-Feira", 3: "Quarta-Feira",
        4: "Quinta-Feira", 5: "Sexta-Feira", 6: "Sábado", 7: "Domingo"
    };
    // ==========================================================

    for (const quadra in todasAsReservas) {
        const reservasDaQuadra = todasAsReservas[quadra];
        for (const key in reservasDaQuadra) {
            const reserva = reservasDaQuadra[key];

            if (reserva.borda === undefined && reserva.duracao > 1) {
                continue;
            }

            if (reserva.status === 'pendente' && reserva.confirmacoes) {
				// Esta linha encontra a chave correta no objeto, ignorando a diferença de maiúsculas/minúsculas
				const chaveConfirmacaoCorreta = Object.keys(reserva.confirmacoes).find(key => key.toUpperCase() === jogadorLogadoApelido.toUpperCase());

				// Agora, usamos a chave correta (com a capitalização original) para verificar
				if (chaveConfirmacaoCorreta && reserva.confirmacoes[chaveConfirmacaoCorreta] === false) {

					// O resto do seu código original vai aqui dentro
					encontrouConvite = true;

					const li = document.createElement('li');
					li.style.marginBottom = '15px';

					const horaFim = reserva.hora + reserva.duracao;
					const listaDeJogadores = reserva.jogadores_completo || reserva.jogadores; 

					li.innerHTML = `
						<span><strong>${quadra}</strong><br>${nomesDiasMap[reserva.dia] || `Dia ${reserva.dia}`} das ${reserva.hora}:00 às ${horaFim}:00</span><br>
						<span style="font-size: 0.9em;">Com: ${listaDeJogadores}<br>(Org: ${reserva.organizador})</span>
						<div style="margin-top: 8px; display: flex; justify-content: center; gap: 10px;">
							<button onclick="confirmarPresenca('${key}', '${quadra}')" style="padding: 8px 15px; font-size: 0.9em; width: auto !important; background-color: #4CAF50; color: white; border-radius: 5px; border: none; cursor: pointer;">Confirmar</button>
							<button onclick="fecharModalConvites()" style="padding: 8px 15px; font-size: 0.9em; width: auto !important; background-color: #777; color: white; border-radius: 5px; border: none; cursor: pointer;">Depois</button>
							<button onclick="recusarPresenca('${key}', '${quadra}')" style="padding: 8px 15px; font-size: 0.9em; width: auto !important; background-color: #f44336; color: white; border-radius: 5px; border: none; cursor: pointer;">Recusar</button>
						</div>
					`;
					listaConvites.appendChild(li);
				}
			}
        }
    }

    if (encontrouConvite) {
        modalConvites.style.display = 'flex';
    }
}



function fecharModalConvites() {
    document.getElementById('modalConvites').style.display = 'none';
}

// Substitua a função confirmarPresenca por esta
// COLE ESTE CÓDIGO COMPLETO NO LUGAR DA SUA FUNÇÃO ATUAL
async function confirmarPresenca(reservaKey, quadra) {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    const jogadorLogadoCompleto = localStorage.getItem('jogadorLogado');
    const jogadorLogadoApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto === jogadorLogadoCompleto
    );

    
	if (!jogadorLogadoApelido) {
		mostrarNotificacao('Erro: Não foi possível identificar seu usuário.', 'error');
		return;
	}

    const reservaRef = database.ref(`sistemas/reservas/${quadra}/${reservaKey}`);

    try {
        const { committed, snapshot } = await reservaRef.transaction(currentData => {
            if (currentData === null || currentData.status !== 'pendente') {
                return undefined;
            }

            if (currentData.confirmacoes) {
                currentData.confirmacoes[jogadorLogadoApelido] = true;
            }

            let todosConfirmaram = true;
            for (const jogador in currentData.confirmacoes) {
                // Considera apenas sócios para a confirmação, ignorando 'recusado'
                if (currentData.confirmacoes[jogador] === false) {
                    todosConfirmaram = false;
                    break;
                }
            }
 
            if (todosConfirmaram) {
                currentData.status = 'confirmada';
            }

            return currentData;
        });

        
		if (committed) {
		const reserva = snapshot.val();
		if (reserva === null) {
			mostrarNotificacao('Não foi possível confirmar. A reserva pode ter sido cancelada por outro jogador.', 'error');
			
			return;
		}
   

            // ---- INÍCIO DA CORREÇÃO ----
            // Se a reserva for de 2 horas, sincroniza a segunda parte IMEDIATAMENTE.
            if (reserva.duracao > 1) {
                const reserva2Ref = database.ref(`sistemas/reservas/${quadra}/${reserva.dia}_${reserva.hora + 1}`);
                
                // Prepara um objeto com os dados que precisam ser sincronizados.
                const updatesParaSegundaParte = {
                    status: reserva.status, // Sincroniza o status geral ('pendente' ou 'confirmada')
                    confirmacoes: reserva.confirmacoes // Sincroniza o objeto de confirmações completo
                };
                
                // Executa a atualização na segunda parte da reserva.
                await reserva2Ref.update(updatesParaSegundaParte);
            }
            // ---- FIM DA CORREÇÃO ----

            // Exibe o alerta apropriado após a sincronização.
            if (reserva.status === 'confirmada') {
                //alert('Presença confirmada! A reserva agora está garantida para todos.');
				mostrarNotificacao('<b>Presença confirmada!</b><br>A reserva agora está garantida para todos.', 'success');

            } else {
                //alert('Presença confirmada! Ainda aguardando os demais jogadores.');
				mostrarNotificacao('Presença confirmada!<br>Aguardando os demais jogadores.', 'success');

				
            }
        } else {
            //alert('Não foi possível confirmar. A reserva pode ter sido alterada ou cancelada por outro jogador.');
			mostrarNotificacao('<b>Não foi possível confirmar.</b><br>A reserva pode ter sido alterada ou cancelada por outro jogador.', 'error');

        }
    } catch (error) {
        console.error("Erro na transação de confirmação:", error);
        //alert("Ocorreu um erro ao confirmar a presença. Verifique o console.");
		mostrarNotificacao("Ocorreu um erro ao confirmar a presença. Verifique o console.", 'error');

    }
}




async function recusarPresenca(reservaKey, quadra) {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    const jogadorLogadoCompleto = localStorage.getItem('jogadorLogado');
    const jogadorLogadoApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto === jogadorLogadoCompleto
    );
    if (!jogadorLogadoApelido) {
        mostrarNotificacao('Erro: Não foi possível identificar seu usuário.', 'error');
        return; 
    }

    const mensagemConfirmacao = "Tem certeza que deseja recusar este convite?<br><br><b>A ação não pode ser desfeita.</b>";

    const acaoAoConfirmar = async () => {
        const reservaRef = database.ref(`sistemas/reservas/${quadra}/${reservaKey}`);
        const stateCapture = { lastKnownData: null };
        
        try {
            const { committed, snapshot } = await reservaRef.transaction(currentData => {
                stateCapture.lastKnownData = currentData; 
                if (currentData === null || currentData.status !== 'pendente') { return undefined; }
                if (!currentData.jogadores_completo.split(', ').map(j => j.trim()).includes(jogadorLogadoApelido)) { return undefined; }
                currentData.confirmacoes[jogadorLogadoApelido] = "recusado";
                const todosOsJogadoresOriginais = currentData.jogadores_completo.split(', ').map(j => j.trim());
                const jogadoresAtivos = todosOsJogadoresOriginais.filter(apelido => apelido.toLowerCase() === 'convidado' || currentData.confirmacoes[apelido] !== 'recusado');
                let deveCancelar = false;
                const restamApenasConvidados = jogadoresAtivos.length > 0 && jogadoresAtivos.every(p => p.toLowerCase() === 'convidado');
                if (isHorarioDuplaObrigatoria(quadra, currentData.dia, currentData.hora, currentData.duracao) && jogadoresAtivos.length < 4) { deveCancelar = true; }
                if (!deveCancelar && currentData.duracao === 2 && jogadoresAtivos.length < 2) { deveCancelar = true; }
                if (!deveCancelar && restamApenasConvidados) { deveCancelar = true; }
                if (!deveCancelar && currentData.duracao === 1 && jogadoresAtivos.length < 2) { deveCancelar = true; }
                if (deveCancelar) { return null; } 
                else {
                    let todosRestantesConfirmaram = true;
                    for (const jogador in currentData.confirmacoes) {
                        if (currentData.confirmacoes[jogador] === false) {
                            todosRestantesConfirmaram = false;
                            break;
                        }
                    }
                    if (todosRestantesConfirmaram) {
                        currentData.status = 'confirmada';
                    }
                    return currentData;
                }
            });

            if (committed) {
                const reservaFinal = snapshot.val();
                if (reservaFinal === null) {
                    let motivoCancelamento = "não atender às regras do sistema.";
                    if (stateCapture.lastKnownData) {
                        const reservaParaLog = stateCapture.lastKnownData;
                        const futureConfirmacoes = { ...reservaParaLog.confirmacoes };
                        if (futureConfirmacoes.hasOwnProperty(jogadorLogadoApelido)) {
                            futureConfirmacoes[jogadorLogadoApelido] = "recusado";
                        }
                        let activePlayerCount = 0;
                        const activePlayers = [];
                        reservaParaLog.jogadores_completo.split(', ').map(j => j.trim()).forEach(p => {
                            if(p.toLowerCase() === 'convidado') activePlayers.push(p);
                        });
                        for (const player in futureConfirmacoes) {
                            if (futureConfirmacoes[player] !== "recusado") {
                                activePlayerCount++;
                                activePlayers.push(player);
                            }
                        }
                        const activePlayersAreAllGuests = activePlayers.length > 0 && activePlayers.every(p => p.toLowerCase() === 'convidado');
                        if (isHorarioDuplaObrigatoria(quadra, reservaParaLog.dia, reservaParaLog.hora, reservaParaLog.duracao) && activePlayerCount < 4) {
                            motivoCancelamento = "a reserva ficou com menos de 4 jogadores em um horário obrigatório para duplas.";
                        } else if (reservaParaLog.duracao === 2 && activePlayerCount < 2) {
                            motivoCancelamento = "a reserva de 2 horas ficou com menos de 2 jogadores.";
                        } else if (activePlayersAreAllGuests) {
                            motivoCancelamento = "a reserva ficou apenas com convidados, o que não é permitido.";
                        } else if (reservaParaLog.duracao === 1 && activePlayerCount < 2) { 
                            motivoCancelamento = "a reserva de 1 hora ficou com menos de 2 participantes.";
                        }
                        
                        // SUA LÓGICA DE LOG ORIGINAL E COMPLETA
                        const confirmacoesParaLog = { ...reservaParaLog.confirmacoes };
                        confirmacoesParaLog[jogadorLogadoApelido] = "recusado";
                        const jogadoresParaLog = Object.keys(confirmacoesParaLog);
                        if ((reservaParaLog.jogadores_completo || reservaParaLog.jogadores).toLowerCase().includes('convidado')) {
                            const convidadosCount = (reservaParaLog.jogadores_completo.match(/convidado/gi) || []).length;
                            for(let i=0; i < convidadosCount; i++) {
                                jogadoresParaLog.push('Convidado');
                            }
                        }
                        
                        const dataDaReserva = new Date();
                        const diaDaSemanaHoje = dataDaReserva.getDay() === 0 ? 7 : dataDaReserva.getDay();
                        let diff = reservaParaLog.dia - diaDaSemanaHoje;
                        if (diff < 0) diff += 7;
                        dataDaReserva.setDate(new Date().getDate() + diff);
                        const dataFormatada = `${String(dataDaReserva.getDate()).padStart(2, '0')}-${String(dataDaReserva.getMonth() + 1).padStart(2, '0')}-${dataDaReserva.getFullYear()}`;
                        const horaFinal = reservaParaLog.hora + reservaParaLog.duracao;
                        const horarioFormatado = `${String(reservaParaLog.hora).padStart(2, '0')}:00 - ${String(horaFinal).padStart(2, '0')}:00`;
                        let duracaoTexto = reservaParaLog.duracao === 1 ? "1 Hora" : "2 Horas";
                        if (reservaParaLog.duracao === 3) duracaoTexto = "2 Horas - Pirâmide";
                        
                        const logData = {
                            quadra: quadra,
                            horario: horarioFormatado,
                            jogadores: [...new Set(jogadoresParaLog)].map(capitalizarNome),
                            usuario: "SISTEMA",
                            duracao: duracaoTexto,
                            data: dataFormatada,
                            statusNoMomentoDaExclusao: 'cancelada',
                            organizadorDaReserva: reservaParaLog.organizador,
                            confirmacoes: traduzirConfirmacoesParaLog(confirmacoesParaLog),
                            motivo: motivoCancelamento
                        };
                        await registrarExclusao(logData);
                        
                        if (reservaParaLog.duracao > 1) {
                            const reserva2Ref = database.ref(`sistemas/reservas/${quadra}/${reservaParaLog.dia}_${reservaParaLog.hora + 1}`);
                            await reserva2Ref.remove();
                        }
                    }
                    
                    const mensagem = `<b>Convite recusado.</b><br>A reserva foi cancelada automaticamente porque ${motivoCancelamento}`;
                    mostrarNotificacao(mensagem, 'error');

                } else {
                    if (reservaFinal.duracao > 1) {
                        const reserva2Ref = database.ref(`sistemas/reservas/${quadra}/${reservaFinal.dia}_${reservaFinal.hora + 1}`);
                        await reserva2Ref.update({
                            status: reservaFinal.status,
                            confirmacoes: reservaFinal.confirmacoes
                        });
                    }
                    if (reservaFinal.status === 'confirmada') {
                        mostrarNotificacao('Convite recusado. Como você era o último pendente, a reserva agora está confirmada para os jogadores restantes.', 'success');
                    } else {
                        mostrarNotificacao('Convite recusado. O seu status foi atualizado.', 'success');
                    }
                }
            } else {
                mostrarNotificacao('<b>Não foi possível recusar o convite.</b><br>A reserva pode ter sido alterada ou cancelada por outro jogador enquanto você decidia.', 'error');
            }
        } catch (error) {
            console.error("Erro na transação de recusa:", error);
            mostrarNotificacao("Ocorreu um erro ao recusar o convite.", 'error');
        }
    };

    //mostrarConfirmacao(mensagemConfirmacao, acaoAoConfirmar);
	mostrarConfirmacao(mensagemConfirmacao, acaoAoConfirmar, null, 'danger');
}
						
						


/**
 * NOVA FUNÇÃO AUXILIAR
 * Verifica se um determinado horário é obrigatório para duplas, sem mostrar alertas.
 * Retorna 'true' se for um horário de duplas, 'false' caso contrário.
 */
function isHorarioDuplaObrigatoria(quadraSelecionada, dia, hora, duracao) {
    const duplasConfig = duplasConfigGlobais;
    if (!duplasConfig || !duplasConfig.ativa) return false;

    const quadraKey = `Quadra-${quadraSelecionada.split(' ')[1]}`;
    const configDaQuadra = duplasConfig[quadraKey];
    if (!configDaQuadra || !configDaQuadra[`${quadraKey}-ativa`]) return false;

    // Lógica para checar exceções e regras semanais (similar à validação, mas sem alertas)
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0); 
    const diaDaSemanaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay();
    let diff = dia - diaDaSemanaHoje;
    if (diff < 0) diff += 7;
    const dataDaReserva = new Date(hoje);
    dataDaReserva.setDate(hoje.getDate() + diff);
    const dataFormatadaParaChave = `${dataDaReserva.getFullYear()}-${String(dataDaReserva.getMonth() + 1).padStart(2, '0')}-${String(dataDaReserva.getDate()).padStart(2, '0')}`;
    
    const excecao = duplasConfig.DatasEspeciais?.[quadraKey]?.[dataFormatadaParaChave];
    if (excecao && excecao.regras) {
        const inicio = parseInt((excecao.regras.inicio || "0:00").split(':')[0]);
        const fim = parseInt((excecao.regras.fim || "0:00").split(':')[0]);
        if (hora >= inicio && (hora + duracao) <= fim) return true;
    }

    const diaDaSemana = dia >= 1 && dia <= 5;
    const sabado = dia === 6;
    const domingo = dia === 7;
    let diaConfigKey;
    if (diaDaSemana) {
        const configDiasEspecificos = configDaQuadra.DiasDeSemanaConfig;
        if (!configDaQuadra[`Quadra-${quadraKey.split('-')[1]}-DiasDeSemana`] || !configDiasEspecificos) {
            return false;
        }
        const diaSemanaMap = { 1: 'segunda', 2: 'terca', 3: 'quarta', 4: 'quinta', 5: 'sexta' };
        if (!configDiasEspecificos[diaSemanaMap[dia]]) {
            return false; 
        }
        diaConfigKey = `${quadraKey.split('-')[1]}-DiasDeSemana`;
    }
    else if (sabado) diaConfigKey = `${quadraKey.split('-')[1]}-Sabado`;
    else if (domingo) diaConfigKey = `${quadraKey.split('-')[1]}-Domingo`;
    else return false;

    if (!configDaQuadra[diaConfigKey]) return false;

    const inicio = parseInt((configDaQuadra[`${diaConfigKey}-Inicio`] || "0:00").split(':')[0]);
    const fim = parseInt((configDaQuadra[`${diaConfigKey}-Fim`] || "0:00").split(':')[0]);
    if (hora >= inicio && (hora + duracao) <= fim) return true;

    return false;
}



// COLE ESTE CÓDIGO COMPLETO NO LUGAR DA SUA FUNÇÃO ATUAL
async function limparReservasExpiradas() {
    if (vReservasPorConfirmacao === false) {
        console.log("ℹ️ Limpeza de reservas expiradas ignorada (funcionalidade desligada).");
        return; 
    }
    console.log("🧹 Iniciando verificação de reservas pendentes expiradas...");
    
    const quadras = ["Quadra 1 - Coberta", "Quadra 2 - Aberta", "Quadra 3 - Coberta"];
    const agora = Date.now();
    const updates = {};
    const logsParaRegistrar = [];

    try {
        const snapshot = await database.ref('sistemas/reservas').once('value');
        const todasAsReservas = snapshot.val();

        if (!todasAsReservas) {
            console.log("✅ Nenhuma reserva encontrada para verificar.");
            return;
        }

        for (const quadra of quadras) {
            const reservasDaQuadra = todasAsReservas[quadra];
            if (reservasDaQuadra) {
                for (const key in reservasDaQuadra) {
                    const reserva = reservasDaQuadra[key];

                    // Ignora a segunda hora da reserva (já tratada pela primeira)
                    if (reserva.borda === undefined && reserva.duracao > 1) {
                        continue;
                    }
                    
                    // Verifica se está pendente e expirada
                    if (reserva.status === 'pendente' && agora > reserva.expiraEm) {
                        
                        // 1. RECONSTRÓI A LISTA TOTAL DE JOGADORES ORIGINAIS
                        let todosJogadores = [];
                        if (reserva.jogadores_completo) {
                            todosJogadores = reserva.jogadores_completo.split(',').map(j => j.trim());
                        } else {
                            // Fallback para dados antigos (junta visual da hora 1 + hora 2)
                            let j1 = reserva.jogadores.split(',').map(j => j.trim());
                            todosJogadores.push(...j1);
                            
                            if (reserva.duracao > 1) {
                                const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                                const reserva2 = reservasDaQuadra[key2];
                                if (reserva2 && reserva2.jogadores) {
                                    todosJogadores.push(...reserva2.jogadores.split(',').map(j => j.trim()));
                                }
                            }
                            // Remove duplicatas
                            todosJogadores = [...new Set(todosJogadores)];
                        }

                        // 2. FILTRA OS "SOBREVIVENTES"
                        // Mantém: Organizador, Convidados e Quem já confirmou (true)
                        const jogadoresQueFicam = todosJogadores.filter(apelido => {
                            const isOrganizador = apelido === reserva.organizador;
                            // Verifica se começa com "Convidado" (cobre "Convidado" e "Convidado - Nome")
                            const isConvidado = apelido.startsWith("Convidado") || apelido.toLowerCase() === 'convidado';
                            const confirmou = reserva.confirmacoes && reserva.confirmacoes[apelido] === true;
                            
                            return isOrganizador || isConvidado || confirmou;
                        });

                        // 3. DECISÃO: SALVAR OU EXCLUIR?
                        if (jogadoresQueFicam.length >= 2) {
                            // === CENÁRIO A: SALVAR (Sobraram jogadores suficientes) ===
                            console.log(`✅ Reserva em ${quadra} (${key}) salva parcialmente com: ${jogadoresQueFicam.join(', ')}`);

                            const novoStatus = 'confirmada';
                            const novaListaCompleta = jogadoresQueFicam.join(', ');
                            
                            // Recalcula a visualização das células (Quem aparece na hora 1 e 2)
                            let visualParte1 = "";
                            let visualParte2 = "";

                            if (reserva.duracao > 1) {
                                // Lógica de distribuição: 1º e 3º na hora 1, 2º e 4º na hora 2
                                const p1 = [];
                                const p2 = [];
                                jogadoresQueFicam.forEach((jogador, index) => {
                                    if (index === 0 || index === 2) p1.push(jogador);
                                    if (index === 1 || index === 3) p2.push(jogador);
                                });
                                visualParte1 = p1.join(', ');
                                visualParte2 = p2.join(', ');
                            } else {
                                visualParte1 = novaListaCompleta;
                            }

                            // Prepara atualizações para a Hora 1
                            updates[`sistemas/reservas/${quadra}/${key}/status`] = novoStatus;
                            updates[`sistemas/reservas/${quadra}/${key}/jogadores_completo`] = novaListaCompleta;
                            updates[`sistemas/reservas/${quadra}/${key}/jogadores`] = visualParte1;
                            updates[`sistemas/reservas/${quadra}/${key}/expiraEm`] = null; // Remove validade

                            // Prepara atualizações para a Hora 2 (se houver)
                            if (reserva.duracao > 1) {
                                const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                                updates[`sistemas/reservas/${quadra}/${key2}/status`] = novoStatus;
                                updates[`sistemas/reservas/${quadra}/${key2}/jogadores_completo`] = novaListaCompleta;
                                updates[`sistemas/reservas/${quadra}/${key2}/jogadores`] = visualParte2;
                                updates[`sistemas/reservas/${quadra}/${key2}/expiraEm`] = null;
                            }

                            // Reconstrói o objeto de confirmações apenas com quem ficou
                            const novasConfirmacoes = {};
                            jogadoresQueFicam.forEach(j => {
                                // Se não é convidado, marca como confirmado (pois ou era org ou já tinha aceito)
                                if (!j.startsWith("Convidado") && j.toLowerCase() !== 'convidado') {
                                    novasConfirmacoes[j] = true;
                                }
                            });
                            updates[`sistemas/reservas/${quadra}/${key}/confirmacoes`] = novasConfirmacoes;
                            if (reserva.duracao > 1) {
                                const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                                updates[`sistemas/reservas/${quadra}/${key2}/confirmacoes`] = novasConfirmacoes;
                            }

                        } else {
                            // === CENÁRIO B: EXCLUIR (Não sobraram jogadores suficientes) ===
                            console.warn(`🗑️ Reserva expirada em ${quadra} (${key}) com jogadores insuficientes. Removendo.`);
                            
                            // Monta lista para o Log de Exclusão
                            // (Inclui quem estava pendente para saber quem caiu)
                            const jogadoresParaLog = Object.keys(reserva.confirmacoes || {});
                            if ((reserva.jogadores_completo || reserva.jogadores).toLowerCase().includes('convidado')) {
                                if (!jogadoresParaLog.some(j => j.toLowerCase().includes('convidado'))) {
                                    jogadoresParaLog.push('Convidado');
                                }
                            }

                            const dataDaReserva = new Date();
                            const diaDaSemanaHoje = dataDaReserva.getDay() === 0 ? 7 : dataDaReserva.getDay();
                            let diff = reserva.dia - diaDaSemanaHoje;
                            if (diff < 0) diff += 7;
                            dataDaReserva.setDate(new Date().getDate() + diff);
                            const dataFormatada = `${String(dataDaReserva.getDate()).padStart(2, '0')}-${String(dataDaReserva.getMonth() + 1).padStart(2, '0')}-${dataDaReserva.getFullYear()}`;
                            
                            const horaFinal = reserva.hora + reserva.duracao;
                            const horarioFormatado = `${String(reserva.hora).padStart(2, '0')}:00 - ${String(horaFinal).padStart(2, '0')}:00`;
                            
                            let duracaoTexto = reserva.duracao === 1 ? "1 Hora" : "2 Horas";
                            if (reserva.duracao === 3) duracaoTexto = "2 Horas - Pirâmide";
                            
                            const logData = {
                                exclusao: new Date().toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }).replace(',', ''),
                                quadra: quadra,
                                horario: horarioFormatado,
                                jogadores: jogadoresParaLog.map(capitalizarNome),
                                usuario: "SISTEMA",
                                duracao: duracaoTexto,
                                data: dataFormatada,
                                statusNoMomentoDaExclusao: 'expirada',
                                organizadorDaReserva: reserva.organizador,
                                confirmacoes: traduzirConfirmacoesParaLog(reserva.confirmacoes),
                                motivo: "Reserva expirada e com número insuficiente de jogadores confirmados"
                            };
                            
                            logsParaRegistrar.push(logData);

                            // Deleta a hora 1
                            updates[`sistemas/reservas/${quadra}/${key}`] = null;
                            // Deleta a hora 2 se existir
                            if (reserva.duracao > 1) {
                                const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                                updates[`sistemas/reservas/${quadra}/${key2}`] = null; 
                            }
                        }
                    }
                }
            }
        }

        if (Object.keys(updates).length > 0) {
            await database.ref().update(updates);
            
            // Só salva o log se houver exclusões reais
            if (logsParaRegistrar.length > 0) {
                await registrarExclusao(logsParaRegistrar);
                console.log(`✅ Processamento concluído: Reservas insuficientes removidas e reservas suficientes salvas.`);
            } else {
                console.log(`✅ Processamento concluído: Reservas expiradas foram salvas/atualizadas.`);
            }
        } else {
            console.log("✅ Nenhuma reserva expirada encontrada.");
        }

    } catch (error) {
        console.error("❌ Erro durante a limpeza de reservas expiradas:", error);
    }
}




// Função auxiliar para codificar corretamente strings com caracteres especiais
function utf8_to_b64(str) {
    return btoa(unescape(encodeURIComponent(str)));
}

// Função auxiliar para decodificar corretamente strings com caracteres especiais
function b64_to_utf8(str) {
    return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
}



// VERSÃO NOVA E ATUALIZADA
/**
 * Traduz os status de um objeto de confirmações para serem mais claros no log.
 * Converte 'true' para 'confirmado' e 'false' para 'pendente'.
 * @param {object} confirmacoes Objeto de confirmações original.
 * @returns {object} Novo objeto com os valores traduzidos, ou undefined se a entrada for nula.
 */
// Função auxiliar para preparar as confirmações para o LOG (JSON)
// Função auxiliar: Grava STATUS + NOME COMPLETO no mesmo campo
// Função auxiliar: Grava STATUS + NOME COMPLETO (Ignorando Convidados)
function traduzirConfirmacoesParaLog(confirmacoes) {
    if (!confirmacoes) return undefined;
    
    const confirmacoesTraduzidas = {};
    
    for (const apelido in confirmacoes) {
        if (confirmacoes.hasOwnProperty(apelido)) {
            // CORREÇÃO: Pula se for Convidado (não precisa aparecer nos detalhes)
            if (apelido.startsWith("Convidado")) {
                continue;
            }

            const status = confirmacoes[apelido];
            
            // 1. Traduz o Status
            let statusTexto = status;
            if (status === true) statusTexto = "confirmado";
            else if (status === false) statusTexto = "pendente";
            
            // 2. Busca o Nome Completo
            let nomeCompleto = apelido;
            if (typeof jogadoresData !== 'undefined' && jogadoresData[apelido] && jogadoresData[apelido].nomeCompleto) {
                nomeCompleto = jogadoresData[apelido].nomeCompleto; 
            }
            
            // 3. Grava chave=Apelido, valor=status|NomeCompleto
            confirmacoesTraduzidas[apelido] = `${statusTexto}|${nomeCompleto}`;
        }
    }
    return confirmacoesTraduzidas;
}

/**
 * Executa uma transação do Firebase e a encapsula em uma Promise para uso com async/await.
 * @param {firebase.database.Reference} ref - A referência do Firebase para a transação.
 * @param {function} updateFunction - A função que atualiza os dados.
 * @returns {Promise<firebase.database.DataSnapshot>} - Resolve com o snapshot em caso de sucesso.
 * @rejects {Error} - Rejeita com um erro em caso de falha ou se o horário já estiver ocupado.
 */
/**
 * Executa uma transação do Firebase e a encapsula em uma Promise.
 * ATUALIZADA: Melhora as mensagens de erro em caso de conflito, sem alterar o fluxo visual.
 */
function runTransaction(ref, updateFunction) {
    return new Promise((resolve, reject) => {
        ref.transaction(updateFunction, (error, committed, snapshot) => {
            if (error) {
                console.error("Erro na transação do Firebase:", error);
                reject(new Error("Ocorreu um erro de comunicação com o banco de dados."));
            } else if (!committed) {
                // --- MELHORIA NAS MENSAGENS DE ERRO ---
                // Se falhou (committed = false), analisamos o snapshot para dizer o motivo exato.
                const dadosQueBloquearam = snapshot.val();
                let mensagemErro = "Este horário acabou de ser reservado por outra pessoa.";

                if (dadosQueBloquearam) {
					// True = Concorrência instantânea (Presente)
					mensagemErro = obterMensagemDeConflito(dadosQueBloquearam, true);
				}
                
                // Apenas rejeita com a mensagem detalhada. O sistema segue seu fluxo normal.
                reject(new Error(mensagemErro));
                
            } else {
                // Sucesso!
                resolve(snapshot);
            }
        });
    });
}

//
// ADICIONE ESTAS TRÊS NOVAS FUNÇÕES AO SEU SCRIPT
//

/**
 * Fecha o modal de detalhes da reserva.
 */
/**
 * Fecha o modal de detalhes da reserva e desliga todos os listeners ativos (timer e Firebase).
 */
function fecharModalDetalhes() {
    const modal = document.getElementById('modalDetalhesReserva');
    if (modal) {
        modal.style.display = 'none';
    }
    if (timerContadorExpiracao) {
        clearInterval(timerContadorExpiracao);
        timerContadorExpiracao = null;
    }
    if (listenerDetalhesReserva) {
        listenerDetalhesReserva.ref.off('value', listenerDetalhesReserva.callback);
        listenerDetalhesReserva = null;
    }
    
    // --- NOVO: Remove o ouvinte de redimensionamento da tela ---
    if (funcaoAtualizarPlacarDetalhes) {
        window.removeEventListener('resize', funcaoAtualizarPlacarDetalhes);
        funcaoAtualizarPlacarDetalhes = null;
    }
    // -----------------------------------------------------------

    // Garante que a tela de placar ao vivo também seja fechada.
    fecharPlacarAoVivo();
}




// --- FUNÇÃO AUXILIAR: CALCULA COR DO TEXTO (PRETO ou BRANCO) ---
function obterCorTextoContraste(corFundo) {
    if (!corFundo || corFundo === 'rgba(0, 0, 0, 0)') return '#000000'; // Padrão

    // Converte rgb/rgba string em números
    const rgb = corFundo.match(/\d+/g);
    if (!rgb || rgb.length < 3) return '#000000';

    const r = parseInt(rgb[0]);
    const g = parseInt(rgb[1]);
    const b = parseInt(rgb[2]);

    // Fórmula de Luminosidade (YIQ)
    // Se o valor for alto, o fundo é claro (usa texto preto). Se baixo, é escuro (texto branco).
    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    
    return (yiq >= 128) ? '#000000' : '#ffffff';
}



/**
 * Abre o modal de detalhes e ATIVA o monitoramento em tempo real para a reserva.
 * @param {object} reservaInicial - O objeto da reserva no momento do clique.
 * @param {string} key - A chave da reserva no Firebase.
 * @param {string} quadra - A quadra onde a reserva está.
 */

// SUBSTITUA A FUNÇÃO exibirDetalhesReserva INTEIRA POR ESTA:
/* ================================================================= */
/* === FUNÇÃO DE DETALHES (COM VISUAL DIFERENCIADO PARA AULAS) === */
/* ================================================================= */
/* ================================================================= */
/* === FUNÇÃO DE DETALHES (CAMALEÃO - COR IGUAL À GRADE) === */
/* ================================================================= */
async function exibirDetalhesReserva(reservaInicial, key, quadra) { 
    fecharModalDetalhes(); 
    
    if (reservaInicial && reservaInicial.hora && key !== `${reservaInicial.dia}_${reservaInicial.hora}`) {
        key = `${reservaInicial.dia}_${reservaInicial.hora}`; 
    }

    const modal = document.getElementById('modalDetalhesReserva');
    const modalContent = document.querySelector('.modal-content-reserva'); 
    const reservaRef = database.ref(`sistemas/reservas/${quadra}/${key}`);

    // --- 1. RESET INICIAL ---
    const modalTitle = document.querySelector('#modalDetalhesReserva h3');
    const closeBtn = document.querySelector('.close-button');
    
    if (modalTitle) {
        modalTitle.style.padding = "15px";
        modalTitle.style.marginTop = "-20px";
        modalTitle.style.marginLeft = "-30px";
        modalTitle.style.marginRight = "-30px";
        modalTitle.style.marginBottom = "15px";
        modalTitle.style.borderRadius = "8px 8px 0 0";
    }

    const callbackDoListener = async snapshot => { 
        let reserva = snapshot.val(); 

        if (!reserva && reservaInicial && reservaInicial.fake) reserva = reservaInicial;
        if (!reserva) {
            fecharModalDetalhes();
            mostrarNotificacao("Esta reserva foi cancelada ou removida.", 'warning');
            return;
        }

        // --- 2. LÓGICA CAMALEÃO ---
        let corFundo = '#0d6efd'; 
        let corTexto = '#ffffff';

        try {
            const tabela = document.getElementById('tabelaQuadra');
            if (tabela) {
                const linhas = tabela.querySelectorAll('tbody tr');
                let celulaAlvo = null;
                linhas.forEach(tr => {
                    const cellHora = tr.cells[0];
                    if (cellHora) {
                        const horaTexto = parseInt(cellHora.textContent.trim());
                        if (horaTexto === reserva.hora) {
                            celulaAlvo = tr.cells[reserva.dia]; 
                        }
                    }
                });

                if (celulaAlvo) {
                    const estilo = window.getComputedStyle(celulaAlvo);
                    corFundo = estilo.backgroundColor;
                    if (corFundo === 'rgba(0, 0, 0, 0)' || corFundo === 'rgb(255, 255, 255)') {
                        corFundo = document.body.classList.contains('dark-mode') ? '#333' : '#f8f9fa';
                    }
                    corTexto = obterCorTextoContraste(corFundo);
                }
            }
        } catch (e) {
            console.log("Erro ao capturar cor da célula:", e);
        }

        if (modalTitle) {
            modalTitle.style.backgroundColor = corFundo;
            modalTitle.style.color = corTexto;
        }
        if (closeBtn) {
            closeBtn.style.color = corTexto; 
        }

        modalContent.classList.remove('modo-placar', 'modo-normal');
        modalContent.querySelectorAll('.p-tecnico').forEach(el => el.classList.remove('p-tecnico'));

        const idsTecnicos = ['modal-quadra', 'modal-dia', 'modal-data', 'modal-horario', 'modal-duracao', 'modal-organizador', 'p-expira-em'];
        idsTecnicos.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                const p = el.tagName === 'P' ? el : el.parentElement;
                if (p) p.classList.add('p-tecnico');
            }
        });

        const temResultado = reserva.resultado || reserva.resultadoDuplas;
        
        // --- CORREÇÃO AQUI (USAR == em vez de ===) ---
        // Isso garante que funcione mesmo se a duração vier como texto "3" do banco
        const isPiramide = (reserva.duracao == 3); 
        // ---------------------------------------------

        if (temResultado || isPiramide) modalContent.classList.add('modo-placar');
        else modalContent.classList.add('modo-normal');

        if (reserva.status === 'pendente' && reserva.expiraEm && Date.now() > reserva.expiraEm) {
            fecharModalDetalhes(); 
            limparReservasExpiradas(); 
            mostrarNotificacao("<b>Reserva Expirada</b><br>Esta reserva já havia expirado.", 'warning');
            return;
        }
        
        const nomesDiasMap = { 1: "Segunda-Feira", 2: "Terça-Feira", 3: "Quarta-Feira", 4: "Quinta-Feira", 5: "Sexta-Feira", 6: "Sábado", 7: "Domingo" };
        const pExpiraEm = document.getElementById('p-expira-em');
        if (timerContadorExpiracao) clearInterval(timerContadorExpiracao);
        
        if (reserva.status === 'pendente' && reserva.expiraEm) {
            pExpiraEm.style.display = 'block';
            iniciarContadorExpiracao(reserva); 
        } else {
            pExpiraEm.style.display = 'none';
        }

        let tituloTexto = "Detalhes da Reserva";
        const tipoLower = (reserva.jogadores || "").toLowerCase().trim();
        const ehFixa = verificarSeEhGradeFixa(quadra, reserva.dia, reserva.hora);

        if (tipoLower === 'manutencao') tituloTexto = "Detalhes da Manutenção";
        else if (tipoLower === 'aula') {
            tituloTexto = ehFixa ? "Detalhes - Aula (Grade Fixa)" : "Detalhes - Aula (Avulsa)";
        }
        else if (isPiramide) tituloTexto = "Detalhes - Desafio Pirâmide";
        
        modalTitle.textContent = tituloTexto;

        // CÁLCULO INTELIGENTE DE DURAÇÃO
        let duracaoBloco = 1;
        if (tipoLower === 'manutencao' || tipoLower === 'aula') {
            const reservasDaQuadra = reservasPorQuadra[quadra] || {};
            for (let h = parseInt(reserva.hora) + 1; h <= 23; h++) {
                const nextKey = `${reserva.dia}_${h}`;
                const nextR = reservasDaQuadra[nextKey];
                const nextNome = (nextR && nextR.jogadores) ? nextR.jogadores.toLowerCase().trim() : "";
                if (nextNome === tipoLower) {
                    duracaoBloco++;
                } else {
                    break; 
                }
            }
        }

        // --- LÓGICA DE CONTEÚDO ---
        if (tipoLower === 'manutencao') {
            const organizadorRow = document.getElementById('modal-organizador').parentElement;
            const jogadoresDiv = document.getElementById('modal-jogadores');
            const statusElement = document.getElementById('modal-status');
            const labelJogadores = jogadoresDiv.previousElementSibling;

            organizadorRow.style.display = 'none'; 
            if (statusElement && statusElement.parentElement) {
                statusElement.parentElement.style.display = 'none';
            }
            if (labelJogadores && (labelJogadores.tagName === 'P' || labelJogadores.tagName === 'STRONG')) {
                labelJogadores.style.display = 'none';
            }

            document.getElementById('modal-quadra').textContent = quadra;
            document.getElementById('modal-dia').textContent = nomesDiasMap[reserva.dia];
            const elData = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${reserva.dia})`);
            if (elData) document.getElementById('modal-data').textContent = elData.textContent;
            document.getElementById('modal-duracao').textContent = duracaoBloco > 1 ? `${duracaoBloco} Horas` : '1 Hora';
            const horaFim = parseInt(reserva.hora) + duracaoBloco;
            document.getElementById('modal-horario').textContent = `${String(reserva.hora).padStart(2, '0')}:00 - ${String(horaFim).padStart(2, '0')}:00`;

            const isDarkMode = document.body.classList.contains('dark-mode');
            const bgM = isDarkMode ? '#424242' : '#f8f9fa';
            const bordaM = isDarkMode ? '#555' : '#dee2e6';
            const cinzaDestaque = isDarkMode ? '#aaaaaa' : '#666666';  
            const nomeResponsavel = capitalizarNome(reserva.responsavel || reserva.organizador || "Manutenção");

            jogadoresDiv.style.display = 'block';
            jogadoresDiv.innerHTML = `
                <div style="padding: 15px 5px; border: 1px solid ${bordaM}; border-radius: 8px; background-color: ${bgM}; text-align: center; margin-top: 10px;">
                    <strong style="font-size: 1.15em; color: ${cinzaDestaque}; display:block; margin-bottom:5px; white-space: nowrap;">💦 Reservado para Manutenção</strong>
                    <span style="font-size: 1.1em; color: ${isDarkMode ? '#f1f1f1' : '#333333'};">Responsável: <b>${nomeResponsavel}</b></span>
                </div>`;
            
            document.getElementById('container-convidados').style.display = 'none';
            document.getElementById('modal-resultado-container').style.display = 'none';
        

        } else if (tipoLower === 'aula') {
            const organizadorRow = document.getElementById('modal-organizador').parentElement;
            const jogadoresDiv = document.getElementById('modal-jogadores');
            const jogadoresLabel = jogadoresDiv.previousElementSibling;
            const statusElement = document.getElementById('modal-status');
            const resultadoContainer = document.getElementById('modal-resultado-container');
            const containerConvidados = document.getElementById('container-convidados');

            organizadorRow.style.display = 'none'; 
            if (jogadoresLabel) jogadoresLabel.style.display = 'none';
            resultadoContainer.style.display = 'none';
            containerConvidados.style.display = 'none';

            document.getElementById('modal-quadra').textContent = quadra;
            document.getElementById('modal-dia').textContent = nomesDiasMap[reserva.dia];
            document.getElementById('modal-data').textContent = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${reserva.dia})`).textContent;
            document.getElementById('modal-duracao').textContent = duracaoBloco > 1 ? `${duracaoBloco} Horas` : '1 Hora';
            
            const horaFim = parseInt(reserva.hora) + duracaoBloco;
            document.getElementById('modal-horario').textContent = `${String(reserva.hora).padStart(2, '0')}:00 - ${String(horaFim).padStart(2, '0')}:00`;

            statusElement.textContent = 'Confirmada';
            statusElement.style.color = 'green';

            const isDarkMode = document.body.classList.contains('dark-mode');
            const bgA = isDarkMode ? '#4a3b3b' : '#fff0f0';
            const bordaA = isDarkMode ? '#8B0000' : '#ffcccc';
            const textA = isDarkMode ? '#ffcccc' : '#8B0000';
            const nomeProfessor = capitalizarNome(reserva.organizador || "Professor");

            jogadoresDiv.innerHTML = `
                <div style="padding: 15px; border: 1px solid ${bordaA}; border-radius: 8px; background-color: ${bgA}; text-align: center; margin-top: 10px;">
                    <strong style="font-size: 1.2em; color: ${textA}; display:block; margin-bottom:5px;">🎾 Aula de Tênis</strong>
                    <span style="font-size: 1.1em; color: ${isDarkMode ? '#ddd' : '#333'};">Professor: <b>${nomeProfessor}</b></span>
                </div>`;
        } else {
            // Lógica Normal (Sócios)
            let listaDeApelidos = [];
            if (reserva.jogadores_completo) listaDeApelidos = reserva.jogadores_completo.split(',').map(j => j.trim());
            else {
                listaDeApelidos.push(...(reserva.jogadores || "").split(',').map(j => j.trim()));
                if (reserva.duracao > 1) {
                    const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                    const snap2 = await database.ref(`sistemas/reservas/${quadra}/${key2}`).once('value');
                    const res2 = snap2.val();
                    if (res2 && res2.jogadores) listaDeApelidos.push(...res2.jogadores.split(',').map(j => j.trim()));
                }
            }
            
            if (reserva.resultado && reserva.duracao > 1 && listaDeApelidos.length < 2) {
                fecharModalDetalhes(); 
                setTimeout(() => { exibirDetalhesReserva(reservaInicial, key, quadra); }, 50); 
                return; 
            }

            document.getElementById('modal-organizador').parentElement.style.display = 'block';
            const jLab = document.getElementById('modal-jogadores').previousElementSibling;
            if(jLab) jLab.style.display = 'block';
            
            document.getElementById('modal-quadra').textContent = quadra;
            document.getElementById('modal-dia').textContent = nomesDiasMap[reserva.dia];
            document.getElementById('modal-data').textContent = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${reserva.dia})`).textContent;
            let duracaoTexto = reserva.duracao === 1 ? "1 Hora" : "2 Horas";
            if (reserva.duracao == 3) duracaoTexto = "2 Horas - Pirâmide";
            document.getElementById('modal-duracao').textContent = duracaoTexto;
            const hFim = reserva.hora + (reserva.duracao === 1 ? 1 : 2);
            document.getElementById('modal-horario').textContent = `${String(reserva.hora).padStart(2, '0')}:00 - ${String(hFim).padStart(2, '0')}:00`;
            document.getElementById('modal-organizador').textContent = reserva.organizador ? (jogadoresData[reserva.organizador]?.nomeCompleto || reserva.organizador) : 'N/A';
            
            const statusEl = document.getElementById('modal-status');
            const statusP = reserva.status || 'confirmada';
            statusEl.textContent = capitalizarNome(statusP.replace(/_/g, ' '));
            const isDM = document.body.classList.contains('dark-mode');
            if (statusP.includes('pendente')) statusEl.style.color = isDM ? '#FFA726' : 'orange';
            else if (statusP.includes('recusado') || statusP.includes('cancelada')) statusEl.style.color = isDM ? '#EF5350' : 'red';
            else statusEl.style.color = isDM ? '#66BB6A' : 'green';
            
            const socios = listaDeApelidos.filter(j => !j.startsWith("Convidado"));
            const convidados = listaDeApelidos.filter(j => j.startsWith("Convidado - ")).map(j => j.replace("Convidado - ", "")); 
            const divConv = document.getElementById('modal-convidados');
            const contConv = document.getElementById('container-convidados');

            if (convidados.length > 0) {
                divConv.innerHTML = '<ul>' + convidados.map(n => `<li><span class="modal-player-name"><i>${n}</i></span></li>`).join('') + '</ul>';
                contConv.style.display = 'block';
            } else {
                divConv.innerHTML = '';
                contConv.style.display = 'none';
            }

            const jogDiv = document.getElementById('modal-jogadores');
            const resCont = document.getElementById('modal-resultado-container');
            const resPlacar = document.getElementById('modal-resultado-placar');
            resCont.style.display = 'none';
            resPlacar.innerHTML = '';

            if (temResultado) {
                jogDiv.innerHTML = `<p style="margin:0;font-size:0.95em;"><em>${socios.map(a => capitalizarNome(jogadoresData[a.trim()]?.nomeCompleto || a)).join(', ')}</em></p>`;
                resCont.style.display = 'block';
                document.getElementById('modal-resultado-titulo').textContent = (reserva.status === 'em_andamento') ? 'Placar em Andamento:' : 'Resultado do Jogo:';
                
                if (reserva.resultado && listaDeApelidos.length >= 2) { 
                    funcaoAtualizarPlacarDetalhes = () => { resPlacar.innerHTML = gerarPlacarHtml(reserva.resultado, listaDeApelidos[0], listaDeApelidos[1]); };
                    funcaoAtualizarPlacarDetalhes();
                    window.addEventListener('resize', funcaoAtualizarPlacarDetalhes);
                } else if (reserva.resultadoDuplas) {
                    resPlacar.innerHTML = gerarPlacarDuplasHtml(reserva.resultadoDuplas);
                }
            } else {
                 if (funcaoAtualizarPlacarDetalhes) { window.removeEventListener('resize', funcaoAtualizarPlacarDetalhes); funcaoAtualizarPlacarDetalhes = null; }
                 
                 // --- LISTA DE JOGADORES COM STATUS --- 
                 jogDiv.innerHTML = '<ul>' + socios.map(ap => {
					let stTxt = '';
                    
                    // SÓ MOSTRA O STATUS SE NÃO FOR PIRÂMIDE
                    // Agora usando a variável isPiramide que foi corrigida acima com '=='
                    if (!isPiramide) {
                        const statusIndividual = reserva.confirmacoes ? reserva.confirmacoes[ap] : null;

                        if (statusIndividual === true) {
                            stTxt = '<span class="status-confirmado">(✓)</span>';
                        } 
                        else if (statusIndividual === "recusado") {
                            const corX = document.body.classList.contains('dark-mode') ? '#EF5350' : 'red';
                            stTxt = `<span style="color: ${corX}; font-weight: bold;">(X)</span>`;
                        }
                        else {
                            stTxt = '<span class="status-pendente">(?)</span>';
                        } 
                    }

					return `<li><span class="modal-player-name">${capitalizarNome(jogadoresData[ap.trim()]?.nomeCompleto || ap)}</span> ${stTxt}</li>`;
				}).join('') + '</ul>';
                 
                 if (isPiramide && listaDeApelidos.length >= 2) {
                    resCont.style.display = 'block';
                    document.getElementById('modal-resultado-titulo').textContent = 'Placar (Aguardando):';
                    resPlacar.innerHTML = gerarPlacarHtml({tipo: 'Placar Normal', vencedor: '', perdedor: '', set1: { placar: '0x0' }, set2: { placar: '0x0' }, set3: '0x0'}, listaDeApelidos[0], listaDeApelidos[1]);
                 }
            }
        }
        
        const btnPlacar = document.getElementById('container-btn-placar-ao-vivo');
        if (reserva.duracao == 3 && reserva.status === 'em_andamento') {
            btnPlacar.style.display = 'block';
            document.getElementById('btn-placar-ao-vivo').onclick = () => abrirPlacarAoVivo(key, quadra);
        } else {
            btnPlacar.style.display = 'none'; 
        }
    };

    const listenerCallback = reservaRef.on('value', callbackDoListener);
    listenerDetalhesReserva = { ref: reservaRef, callback: listenerCallback };

    if (modal.style.display !== 'flex') modal.style.display = 'flex';
}





// COLE ESTA FUNÇÃO COMPLETA NO LUGAR DA SUA ATUAL 'configurarEventosDaTabela'
// CÓDIGO COMPLETO E ATUALIZADO
function configurarEventosDaTabela() {
    const tabelaCorpo = document.getElementById('tabelaCorpo');
    if (!tabelaCorpo) return;

    const novoTabelaCorpo = tabelaCorpo.cloneNode(true);
    tabelaCorpo.parentNode.replaceChild(novoTabelaCorpo, tabelaCorpo);

    // 1. LISTENER PARA O CLIQUE SIMPLES
    novoTabelaCorpo.addEventListener('click', function(event) {
        const cell = event.target.closest('td');
        if (!cell || cell.classList.contains('horario')) return;
        
        const isAdmin = isUsuarioAdmin(); 
        
        // Verifica tipos especiais
        const tipoCelula = cell.dataset.tipo;
        const conteudoCelula = cell.innerHTML.trim().toLowerCase();
        const isAulaCell = (tipoCelula === 'aula_fixa' || tipoCelula === 'aula_extra' || conteudoCelula.includes('aula'));
        const isManutencaoCell = (tipoCelula === 'manutencao' || conteudoCelula.includes('manutenção') || conteudoCelula.includes('manutencao'));

        // --- VALIDAÇÃO DE DATAS (Mantida igual) ---
        const colIndex = cell.cellIndex;
        const headerRow = document.getElementById('tabelaQuadra').rows[1];
        let dataCelula = null;
        const hoje = new Date();
        hoje.setHours(0, 0, 0, 0);

        if (headerRow && headerRow.cells[colIndex - 1]) {
            const dataTextoRaw = headerRow.cells[colIndex - 1].textContent.trim();
            const dataTexto = dataTextoRaw.replace(/[^0-9\/]/g, ''); 
            if (dataTexto.includes('/')) {
                const [d, m, y] = dataTexto.split('/');
                const anoCompleto = y.length === 2 ? "20" + y : y;
                dataCelula = new Date(anoCompleto, m - 1, d);
                dataCelula.setHours(0, 0, 0, 0); 

                // Bloqueio de Passado (Data)
                if (dataCelula < hoje) {
                    if (!isAdmin || isAulaCell || isManutencaoCell) return; 
                }
            }
        }

        if (cell.dataset.blocked === 'true') {
            mostrarNotificacao(`<b>Horário Bloqueado</b><br>${cell.dataset.motivo}`, 'warning');
            return; 
        }

        // --- CÉLULA VAZIA (Novo Agendamento) ---
        if (cell.innerHTML.trim() === '') {
            if (dataCelula && dataCelula < hoje) return; 

            const diaIndex = cell.cellIndex;
            const rowIndex = cell.parentElement.rowIndex - 2;
            const horaDaCelula = rowIndex + 6;

            // ========================================================
            // === NOVA TRAVA: HORÁRIO PASSADO (MESMO DIA) ===
            // ========================================================
            const agora = new Date();
            const diaSemanaHoje = agora.getDay() === 0 ? 7 : agora.getDay();
            const horaAtual = agora.getHours();

            // Se for hoje E a hora da célula for menor que a hora atual, bloqueia.
            if (diaIndex === diaSemanaHoje && horaDaCelula < horaAtual) {
                if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
                mostrarNotificacao("Horário indisponível!", "warning");
                return;
            }
            // ========================================================

            abrirAgendamentoPelaCelula(diaIndex, horaDaCelula);
            return;
        }
        
        // --- CLIQUE EM RESERVA EXISTENTE ---
        clearTimeout(clickTimer);
        
        clickTimer = setTimeout(function() {
            const rowIndex = cell.parentElement.rowIndex - 2;
            const hora = rowIndex + 6;
            const dia = colIndex;
            
            const reservasDaQuadra = reservasPorQuadra[quadraSelecionada] || {};
            let keyClicada = `${dia}_${hora}`;
            let reservaParaAcao = reservasDaQuadra[keyClicada];

            // Fake Object para Aula Fixa Visual
            if (!reservaParaAcao && cell.dataset.tipo === 'aula_fixa') {
                reservaParaAcao = { jogadores: "Aula", fake: true, dia: dia, hora: hora, organizador: cell.dataset.professor || "Professor", tipo: 'aula_fixa' };
            }

            if (!reservaParaAcao) return;

            // Backtracking (Busca a reserva pai se clicou na 2ª hora)
            const nomeReserva = (reservaParaAcao.jogadores || "").trim();
            const isAula = nomeReserva.toLowerCase() === 'aula';
            const isManutencao = nomeReserva.toLowerCase() === 'manutencao' || reservaParaAcao.tipo === 'manutencao';

            if (!isAula && !isManutencao && !reservaParaAcao.fake) {
                if (reservaParaAcao.borda === undefined) {
                    const keyAnterior = `${dia}_${hora - 1}`;
                    const reservaAnterior = reservasDaQuadra[keyAnterior];
                    if (reservaAnterior && reservaAnterior.duracao > 1) {
                        reservaParaAcao = reservaAnterior;
                        keyClicada = keyAnterior;
                    }
                }
            }

            const jogadorLogado = localStorage.getItem('jogadorLogado');
            const apelidoJogadorLogado = Object.keys(jogadoresData).find(
                apelido => jogadoresData[apelido].nomeCompleto.toLowerCase() === jogadorLogado.toLowerCase()
            ) || jogadorLogado;
            const isProfessorDono = verificarPermissao('gestor_aulas') && isUsuarioProfessor(quadraSelecionada);
            const isManutencaoUser = verificarPermissao('controle_quadras');
            const isOperador = verificarPermissao('gerir_reservas');

            // --- MENU 1: MANUTENÇÃO (NOVO!) ---
            if (isManutencao) {
                if (isAdmin || isManutencaoUser) {
                    mostrarOpcoesManutencao(dia, hora, quadraSelecionada);
                }
                return;
            }

            // --- MENU 2: PIRÂMIDE ---
            if (reservaParaAcao.duracao === 3) {
                let todosJogadoresDaPartida = [];
                const jogadoresParte1 = (reservaParaAcao.jogadores_completo || reservaParaAcao.jogadores).split(',').map(j => j.trim());
                todosJogadoresDaPartida.push(...jogadoresParte1);
                const keySegundaParte = `${reservaParaAcao.dia}_${reservaParaAcao.hora + 1}`;
                const reservaSegundaParte = reservasDaQuadra[keySegundaParte];
                if (reservaSegundaParte) {
                    const jogadoresParte2 = (reservaSegundaParte.jogadores_completo || reservaSegundaParte.jogadores).split(',').map(j => j.trim());
                    todosJogadoresDaPartida.push(...jogadoresParte2);
                }
                const isParticipante = [...new Set(todosJogadoresDaPartida)].some(j => j.toUpperCase() === apelidoJogadorLogado.toUpperCase());
                const isDelegado = reservaParaAcao.delegado === apelidoJogadorLogado;

                if (isAdmin || isParticipante || isUsuarioArbitro() || isDelegado) {
                    mostrarOpcoesPiramide(reservaParaAcao, keyClicada, quadraSelecionada, isParticipante, isDelegado);
                }
                return; 
            } 
            
            // --- MENU 3: AULA ---
            if (isAula) {
                if (isAdmin || isProfessorDono) {
                    const tipo = cell.dataset.tipo || 'aula_extra'; 
                    mostrarOpcoesAula(tipo, dia, hora, quadraSelecionada);
                }
                return; 
            } 
            
            // --- MENU 4: JOGO NORMAL ---
            let listaDeJogadores = [];
            if (reservaParaAcao.jogadores_completo) {
                listaDeJogadores = reservaParaAcao.jogadores_completo.split(',').map(j => j.trim());
            } else {
                listaDeJogadores.push(...reservaParaAcao.jogadores.split(',').map(j => j.trim()));
                if (reservaParaAcao.duracao > 1) {
                    const keySegundaParte = `${reservaParaAcao.dia}_${reservaParaAcao.hora + 1}`;
                    const reservaSegundaParte = reservasDaQuadra[keySegundaParte];
                    if (reservaSegundaParte && reservaSegundaParte.jogadores) {
                       listaDeJogadores.push(...reservaSegundaParte.jogadores.split(',').map(j => j.trim()));
                    }
                }
            }
            const isParticipante = [...new Set(listaDeJogadores)].some(j => j.toUpperCase() === apelidoJogadorLogado.toUpperCase());

            if (isAdmin || isOperador || isParticipante) {
                mostrarOpcoesReserva(reservaParaAcao, keyClicada, quadraSelecionada);
            }

        }, 250); 
    });

    // 2. LISTENER DUPLO CLIQUE (Mantido igual)
    novoTabelaCorpo.addEventListener('dblclick', function(event) {
        clearTimeout(clickTimer); 
        const cell = event.target.closest('td');
        if (!cell || cell.innerHTML.trim() === '' || cell.classList.contains('horario') || cell.dataset.blocked === 'true') {
            return;
        }

        const rowIndex = cell.parentElement.rowIndex - 2;
        const colIndex = cell.cellIndex;
        const hora = rowIndex + 6; 
        const dia = colIndex;
        
        const reservasDaQuadra = reservasPorQuadra[quadraSelecionada] || {};
        let keyClicada = `${dia}_${hora}`; 
        let reservaParaExibir = reservasDaQuadra[keyClicada];

        // Fallback Aula Fixa
        if (!reservaParaExibir && cell.dataset.tipo === 'aula_fixa') {
            reservaParaExibir = {
                jogadores: "Aula",
                dia: dia,
                hora: hora,
                duracao: 1,
                status: 'confirmada',
                organizador: cell.dataset.professor || "Professor",
                tipo: 'aula_fixa', 
                fake: true
            };
        }

        if (!reservaParaExibir) return;

        // Backtracking Jogos
        const nomeReserva = (reservaParaExibir.jogadores || "").trim().toLowerCase();
        const isManutencao = nomeReserva === 'manutencao';
        
        if (nomeReserva !== 'aula' && !isManutencao && !reservaParaExibir.fake) {
            if (reservaParaExibir.borda === undefined) {
                const keyAnterior = `${dia}_${hora - 1}`;
                const reservaAnterior = reservasDaQuadra[keyAnterior];
                if (reservaAnterior && reservaAnterior.duracao > 1) {
                    reservaParaExibir = reservaAnterior;
                    keyClicada = keyAnterior; 
                }
            }
        }

        if (reservaParaExibir) {
            exibirDetalhesReserva(reservaParaExibir, keyClicada, quadraSelecionada);
        }
    });
}





function mostrarOpcoesReserva(reserva, key, quadra) {
    // 1. FAXINA GERAL (A novidade)
    limparBotoesFantasmas();

    const modal = document.getElementById('modalAcoesReserva');
    if (!modal) return;

    const modalTitulo = modal.querySelector('h3');
    if (modalTitulo) modalTitulo.textContent = "O que deseja fazer?";

    const btnVer = document.getElementById('btnModalVer');
    const btnEditar = document.getElementById('btnModalEditar');
    const btnExcluir = document.getElementById('btnModalExcluir');
    const btnCancelar = document.getElementById('btnModalCancelar');

    // --- LÓGICA DE PERMISSÕES (Completa) ---
    const jogadorLogado = localStorage.getItem('jogadorLogado');
    const apelidoJogadorLogado = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto.toLowerCase() === jogadorLogado.toLowerCase()
    ) || jogadorLogado;

    // Reconstrói lista de jogadores (incluindo duplas se houver)
    let listaDeJogadores = [];
    if (reserva.jogadores_completo) {
        listaDeJogadores = reserva.jogadores_completo.split(',').map(j => j.trim());
    } else {
        const p1 = (reserva.jogadores || "").split(',').map(j => j.trim());
        listaDeJogadores.push(...p1);
        
        // Verifica continuação (2ª hora) para pegar mais jogadores
        if (reserva.duracao > 1) {
            const reservasDaQuadra = reservasPorQuadra[quadra] || {};
            const key2 = `${reserva.dia}_${reserva.hora + 1}`;
            const r2 = reservasDaQuadra[key2];
            if (r2 && r2.jogadores) {
                listaDeJogadores.push(...r2.jogadores.split(',').map(j => j.trim()));
            }
        }
    }
    // Remove duplicatas
    listaDeJogadores = [...new Set(listaDeJogadores)];

    const isAdmin = isUsuarioAdmin();
    const isOperador = verificarPermissao('gerir_reservas');
    const isOrganizador = reserva.organizador === apelidoJogadorLogado;
    const isPendente = reserva.status === 'pendente';
    
    // Normalização para comparar nomes (Case Insensitive)
    const isParticipante = listaDeJogadores.some(j => j.trim().toUpperCase() === apelidoJogadorLogado.toUpperCase());
    
    const statusDoJogador = reserva.confirmacoes ? reserva.confirmacoes[apelidoJogadorLogado] : undefined;

    // --- BOTÕES ---

    // 1. Botão VER
    if (btnVer) {
        btnVer.style.display = 'block';
        btnVer.textContent = "Ver Detalhes";
        btnVer.onclick = () => {
            exibirDetalhesReserva(reserva, key, quadra);
            fecharModalAcoes();
        };
    }

    // 2. Botão EDITAR
    const podeEditar = isPendente && (isAdmin || isOperador || (isOrganizador && edicaoOrganizadorAtiva));
    if (btnEditar) {
        if (podeEditar) {
            btnEditar.style.display = 'block';
            btnEditar.textContent = "Editar Reserva";
            btnEditar.onclick = () => {
                iniciarModoEdicao(reserva, key, quadra);
                fecharModalAcoes();
            };
        } else {
            btnEditar.style.display = 'none';
        }
    }

    // 3. Botão EXCLUIR
    const temPermissaoBase = isAdmin || isOperador || (isPendente && isOrganizador) || (!isPendente && isParticipante && statusDoJogador !== 'recusado');
    
    // Verificação de Data Futura
    const agora = new Date();
    let isJogoFuturo = true;
    try {
        const tabela = document.getElementById('tabelaQuadra');
        if (tabela && tabela.rows[1].cells[reserva.dia - 1]) {
            const dataString = tabela.rows[1].cells[reserva.dia - 1].textContent;
            const [d, m, y] = dataString.split('/');
            const anoCompleto = y.length === 2 ? "20" + y : y;
            // Fim do jogo = hora + duração
            const dtFim = new Date(anoCompleto, m - 1, d, reserva.hora + (reserva.duracao || 1), 0, 0);
            
            if (agora > dtFim) isJogoFuturo = false;
        }
    } catch(e) { console.error("Erro data excluir", e); }

    // Admin/Operador podem excluir passado. Usuário só futuro (ou se config permitir).
    const podeExcluir = temPermissaoBase && (isJogoFuturo || isAdmin || isOperador || vPermitirExclusaoAposJogo);

    if (btnExcluir) {
        if (podeExcluir) {
            btnExcluir.style.display = 'block';
            btnExcluir.textContent = "Excluir Reserva";
            btnExcluir.style.backgroundColor = "#dc3545"; // Vermelho
            btnExcluir.style.color = "white";
            
            btnExcluir.onclick = () => {
                fecharModalAcoes();
                const mensagem = "Você tem certeza que deseja excluir esta reserva?";
                const acaoAoConfirmar = () => {
                    excluirReserva(reserva.hora - 6, reserva.dia);
                };
                mostrarConfirmacao(mensagem, acaoAoConfirmar, null, 'danger'); 
            };
        } else {
            btnExcluir.style.display = 'none';
        }
    }

    // 4. Botão CANCELAR
    if (btnCancelar) {
        btnCancelar.style.display = 'block';
        btnCancelar.textContent = "Cancelar";
        btnCancelar.onclick = fecharModalAcoes;
    }

    // Fecha ao clicar fora
    modal.onclick = (event) => {
        if (event.target === modal) {
            fecharModalAcoes();
        }
    };

    modal.style.display = 'flex';
}





function iniciarModoEdicao(reserva, key, quadra) {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    reservaEmEdicao = { key, quadra, dadosOriginais: reserva };

    const container = document.getElementById('edit-jogadores-container');
    container.innerHTML = '';
    const jogadoresParaEditar = reserva.jogadores_completo.split(',').map(j => j.trim());

    jogadoresParaEditar.forEach(apelido => {
        const newRow = document.createElement('div');
        newRow.className = 'edit-jogador-row';
        
        const novoSelect = document.createElement('select');
        novoSelect.innerHTML = document.getElementById('jogadorSelect').innerHTML;

        // ==========================================================
        // ===== INÍCIO DA CORREÇÃO (Parte 1) =====
        // ==========================================================
        
        // 1. ADICIONA O GATILHO 'onchange' a TODOS os dropdowns
        // Isso é crucial para permitir a troca para um "Novo Convidado"
        novoSelect.setAttribute('onchange', 'handleConvidadoSelect(this)');

        const statusSpan = document.createElement('span');
        statusSpan.className = 'edit-status-span'; 
        
        const status = reserva.confirmacoes ? reserva.confirmacoes[apelido] : null;

        const isConvidadoNomeado = apelido.trim().startsWith("Convidado - ");
        const isConvidadoGenerico = apelido.trim().toLowerCase() === 'convidado';

        // 2. VERIFICA SE É UM CONVIDADO NOMEADO (ex: "Convidado - Joao Maria")
        if (isConvidadoNomeado) {
            // Extrai o nome limpo (ex: "Joao Maria")
            const nomeLimpo = apelido.substring(apelido.indexOf('-') + 2).trim();
            
            // Cria a nova <option> especial
            const guestOption = document.createElement('option');
            guestOption.value = apelido; // O valor interno é o nome completo (ex: "Convidado - Joao Maria")
            guestOption.textContent = nomeLimpo; // O texto visível é o nome limpo (ex: "Joao Maria")
            guestOption.classList.add('convidado-nomeado-option'); // Aplica o estilo (Negrito, Itálico)
            
            // Adiciona a opção no topo do dropdown e a seleciona
            novoSelect.appendChild(guestOption);
            novoSelect.value = apelido;

            // Define o status visual
            statusSpan.textContent = '(Convidado)';
            statusSpan.style.color = document.body.classList.contains('dark-mode') ? '#ccc' : '#555';
            statusSpan.style.fontStyle = 'italic';
        
        } else if (isConvidadoGenerico) {
            // Se for o convidado genérico, apenas seleciona
            novoSelect.value = "Convidado";
            statusSpan.textContent = '(Convidado)';
            statusSpan.style.color = document.body.classList.contains('dark-mode') ? '#ccc' : '#555';
            statusSpan.style.fontStyle = 'italic';
        
        } else { 
            // É um Sócio
            novoSelect.value = apelido;
            if (status === true) {
                novoSelect.disabled = true;
                statusSpan.textContent = '(Confirmado)';
                statusSpan.style.color = 'green';
            } else if (status === false) {
                statusSpan.textContent = '(Pendente)';
                statusSpan.style.color = 'orange';
            } else if (status === 'recusado') {
                statusSpan.textContent = '(Recusado)';
                statusSpan.style.color = 'red';
            }
        }
        // ==========================================================
        // ===== FIM DA CORREÇÃO (Parte 1) =====
        // ==========================================================
        
        newRow.appendChild(novoSelect);
        newRow.appendChild(statusSpan);

        if (status !== true) {
            const removeButton = document.createElement('span');
            removeButton.className = 'remove-jogador-btn';
            removeButton.innerHTML = '&times;';
            removeButton.onclick = () => newRow.remove();
            newRow.appendChild(removeButton);
        } else {
            const placeholder = document.createElement('span');
            placeholder.className = 'remove-jogador-btn';
            placeholder.innerHTML = '&times;';
            placeholder.style.visibility = 'hidden';
            newRow.appendChild(placeholder);
			
        }
		
        atualizarEstiloSelectConvidado(novoSelect);
        container.appendChild(newRow);
    });

    document.getElementById('btnAdicionarJogadorEdicao').onclick = adicionarJogadorNaEdicao;
	
    document.getElementById('btnSalvarEdicao').onclick = salvarEdicao;
	
    document.getElementById('modalEdicaoReserva').style.display = 'flex';
}




async function salvarEdicao() {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    if (!reservaEmEdicao) return;

    // Pega os dados dos jogadores de dentro do modal
    const container = document.getElementById('edit-jogadores-container');
    const novosJogadoresSelects = container.querySelectorAll('select');

    // ==========================================================
    // ===== INÍCIO DA CORREÇÃO (Parte 2) =====
    // ==========================================================
    
    // --- LÓGICA SIMPLIFICADA E CORRIGIDA ---
    
    // ==========================================================
    // ===== CORREÇÃO DO BUG (Linha 9011) =====
    // ==========================================================
    // Atribui IDs temporários aos selects para que o mapa de convidados funcione
    novosJogadoresSelects.forEach((select, index) => { // <-- Variável 'selects' corrigida para 'novosJogadoresSelects'
         select.id = `edit_jogador_${index}`; 
    });
    // ==========================================================
    // ===== FIM DA CORREÇÃO DO BUG =====
    // ==========================================================

    const novosApelidos = Array.from(novosJogadoresSelects).map(select => {
        const valorSelecionado = select.value; // ex: "Convidado - Joao Maria" OU "TABORDA" OU "Convidado"

        // Agora podemos ler o mapa com segurança
        if (valorSelecionado === "Convidado" && nomesConvidadosMap[select.id]) {
            return nomesConvidadosMap[select.id]; // Retorna "Convidado - Novo Nome"
        }
        
        // Se for "Convidado - Joao Maria" (a opção que criamos) ou um sócio,
        // o valor já está correto.
        return valorSelecionado; 
    }).filter(val => val); // Filtra valores vazios
    // ==========================================================
    // ===== FIM DA CORREÇÃO (Parte 2) =====
    // ==========================================================


    if (novosApelidos.length === 0) {
		mostrarNotificacao("Uma reserva não pode ficar sem jogadores.", 'error');
        return;
    }

    const sociosNaLista = novosApelidos.filter(j => !j.trim().startsWith("Convidado")); // Filtra "Convidado" E "Convidado - Nome"
    if (new Set(sociosNaLista).size !== sociosNaLista.length) {
		mostrarNotificacao("Não é permitido adicionar o mesmo sócio mais de uma vez na reserva.", 'error');
        return;
    }

    const { key, quadra, dadosOriginais } = reservaEmEdicao;

    // VALIDAÇÃO 1: REGRAS DE DUPLAS (VERSÃO CORRIGIDA)
    const resultadoDuplasOk = await validarRegraDeDuplas(novosApelidos, quadra, dadosOriginais.dia, dadosOriginais.hora, dadosOriginais.duracao);
    
    if (resultadoDuplasOk !== true) {
        mostrarNotificacao(resultadoDuplasOk, 'warning');
        return; 
    }

    // VALIDAÇÃO 2: CONFLITO DE RESERVAS (APENAS PARA JOGADORES ADICIONADOS)
    const jogadoresOriginais = new Set(dadosOriginais.jogadores_completo.split(',').map(j => j.trim()));
    const jogadoresAdicionados = novosApelidos.filter(apelido => !jogadoresOriginais.has(apelido));
    if (jogadoresAdicionados.length > 0) {
        const reservaValida = await validarSeTemReserva(jogadoresAdicionados);
        if (!reservaValida) {
            return;
        }
    }

    // Lógica para reconstruir o objeto de confirmações
    const novoConfirmacoes = {};
    novosApelidos.forEach(apelido => {
        const statusOriginal = dadosOriginais.confirmacoes[apelido];
        if (statusOriginal === true) {
            novoConfirmacoes[apelido] = true;
        } else if (statusOriginal === 'recusado') {
            novoConfirmacoes[apelido] = 'recusado';
        } else if (!apelido.trim().startsWith("Convidado")) { // Modificado para incluir "Convidado - Nome"
            novoConfirmacoes[apelido] = false;
        }
    });

    // VALIDAÇÃO 3: NÚMERO MÍNIMO DE JOGADORES ATIVOS
    const jogadoresAtivos = novosApelidos.filter(apelido => novoConfirmacoes[apelido] !== 'recusado');
    const numJogadoresAtivos = jogadoresAtivos.length;
    const apenasConvidadosAtivos = numJogadoresAtivos > 0 && jogadoresAtivos.every(j => j.trim().startsWith("Convidado")); // Modificado

    let motivoCancelamento = '';

    if (dadosOriginais.duracao === 2 && numJogadoresAtivos < 2) {
        motivoCancelamento = 'a reserva de 2 horas ficou com menos de 2 jogadores ativos.';
    } else if (dadosOriginais.duracao === 1 && numJogadoresAtivos < 2) {
        motivoCancelamento = 'a reserva de 1 hora ficou com menos de 2 participantes ativos.';
    } else if (apenasConvidadosAtivos) {
        motivoCancelamento = 'a reserva ficou apenas com convidados, o que não é permitido.';
    }

    if (motivoCancelamento) {
		mostrarNotificacao(`A reserva será cancelada automaticamente porque, após a edição, ${motivoCancelamento}`, 'error');
               
        try {
            const jogadorLogado = localStorage.getItem('jogadorLogado');
            const dataDaReserva = new Date();
            const diaDaSemanaHoje = dataDaReserva.getDay() === 0 ? 7 : dataDaReserva.getDay();
            let diff = dadosOriginais.dia - diaDaSemanaHoje;
            if (diff < 0) diff += 7;
            dataDaReserva.setDate(new Date().getDate() + diff);
            const dataFormatada = `${String(dataDaReserva.getDate()).padStart(2, '0')}-${String(dataDaReserva.getMonth() + 1).padStart(2, '0')}-${dataDaReserva.getFullYear()}`;

            const horaFinal = dadosOriginais.hora + (dadosOriginais.duracao === 1 ? 1 : 2);
            const horarioFormatado = `${String(dadosOriginais.hora).padStart(2, '0')}:00 - ${String(horaFinal).padStart(2, '0')}:00`;
            let duracaoTexto = dadosOriginais.duracao === 1 ? "1 Hora" : "2 Horas";
            if (dadosOriginais.duracao === 3) duracaoTexto = "2 Horas - Pirâmide";

            const logData = {
                quadra: quadra,
                horario: horarioFormatado,
                jogadores: dadosOriginais.jogadores_completo.split(',').map(j => capitalizarNome(j.trim())),
                usuario: jogadorLogado,
                duracao: duracaoTexto,
                motivo: `Cancelado automaticamente após edição: ${motivoCancelamento}`,
                statusNoMomentoDaExclusao: 'cancelada', 
                organizadorDaReserva: dadosOriginais.organizador,
                confirmacoes: traduzirConfirmacoesParaLog(dadosOriginais.confirmacoes)
            };
            
            await registrarExclusao(logData);
        } catch(logError) {
            console.error("ERRO CRÍTICO: Falha ao registrar o log da exclusão automática.", logError);
			const mensagem = "<b>Atenção:</b> A reserva será cancelada, mas houve uma falha ao registrar o log.<br>Avise o administrador.";
            mostrarNotificacao(mensagem, 'error');
        }
        
        const refPrimeiraHora = database.ref(`sistemas/reservas/${quadra}/${key}`);
        const refSegundaHora = dadosOriginais.duracao > 1 ? database.ref(`sistemas/reservas/${quadra}/${dadosOriginais.dia}_${dadosOriginais.hora + 1}`) : null;

        try {
            await refPrimeiraHora.remove();
            if (refSegundaHora) {
                await refSegundaHora.remove();
            }
        } catch (error) {
            console.error("Erro no cancelamento automático pós-edição:", error);
			mostrarNotificacao("Ocorreu um erro ao cancelar a reserva automaticamente.", 'error');
        } finally {
            fecharModalEdicao(); 
        }
        return; 
    }

    // Se todas as validações passaram, o código para ATUALIZAR a reserva é executado
    let todosConfirmaram = Object.values(novoConfirmacoes).every(status => status === true || status === 'recusado');
    if(Object.values(novoConfirmacoes).some(status => status === false)) { todosConfirmaram = false; }
    const novoStatus = todosConfirmaram ? 'confirmada' : 'pendente';
    
    const updates = {};
    const jogadoresParte1 = [], jogadoresParte2 = [];
    if (dadosOriginais.duracao > 1) {
        novosApelidos.forEach((apelido, index) => {
            if (index === 0 || index === 2) jogadoresParte1.push(apelido);
            if (index === 1 || index === 3) jogadoresParte2.push(apelido);
        });
    } else {
        jogadoresParte1.push(...novosApelidos);
    }
    
    updates[`sistemas/reservas/${quadra}/${key}/status`] = novoStatus;
    updates[`sistemas/reservas/${quadra}/${key}/jogadores_completo`] = novosApelidos.join(', ');
    updates[`sistemas/reservas/${quadra}/${key}/jogadores`] = jogadoresParte1.join(', ');
    updates[`sistemas/reservas/${quadra}/${key}/confirmacoes`] = novoConfirmacoes;

    if (dadosOriginais.duracao > 1) {
        const key2 = `${dadosOriginais.dia}_${dadosOriginais.hora + 1}`;
        updates[`sistemas/reservas/${quadra}/${key2}/status`] = novoStatus;
        updates[`sistemas/reservas/${quadra}/${key2}/jogadores_completo`] = novosApelidos.join(', ');
        updates[`sistemas/reservas/${quadra}/${key2}/jogadores`] = jogadoresParte2.join(', ');
        updates[`sistemas/reservas/${quadra}/${key2}/confirmacoes`] = novoConfirmacoes;
    }

    try {
        await database.ref().update(updates);
        
        const statusOriginal = dadosOriginais.status;
        if (statusOriginal === 'pendente' && novoStatus === 'confirmada') {
			const mensagem = "<b>Alterações salvas!</b><br>Como não há mais jogadores pendentes, a reserva foi confirmada.";
            mostrarNotificacao(mensagem, 'success');
        } else {
			mostrarNotificacao("Reserva atualizada com sucesso!", 'success');
        }

    } catch (error) {
		mostrarNotificacao("Erro ao atualizar a reserva. Tente novamente.", 'error');
        console.error("Erro ao salvar edição:", error);
    } finally {
        fecharModalEdicao();
        // Limpa o mapa de convidados após o uso para a próxima reserva
        nomesConvidadosMap = {};
    }
}



function cancelarEdicao() {
    reservaEmEdicao = null;

    ['quadra', 'dia', 'duracao', 'hora'].forEach(id => document.getElementById(id).disabled = false);

    limparCampos();

    const botaoAgendar = document.getElementById('botaoAgendar');
    botaoAgendar.textContent = 'Agendar';
    botaoAgendar.onclick = atualizarTabela;
    botaoAgendar.style.backgroundColor = '#4CAF50';

    const cancelButton = document.getElementById('cancelButton');
    if (cancelButton) {
        cancelButton.remove();
    }
}

// ADICIONE ESTA NOVA FUNÇÃO
function fecharModalAcoes() {
    document.getElementById('modalAcoesReserva').style.display = 'none';
}


// ADICIONE ESTAS DUAS NOVAS FUNÇÕES

/**
 * Fecha o modal de edição de reserva.
 */
function fecharModalEdicao() {
    reservaEmEdicao = null; // Limpa a reserva em edição
    document.getElementById('modalEdicaoReserva').style.display = 'none';
}

/**
 * Adiciona um novo campo de jogador dentro do modal de edição.
 */
// SUBSTITUA A SUA FUNÇÃO adicionarJogadorNaEdicao ATUAL POR ESTA VERSÃO
/**
 * Adiciona um novo campo de jogador dentro do modal de edição,
 * removendo os jogadores que já foram selecionados.
 */
function adicionarJogadorNaEdicao() {
    const container = document.getElementById('edit-jogadores-container');
    const jogadorRows = container.getElementsByClassName('edit-jogador-row');

    if (jogadorRows.length >= 4) {
        //alert("O limite de 4 jogadores por reserva foi atingido.");
		mostrarNotificacao("O limite de 4 jogadores por reserva foi atingido.", 'error');
        return;
    }

    // ==========================================================
    // INÍCIO DA LÓGICA DE FILTRAGEM
    // ==========================================================

    // 1. Coleta os apelidos de todos os jogadores já selecionados no modal
    const jogadoresJaSelecionados = [];
    const selectsAtuais = container.querySelectorAll('select');
    selectsAtuais.forEach(select => {
        // Ignora o "Convidado" para que possa ser selecionado múltiplas vezes
        if (select.value && select.value.toLowerCase() !== 'convidado') {
            jogadoresJaSelecionados.push(select.value);
        }
    });

    // ==========================================================
    // FIM DA LÓGICA DE FILTRAGEM
    // ==========================================================

    const newRow = document.createElement('div');
    newRow.className = 'edit-jogador-row';
    
    const novoSelect = document.createElement('select');
    // Popula o novo campo com a lista completa de jogadores
    novoSelect.innerHTML = document.getElementById('jogadorSelect').innerHTML;
	novoSelect.setAttribute('onchange', 'handleConvidadoSelect(this)');

    // Remove os jogadores já selecionados do novo campo
    jogadoresJaSelecionados.forEach(apelido => {
        const optionToRemove = novoSelect.querySelector(`option[value="${apelido}"]`);
        if (optionToRemove) {
            optionToRemove.remove();
        }
    });
    
    const removeButton = document.createElement('span');
    removeButton.className = 'remove-jogador-btn';
    removeButton.innerHTML = '&times;';
    removeButton.onclick = () => newRow.remove();

    newRow.appendChild(novoSelect);
    newRow.appendChild(removeButton);
    container.appendChild(newRow);
	atualizarEstiloSelectConvidado(novoSelect);
}



/**
 * Valida a regra "Otimização de Horários" (Inteligente/Dinâmica).
 * Ativa-se automaticamente em QUALQUER dia onde a janela de funcionamento for <= 4 horas.
 */
function validarOtimizacaoHorario(dia, hora, duracao, quadra) {
    // 1. Regra do "Mesmo Dia": Se for para hoje, libera (flexibilidade de última hora).
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0);
    const diaDaSemanaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay();
    
    // Calcula a data real da reserva
    let diff = dia - diaDaSemanaHoje;
    if (diff < 0) diff += 7;
    const dataDaReserva = new Date(hoje);
    dataDaReserva.setDate(hoje.getDate() + diff);

    if (dataDaReserva.getTime() === hoje.getTime()) {
        return true;
    }

    // 2. Verifica se a Otimização Global está ATIVA
    if (!otimizacaoGlobal.ativa) {
        return true;
    }
    
    // 3. Verifica se a QUADRA ESPECÍFICA está marcada
    const quadraKey = `Quadra-${quadra.split(' ')[1]}`; 
    if (!otimizacaoGlobal.quadras || !otimizacaoGlobal.quadras[quadraKey]) {
        return true; 
    }

    // 4. O CÉREBRO: Obtém os horários reais deste dia (Padrão ou Especial)
    const regrasDoDia = obterRegrasDeHorario(dataDaReserva);
    
    // Se estiver fechado, nem precisa validar (já não aparece na lista)
    if (regrasDoDia.status === 'fechado') return true;

    // 5. CÁLCULO DA JANELA
    const horasAbertas = regrasDoDia.fim - regrasDoDia.inicio;

    // Se a janela for maior que 4 horas, o dia é longo o suficiente, não aplica regras.
    if (horasAbertas > 4) {
        return true;
    }

    // --- REGRAS DINÂMICAS (Baseadas na Hora de Abertura 'H') ---
    const H = regrasDoDia.inicio; // Ex: se abre as 08:00, H = 8. Se abre as 18:00, H = 18.

    // REGRA 1: O "Buraco na Entrada" (H+1)
    // Ex: Se abre às 08:00, proíbe agendar às 09:00 (deixaria as 08:00 vaga).
    if (hora === H + 1) {
         const hAberturaStr = String(H).padStart(2, '0') + ":00";
         const hAlvoStr = String(H + 2).padStart(2, '0') + ":00";
         const hProibidaStr = String(hora).padStart(2, '0') + ":00";
         
         const mensagem = `
            <b>Otimização de Horários (Janela Curta)</b><br><br>
            Neste dia, a quadra funciona apenas por ${horasAbertas} horas.<br>
            Para evitar horários ociosos, não permitimos inícios às ${hProibidaStr}.<br><br>
            <i><b>Sugestão:</b> Tente agendar para começar às ${hAberturaStr} ou às ${hAlvoStr}.</i>
         `;
         return mensagem;
    }

    // REGRA 2: 1 Hora na Abertura (H+0)
    // Ex: Se abre às 08:00, proíbe 1h às 08:00.
    if (hora === H && duracao === 1) {
        const hAberturaStr = String(H).padStart(2, '0') + ":00";
        const mensagem = `
            <b>Otimização de Horários (Janela Curta)</b><br><br>
            Em dias de horário reduzido, reservar apenas 1 hora na abertura (${hAberturaStr}) prejudica a grade.<br><br>
            <i><b>Sugestão:</b> Priorize jogos de 2 horas neste horário.</i>
        `;
        return mensagem;
    }

    // REGRA 3: 1 Hora no Meio (H+2)
    // Ex: Se abre às 08:00, proíbe 1h às 10:00.
    if (hora === H + 2 && duracao === 1) {
        const hMeioStr = String(H + 2).padStart(2, '0') + ":00";
        const mensagem = `
            <b>Otimização de Horários (Janela Curta)</b><br><br>
            Reservar apenas 1 hora às ${hMeioStr} cria uma quebra na grade curta.<br><br>
            <i><b>Sugestão:</b> Priorize jogos de 2 horas neste horário.</i>
        `;
        return mensagem;
    }

    // REGRA 4: 1 Hora no Fim (H+3)
    // Ex: Se abre às 08:00, proíbe 1h às 11:00.
    if (hora === H + 3 && duracao === 1) {
        const hFimStr = String(H + 3).padStart(2, '0') + ":00";
        const mensagem = `
            <b>Otimização de Horários (Janela Curta)</b><br><br>
            Para maximizar o uso da quadra no horário curto, reservas de 1 hora não são permitidas às ${hFimStr}.<br><br>
            <i><b>Sugestão:</b> Verifique se há disponibilidade para 2 horas começando mais cedo.</i>
        `;
        return mensagem;
    }
    
    return true;
}




/* ================================================== */
/* === FUNÇÃO DE ANIVERSÁRIO (VERSÃO COM CHUVA DE CONFETES) === */
/* ================================================== */

function checarAniversario() {
    const jogadorLogado = localStorage.getItem('jogadorLogado');
    if (!jogadorLogado) return;

    const jogadorApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto === jogadorLogado
    );

    if (!jogadorApelido || !jogadoresData[jogadorApelido].niver) return;

    const niver = jogadoresData[jogadorApelido].niver; // Formato: "dd/mm/yyyy"
    if (niver.length < 10) return;

    const niverDiaMes = niver.substring(0, 5);

    const hoje = new Date();
    const hojeDia = String(hoje.getDate()).padStart(2, '0');
    const hojeMes = String(hoje.getMonth() + 1).padStart(2, '0');
    const hojeDiaMes = `${hojeDia}/${hojeMes}`;

    if (niverDiaMes == hojeDiaMes) {
        
        // --- 1. Inicia a CHUVA de confetes ---
        // Vamos guardar o ID do intervalo para podermos pará-lo depois
        const duration = 15 * 1000; // Duração total da animação em milissegundos
        const animationEnd = Date.now() + duration;
        let defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 1999 }; // zIndex baixo para ficar atrás do modal

        function randomInRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        const interval = setInterval(function() {
            let timeLeft = animationEnd - Date.now();
            if (timeLeft <= 0) {
                return clearInterval(interval);
            }
            let particleCount = 50 * (timeLeft / duration);
            // Lança os confetes
            confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 } }));
            confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 } }));
        }, 250);


        // --- 2. Aguarda um pouco para mostrar o cartão ---
        setTimeout(() => {
            // --- 3. Calcula a idade ---
            const anoNiver = parseInt(niver.substring(6, 10), 10);
            const mesNiver = parseInt(niver.substring(3, 5), 10) - 1;
            const diaNiver = parseInt(niver.substring(0, 2), 10);
            let idade = hoje.getFullYear() - anoNiver;
            if (hoje.getMonth() < mesNiver || (hoje.getMonth() === mesNiver && hoje.getDate() < diaNiver)) {
                idade--;
            }

            // --- 4. Prepara e exibe o modal ---
            const modal = document.getElementById('birthdayModalOverlay');
            const nomeSpan = document.getElementById('birthdayName');
            const idadeSpan = document.getElementById('birthdayAge');
            const closeButton = document.getElementById('closeBirthdayModal');

            nomeSpan.textContent = jogadorLogado.split(' ')[0];
            idadeSpan.textContent = idade;
            modal.style.display = 'flex';

            // --- 5. Define a ação de fechar o modal ---
            const fecharModal = () => {
                modal.style.display = 'none';
                // Para a chuva de confetes
                clearInterval(interval);
                
                // Dispara a explosão final de confetes!
                confetti({
                    particleCount: 200,
                    spread: 180,
                    startVelocity: 55,
                    zIndex: 9999 // zIndex alto para ficar na frente de tudo
                });
            };

            closeButton.onclick = fecharModal;
            modal.onclick = function(event) {
                if (event.target === modal) {
                    fecharModal();
                }
            };
        }, 1500); // Aumentei um pouco o atraso para dar tempo dos confetes começarem
    }
}

// ==========================================================
// ====== CÓDIGO DA FUNCIONALIDADE - RESULTADO PIRÂMIDE ======
// ==========================================================

// Variável global para guardar a referência da reserva em edição de resultado
let reservaResultadoEmEdicao = null;

function mostrarOpcoesPiramide(reserva, key, quadra, isParticipante, isDelegado) {
    // 1. FAXINA GERAL (Esta é a única novidade crítica)
    limparBotoesFantasmas();

    const modal = document.getElementById('modalAcoesReserva');
    if (!modal) return;

    const modalTitulo = modal.querySelector('h3');
    if (modalTitulo) modalTitulo.textContent = "Gerenciar Desafio Pirâmide";

    const btnVer = document.getElementById('btnModalVer');
    const btnExcluir = document.getElementById('btnModalExcluir');
    const btnCancelar = document.getElementById('btnModalCancelar');
    const btnDelegar = document.getElementById('btnModalDelegar');
    
    // --- LÓGICA DE EXIBIÇÃO ---

    // 1. Botão VER DETALHES
    btnVer.style.display = 'block';
    btnVer.textContent = "Ver Detalhes";
    btnVer.onclick = () => {
        exibirDetalhesReserva(reserva, key, quadra);
        fecharModalAcoes();
    };

    // 2. Botão DELEGAR (Lógica original completa)
    // Esconde por padrão, mostra só se cumprir requisitos
    btnDelegar.style.display = 'none';
    
    if ((!reserva.status || reserva.status === 'confirmada' || reserva.status === 'em_andamento') && 
        isPeriodoDaReservaAtivo(reserva) && 
        (isParticipante || isUsuarioAdmin() || isUsuarioArbitro())) {
        
        btnDelegar.style.display = 'block';
        btnDelegar.textContent = "Delegar Responsável"; // Garante texto correto
        btnDelegar.style.backgroundColor = "#6f42c1"; // Roxo
        btnDelegar.style.color = "white";

        btnDelegar.onclick = () => {
            fecharModalAcoes();
            // Busca a reserva mais atual na memória (segurança contra dados velhos)
            const reservaAtual = reservasPorQuadra[quadra] && reservasPorQuadra[quadra][key] ? reservasPorQuadra[quadra][key] : reserva;
            
            if (reservaAtual.delegado) {
                const nomeDelegado = capitalizarNome(reservaAtual.delegado);
                const mensagem = `O jogador <b>${nomeDelegado}</b> já foi delegado como responsável por lançar o resultado. Deseja substituí-lo?`;
                const acaoConfirmar = () => { abrirModalDelegacao(reservaAtual, key, quadra); };
                mostrarConfirmacao(mensagem, acaoConfirmar, null, 'warning');
            } else {
                abrirModalDelegacao(reservaAtual, key, quadra);
            }
        };
    }

    // 3. Botão RESULTADO (Criação Dinâmica)
    // Esconde botão de duplas se existir (limpeza extra)
    const btnResultadoDuplas = document.getElementById('btnModalResultadoDuplas');
    if (btnResultadoDuplas) btnResultadoDuplas.style.display = 'none';

    if (isParticipante || isUsuarioAdmin() || isUsuarioArbitro() || isDelegado) {
        // Cria o botão novo
        const btnResultado = document.createElement('button');
        btnResultado.id = 'btnModalResultado'; 
        btnResultado.className = 'btn-acao';
        
        // Define texto e cor baseada no status
        if (reserva.status === 'em_andamento') {
            btnResultado.textContent = 'Continuar Resultado';
            btnResultado.style.backgroundColor = '#ffc107'; // Amarelo
            btnResultado.style.color = 'black';
        } else if (reserva.status === 'resultado_pendente') {
            btnResultado.textContent = 'Editar Resultado';
            btnResultado.style.backgroundColor = '#ffc107';
            btnResultado.style.color = 'black';
        } else if (reserva.resultado) {
            btnResultado.textContent = 'Ver Resultado';
            btnResultado.style.backgroundColor = '#17a2b8'; // Azul
            btnResultado.style.color = 'white';
        } else {
            btnResultado.textContent = 'Informar Resultado';
            btnResultado.style.backgroundColor = '#ffc107'; 
            btnResultado.style.color = 'black';
        }

        // Ação do botão
        btnResultado.onclick = async () => { 
            await abrirModalResultado(reserva, key, quadra, !!reserva.resultado); 
            fecharModalAcoes();
        };

        // Insere no DOM (Logo após o Ver Detalhes)
        if (btnVer && btnVer.parentNode) {
            btnVer.parentNode.insertBefore(btnResultado, btnVer.nextSibling);
        }
    }

    // 4. Botão EXCLUIR (Lógica original completa)
    // Verifica data futura
    const agora = new Date();
    const tabela = document.getElementById('tabelaQuadra');
    let dataString = "";
    if (tabela && tabela.rows.length > 1 && tabela.rows[1].cells[reserva.dia - 1]) {
        dataString = tabela.rows[1].cells[reserva.dia - 1].textContent;
    } else {
        // Fallback seguro
        dataString = new Date().toLocaleDateString('pt-BR');
    }

    const [dia, mes, ano] = dataString.split('/');
    const anoCompleto = ano.length === 2 ? "20" + ano : ano;
    const horaFim = reserva.hora + (reserva.duracao || 1); 
    const dataHoraFimReserva = new Date(anoCompleto, mes - 1, dia, horaFim, 0, 0);

    const isJogoFuturo = agora < dataHoraFimReserva;
    
    // Regra de Permissão
    const temPermissaoParaExcluir = (isUsuarioAdmin() || isParticipante) && (isJogoFuturo || vPermitirExclusaoAposJogo || isUsuarioAdmin());
    
    if (temPermissaoParaExcluir) {
        btnExcluir.style.display = 'block';
        btnExcluir.textContent = "Excluir Reserva"; // Texto claro
        btnExcluir.style.backgroundColor = "#dc3545"; // Vermelho
        btnExcluir.style.color = "white";
        
        btnExcluir.onclick = () => {
            fecharModalAcoes();
            const mensagem = "Você tem certeza que deseja excluir esta reserva?";
            const acaoAoConfirmar = () => {
                excluirReserva(reserva.hora - 6, reserva.dia);
            };
            mostrarConfirmacao(mensagem, acaoAoConfirmar, null, 'danger'); 
        };
    } else {
        btnExcluir.style.display = 'none';
    }

    // 5. Botão CANCELAR
    btnCancelar.style.display = 'block';
    btnCancelar.textContent = "Cancelar";
    btnCancelar.onclick = fecharModalAcoes;

    // Fecha ao clicar fora
    modal.onclick = (event) => {
        if (event.target === modal) {
            fecharModalAcoes();
        }
    };

    modal.style.display = 'flex';
}






/**
 * Reseta a interface do modal de resultado para o modo padrão de "Jogo Normal".
 * Se estiver editando um resultado (ex: árbitro), restaura os dados originais.
 */
function resetarParaModoPlacar() {
    modoResultado = 'placar';
    
    // 1. Visualização (Súmula ou Arbitragem)
    const chkArb = document.getElementById('chk-modo-arbitragem');
    const isArbitragem = chkArb && chkArb.checked;

    if (isArbitragem) {
        document.getElementById('placar-fields-container').style.display = 'flex'; 
        document.getElementById('simple-score-container').style.display = 'none';
    } else {
        document.getElementById('placar-fields-container').style.display = 'none';
        document.getElementById('simple-score-container').style.display = 'block';
    }
    
    // Layout Reset
    const winnerDisplay = document.querySelector('.winner-display');
    if (winnerDisplay) winnerDisplay.style.display = 'block';
    
    const actionsDiv = document.querySelector('.modern-actions');
    if (actionsDiv) actionsDiv.style.marginTop = ''; 

    setPlacarFieldsState(false); 
    document.getElementById('wo-controls').style.display = 'none';
    document.getElementById('desistencia-controls').style.display = 'none';

    // Reset Labels
    document.querySelector('label[for="select-vencedor-wo"]').textContent = 'Vencedor:';
    document.querySelector('label[for="select-desistente"]').textContent = 'Quem venceu?';
    document.getElementById('label-vencedor-final').textContent = 'VENCEDOR DA PARTIDA';
    document.querySelector('#modalResultadoPiramide h3').textContent = 'Súmula';

    // --- LÓGICA DE RESTAURAÇÃO ---
    const r = reservaResultadoEmEdicao ? reservaResultadoEmEdicao.reserva.resultado : null;

    // >>> CORREÇÃO AQUI: Permite restaurar se for 'Placar Normal' OU 'Desistência' <<<
    // Apenas W.O. é bloqueado (pois não tem placar)
    if (r && r.tipo !== 'W.O.') {
        
        if (r.set1 && r.set1.placar) {
            [document.getElementById('set1-j1').value, document.getElementById('set1-j2').value] = r.set1.placar.split('x');
            if (r.set1.tiebreak) {
                [document.getElementById('tb1-j1').value, document.getElementById('tb1-j2').value] = r.set1.tiebreak.split('-');
            }
        }
        if (r.set2 && r.set2.placar) {
            [document.getElementById('set2-j1').value, document.getElementById('set2-j2').value] = r.set2.placar.split('x');
            if (r.set2.tiebreak) {
                [document.getElementById('tb2-j1').value, document.getElementById('tb2-j2').value] = r.set2.tiebreak.split('-');
            }
        }
        if (r.set3) {
            [document.getElementById('set3-j1').value, document.getElementById('set3-j2').value] = r.set3.split('x');
        }
        
        restoreUnsavedScores(); // Restaura backup se houver
        sincronizarParaSumula(); // Joga nos campos visíveis
        calcularVencedorPiramide(); // Atualiza visual

    } else {
        // Se for Novo Jogo ou W.O. -> Zera tudo
        document.getElementById('resultado-vencedor').textContent = '';
        
        // Zera Súmula e Arbitragem
        ['simple-s1-j1','simple-s1-j2','simple-s2-j1','simple-s2-j2','simple-s3-j1','simple-s3-j2',
         'set1-j1','set1-j2','set2-j1','set2-j2','set3-j1','set3-j2'].forEach(id => {
             const el = document.getElementById(id);
             if(el) el.value = '0';
        });
        
        ['simple-tb1-j1','simple-tb1-j2','simple-tb2-j1','simple-tb2-j2',
         'tb1-j1','tb1-j2','tb2-j1','tb2-j2'].forEach(id => {
             const el = document.getElementById(id);
             if(el) el.value = '0';
        });

        verificarTieBreakManual(1); 
        verificarTieBreakManual(2); 
        verificarNecessidadeSet3();
        
        calcularVencedorPiramide();
    }

    // Atualiza se o botão é "Salvar" ou "Parciais"
    const temVencedor = document.getElementById('resultado-vencedor').textContent !== '';
    atualizarBotaoSalvarResultado(temVencedor);
}



// Ação do botão "Voltar ao Jogo"
const btnVoltarJogo = document.getElementById('acao-voltar-jogo');
if (btnVoltarJogo) {
    btnVoltarJogo.addEventListener('click', function(e) {
        e.preventDefault();
        resetarParaModoPlacar(); // Restaura a tela de súmula/arbitragem
        document.getElementById('menu-opcoes-resultado').classList.remove('visivel');
    });
}

// ==============================================================================
// BLOCO DE LÓGICA PARA O MENU DE 3 OPÇÕES E CONTROLE DOS CAMPOS
// ==============================================================================

// Event listener para o botão de mais opções (⋮) - CORRIGIDO
document.getElementById('btn-mais-opcoes').addEventListener('click', function(e) {
    e.preventDefault();
    
    const menu = document.getElementById('menu-opcoes-resultado');
    const itemVoltar = document.getElementById('acao-voltar-jogo');
    const itemWo = document.getElementById('acao-wo');
    const itemDesistencia = document.getElementById('acao-desistencia');
    
    // Itens de configuração
    const itemArbitragem = document.getElementById('item-modo-arbitragem');
    const itemNoAd = document.getElementById('item-no-ad');

    // 1. Reseta: Esconde os botões de ação por padrão
    if (itemVoltar) itemVoltar.style.display = 'none';
    if (itemWo) itemWo.style.display = 'none';
    if (itemDesistencia) itemDesistencia.style.display = 'none';

    // 2. Aplica as regras de contexto
    if (modoResultado === 'wo' || modoResultado === 'desistencia') {
        // REGRA 2 e 3: Modos especiais mostram APENAS "Voltar ao Jogo"
        if (itemVoltar) itemVoltar.style.display = 'block';
        
        if (itemArbitragem) itemArbitragem.style.display = 'none';
        if (itemNoAd) itemNoAd.style.display = 'none';
        
    } else {
        // REGRA 1: Jogo Normal (Placar)
        
        // --- CORREÇÃO AQUI: NÃO FORÇA MAIS O DISPLAY FLEX ---
        // A visibilidade de itemArbitragem e itemNoAd agora é controlada
        // dinamicamente pela função 'calcularVencedorPiramide'
        // baseada se o jogo está concluído ou não.
        // ----------------------------------------------------

        // Verifica status do jogo
        const jogoComecou = typeof hasPlacarParcial === 'function' && hasPlacarParcial();
        
        // Verifica se já existe um vencedor definido na tela
        const elVencedor = document.getElementById('resultado-vencedor');
        const jogoFinalizado = elVencedor && elVencedor.textContent.trim() !== '' && elVencedor.textContent.trim() !== '-';

        if (jogoComecou) {
            // Jogo começou (> 0).
            // Só mostra DESISTÊNCIA se o jogo AINDA NÃO ACABOU.
            if (!jogoFinalizado && itemDesistencia) {
                itemDesistencia.style.display = 'block';
            }
        } else {
            // Jogo não começou (0x0): Mostra W.O.
            if (itemWo) itemWo.style.display = 'block';
        }
    }

    // 3. Abre/Fecha o menu
    if (menu) menu.classList.toggle('visivel');
});





// Event listener para a opção "W.O." - CORRIGIDO
document.getElementById('acao-wo').addEventListener('click', function(e) {
    e.preventDefault();
    modoResultado = 'wo';
	
    
    // 1. Esconde as áreas de placar (Arbitragem E Súmula)
    document.getElementById('placar-fields-container').style.display = 'none';
    document.getElementById('simple-score-container').style.display = 'none';
    
    // 2. Mostra o painel de W.O.
    document.getElementById('wo-controls').style.display = 'block';
    
    // 3. Esconde outros painéis
    document.getElementById('desistencia-controls').style.display = 'none';
    document.getElementById('menu-opcoes-resultado').classList.remove('visivel');
    
    // 4. Ajusta Títulos e Labels
    document.querySelector('#modalResultadoPiramide h3').textContent = 'W.O.'; // Muda título do modal
    document.getElementById('label-vencedor-final').textContent = 'VENCEDOR DA PARTIDA';

    // 5. Limpeza e Reset
    document.getElementById('select-vencedor-wo').value = '';
    document.getElementById('select-motivo-wo').value = '';
	document.getElementById('select-vencedor-wo').removeAttribute('style');
    document.getElementById('resultado-vencedor').textContent = '';
	
	document.querySelector('.winner-display').style.display = 'none';
	
    
    // Força botão "Salvar"
    atualizarBotaoSalvarResultado(true);
});



// Event listener para a opção "Desistência" - CORRIGIDO PARA SALVAR PLACAR
document.getElementById('acao-desistencia').addEventListener('click', function(e) {
    e.preventDefault();
    modoResultado = 'desistencia';
    
    // >>> CORREÇÃO CRÍTICA: SALVA OS DADOS DA SÚMULA ANTES DE ESCONDER <<<
    sincronizarParaArbitragem(); 
    // -------------------------------------------------------------------

    saveUnsavedScores(); // Mantém o backup extra
    
    document.getElementById('placar-fields-container').style.display = 'none';
    document.getElementById('simple-score-container').style.display = 'none';
    
    document.getElementById('desistencia-controls').style.display = 'block';
    document.getElementById('wo-controls').style.display = 'none';
    document.getElementById('menu-opcoes-resultado').classList.remove('visivel');
    
    document.querySelector('#modalResultadoPiramide h3').textContent = 'Desistência';
    document.querySelector('label[for="select-desistente"]').textContent = 'Quem venceu?';
    
    document.querySelector('.winner-display').style.display = 'none';
    document.querySelector('.modern-actions').style.marginTop = '-15px';

    // Limpeza
    const elSelect = document.getElementById('select-desistente');
    elSelect.value = '';
    elSelect.removeAttribute('style'); 
    
    document.getElementById('select-motivo-desistencia').value = '';
    document.getElementById('resultado-vencedor').textContent = '';
    
    atualizarBotaoSalvarResultado(true); 
});





// --- CORREÇÃO ---
// Atualiza o vencedor e também o botão de Salvar ao selecionar no menu de W.O.
// Event listener para o SELECT DE VENCEDOR POR W.O.
document.getElementById('select-vencedor-wo').addEventListener('change', function() {

    // --- NOVO: APLICA ESTILO DE VENCEDOR NO PRÓPRIO CAMPO ---
    if (this.value !== "") {
        this.style.color = '#27ae60';        // Texto Verde
        this.style.fontWeight = '800';       // Negrito Forte
        this.style.borderColor = '#27ae60';  // Borda Verde
        this.style.backgroundColor = '#eafaf1'; // Fundo Verde Bem Claro
    } else {
        // Reset se voltar para "Selecione..."
        this.style.color = '';
        this.style.fontWeight = '';
        this.style.borderColor = '';
        this.style.backgroundColor = '';
    }
    // ---------------------------------------------------------
    
    // Ação principal: Limpa o campo de exibição do vencedor
    // O nome só será exibido quando o Motivo for selecionado (próxima etapa)
    document.getElementById('resultado-vencedor').textContent = ''; 
    
    // Garante que o botão fique como "Salvar" (se o vencedor foi selecionado)
    const vencedorSelecionado = this.value !== '';
    atualizarBotaoSalvarResultado(vencedorSelecionado); 
});



// Event listener para o SELECT DE DESISTÊNCIA (AGORA SELECIONA O VENCEDOR)
document.getElementById('select-desistente').addEventListener('change', function() {
    
    // --- APLICA ESTILO DE VENCEDOR (VERDE/NEGRITO) ---
    if (this.value !== "") {
        this.style.color = '#27ae60';
        this.style.fontWeight = '800';
        this.style.borderColor = '#27ae60';
        this.style.backgroundColor = '#eafaf1';
    } else {
        this.style.color = '';
        this.style.fontWeight = '';
        this.style.borderColor = '';
        this.style.backgroundColor = '';
    }
    // -------------------------------------------------
    
    // Não precisamos mais preencher o 'resultado-vencedor' pois o painel está oculto
    document.getElementById('resultado-vencedor').textContent = '';
    
    atualizarBotaoSalvarResultado(true);
});




// Fecha o menu de opções se clicar fora dele
window.addEventListener('click', function(e) {
    const menu = document.getElementById('menu-opcoes-resultado');
    const botao = document.getElementById('btn-mais-opcoes');
    if (menu && botao && !menu.contains(e.target) && !botao.contains(e.target)) {
        menu.classList.remove('visivel');
    }
});







/**
 * Coleta, valida e salva o resultado.
 * LÓGICA HÍBRIDA:
 * - Modo Súmula: Exige que Vencedor salve + Status Pendente.
 * - Modo Arbitragem: Permite Operador salvar + Status Finalizada (Imediato).
 */
async function salvarResultadoPiramide() {
    // 0. Cancela o robô de auto-save para não atropelar a decisão manual
    if (debounceTimer) clearTimeout(debounceTimer);

    if (!reservaResultadoEmEdicao) {
        mostrarNotificacao("Erro interno. Tente fechar e reabrir a janela.", 'error');
        return; 
    }

    // Identifica o Modo (Súmula ou Arbitragem)
    const containerSumula = document.getElementById('simple-score-container');
    const isModoSumula = containerSumula && containerSumula.style.display !== 'none';
    const isModoArbitragem = !isModoSumula; 

    // Se estiver na Súmula, garante que os dados visuais vão para a memória
    if (isModoSumula) {
        sincronizarParaArbitragem();
        calcularVencedorPiramide();
    }

    const { reserva, key, quadra } = reservaResultadoEmEdicao;
    const btnSalvar = document.getElementById('btnSalvarResultado');
    const modoBotao = btnSalvar.textContent;

    // Helpers
    const getVal = (id) => { const el = document.getElementById(id); return el ? el.value : ""; };
    const getNum = (id) => parseInt(getVal(id).toString().split('(')[0]) || 0;

    let sacadorAtual = null;
    if (document.getElementById('server-marker-j1').innerHTML.trim() !== '') sacadorAtual = 'j1';
    else if (document.getElementById('server-marker-j2').innerHTML.trim() !== '') sacadorAtual = 'j2';

    // === CAMINHO A: SALVAR PARCIAIS (Botão Azul) ===
    if (modoBotao === 'Parciais') {
        // (Lógica de parciais mantida idêntica à original)
        try {
            const s1_1 = getNum('set1-j1'); const s1_2 = getNum('set1-j2');
            const isTb1 = (s1_1 === 6 && s1_2 === 6) || (s1_1 === 7 && s1_2 === 6) || (s1_1 === 6 && s1_2 === 7);
            const s2_1 = getNum('set2-j1'); const s2_2 = getNum('set2-j2');
            const isTb2 = (s2_1 === 6 && s2_2 === 6) || (s2_1 === 7 && s2_2 === 6) || (s2_1 === 6 && s2_2 === 7);
            const valS3_1 = getVal('set3-j1'); const valS3_2 = getVal('set3-j2');

            const resultadoParcialData = {
                tipo: 'Placar Normal', vencedor: '', perdedor: '', sacador: sacadorAtual,
                isMatchPoint: verificarMatchPoint(),
                pontos: { j1: document.getElementById('pontos-j1').textContent, j2: document.getElementById('pontos-j2').textContent, isTieBreak: estadoPontos.tiebreakMode },
                set1: { placar: `${getVal('set1-j1')}x${getVal('set1-j2')}`, tiebreak: (isTb1) ? `${getVal('tb1-j1')}-${getVal('tb1-j2')}` : "" },
                set2: { placar: `${getVal('set2-j1')}x${getVal('set2-j2')}`, tiebreak: (isTb2) ? `${getVal('tb2-j1')}-${getVal('tb2-j2')}` : "" },
                set3: (valS3_1 !== "" && valS3_2 !== "") ? `${valS3_1}x${valS3_2}` : ""
            };
            const updates = {};
            const path1 = `sistemas/reservas/${quadra}/${key}`;
            updates[`${path1}/status`] = 'em_andamento';
            updates[`${path1}/resultado`] = resultadoParcialData;
            if (reserva.duracao > 1) {
                const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                updates[`sistemas/reservas/${quadra}/${key2}/status`] = 'em_andamento';
                updates[`sistemas/reservas/${quadra}/${key2}/resultado`] = resultadoParcialData;
            }
            await database.ref().update(updates);
            atualizarIndicadorAba(quadra, true);
            mostrarNotificacao("Placar parcial salvo com sucesso!", 'success');
        } catch (error) { console.error(error); mostrarNotificacao("Erro ao salvar parcial.", 'error'); }

    // === CAMINHO B: SALVAR RESULTADO FINAL (Botão Verde) ===
    } else {
        const jogadorLogadoCompleto = localStorage.getItem('jogadorLogado');
        let resultadoData = {};

        try {
            if (modoResultado === 'placar') {
                calcularVencedorPiramide(); 
                const vencedorApelido = document.getElementById('resultado-vencedor').textContent; 
                
                if (!vencedorApelido || vencedorApelido === '-' || vencedorApelido === '') return mostrarNotificacao("O placar não define um vencedor.", 'warning');

                // Identifica Vencedor para validação (apenas no modo Súmula)
				let vencedorObj = jogadoresData[vencedorApelido];
				if (!vencedorObj) vencedorObj = Object.values(jogadoresData).find(j => j.nomeCompleto === vencedorApelido) || {};
				const vencedorNomeCompleto = vencedorObj.nomeCompleto || vencedorApelido;

                // >> VALIDAÇÃO DE PERMISSÃO <<
                if (isModoSumula) {
                    if (!isUsuarioAdmin() && !isUsuarioArbitro() && (jogadorLogadoCompleto.toUpperCase() !== vencedorNomeCompleto.toUpperCase())) {
                         return mostrarNotificacao("Modo Súmula: Apenas o vencedor pode salvar o resultado.", 'warning');
                    }
                }
                // No modo Arbitragem, qualquer operador pode salvar.

                // Validação de Placar (Tênis)
                const s1_1 = getNum('set1-j1'); const s1_2 = getNum('set1-j2');
                const s2_1 = getNum('set2-j1'); const s2_2 = getNum('set2-j2');
                const validarPlacarTenis = (s1, s2, nomeSet) => {
                    if (s1 === 7 && s2 === 7) { mostrarNotificacao(`${nomeSet}: 7x7 inválido.`, 'warning'); return false; }
                    if (s1 === 7 && s2 < 5) { mostrarNotificacao(`${nomeSet}: ${s1}x${s2} inválido.`, 'warning'); return false; }
                    if (s2 === 7 && s1 < 5) { mostrarNotificacao(`${nomeSet}: ${s1}x${s2} inválido.`, 'warning'); return false; }
                    return true;
                };
                if (!validarPlacarTenis(s1_1, s1_2, "1º Set")) return;
                if ((s2_1 > 0 || s2_2 > 0) && !validarPlacarTenis(s2_1, s2_2, "2º Set")) return;

                // Monta o objeto
                const isTb1 = (s1_1 === 6 && s1_2 === 6) || (s1_1 === 7 && s1_2 === 6) || (s1_1 === 6 && s1_2 === 7);
                const isTb2 = (s2_1 === 6 && s2_2 === 6) || (s2_1 === 7 && s2_2 === 6) || (s2_1 === 6 && s2_2 === 7);
                const valS3_1 = getVal('set3-j1'); const valS3_2 = getVal('set3-j2');
                
                const perdedorApelido = (vencedorApelido === reservaResultadoEmEdicao.jogador1 || vencedorNomeCompleto === jogadoresData[reservaResultadoEmEdicao.jogador1]?.nomeCompleto) 
                                        ? reservaResultadoEmEdicao.jogador2 : reservaResultadoEmEdicao.jogador1;

                resultadoData = {
                    tipo: 'Placar Normal',
                    vencedor: vencedorApelido, sacador: sacadorAtual, perdedor: perdedorApelido,
                    set1: { placar: `${getVal('set1-j1')}x${getVal('set1-j2')}`, tiebreak: (isTb1) ? `${getVal('tb1-j1')}-${getVal('tb1-j2')}` : "" },
                    set2: { placar: `${getVal('set2-j1')}x${getVal('set2-j2')}`, tiebreak: (isTb2) ? `${getVal('tb2-j1')}-${getVal('tb2-j2')}` : "" },
                    set3: (valS3_1 !== "" && valS3_2 !== "") ? `${valS3_1}x${valS3_2}` : ""
                };

            } else if (modoResultado === 'wo') {
                const vencedorApelido = document.getElementById('select-vencedor-wo').value;
                const motivo = document.getElementById('select-motivo-wo').value;
                if (!vencedorApelido || !motivo) return mostrarNotificacao("Preencha vencedor e motivo.", 'warning');
                
                // WO sempre requer validação de vencedor/admin, pois não é arbitrado ponto a ponto
                const vencedorInfo = jogadoresData[vencedorApelido];
                const vencedorNomeCompleto = vencedorInfo ? vencedorInfo.nomeCompleto : vencedorApelido;
                if (!isUsuarioAdmin() && !isUsuarioArbitro() && (jogadorLogadoCompleto.toUpperCase() !== vencedorNomeCompleto.toUpperCase())) {
                    return mostrarNotificacao("Atenção: Apenas o vencedor pode salvar.", 'warning');
                }
                resultadoData = {
                    tipo: 'W.O.', vencedorWo: vencedorApelido, motivoWo: motivo, vencedor: vencedorApelido,
                    perdedor: (vencedorApelido === reservaResultadoEmEdicao.jogador1) ? reservaResultadoEmEdicao.jogador2 : reservaResultadoEmEdicao.jogador1,
                };

            } else if (modoResultado === 'desistencia') {
                const vencedorApelido = document.getElementById('select-desistente').value;
                const motivo = document.getElementById('select-motivo-desistencia').value;
                const s1j1 = getVal('set1-j1'); const s1j2 = getVal('set1-j2');
                if (!vencedorApelido) return mostrarNotificacao("Selecione quem venceu.", 'warning');
                if (s1j1 === '' || s1j2 === '') return mostrarNotificacao("Preencha o placar parcial.", 'warning');
                if (!motivo) return mostrarNotificacao("Selecione o motivo.", 'warning');

                const desistente = (vencedorApelido === reservaResultadoEmEdicao.jogador1) ? reservaResultadoEmEdicao.jogador2 : reservaResultadoEmEdicao.jogador1;
                // Desistência também requer validação
                const vencedorInfo = jogadoresData[vencedorApelido];
                const vencedorNomeCompleto = vencedorInfo ? vencedorInfo.nomeCompleto : vencedorApelido;
                if (!isUsuarioAdmin() && !isUsuarioArbitro() && (jogadorLogadoCompleto.toUpperCase() !== vencedorNomeCompleto.toUpperCase())) {
                    return mostrarNotificacao("Atenção: Apenas o vencedor pode salvar.", 'warning');
                }
                const getTB = (id1, id2) => (getVal(id1) && getVal(id2)) ? `${getVal(id1)}-${getVal(id2)}` : "";
                resultadoData = {
                    tipo: 'Desistência', desistente: desistente, motivoDesistencia: motivo, vencedor: vencedorApelido,
                    perdedor: desistente, motivo: motivo, sacador: sacadorAtual,
                    set1: { placar: `${s1j1}x${s1j2}`, tiebreak: getTB('tb1-j1', 'tb1-j2') },
                    set2: { placar: `${getVal('set2-j1')}x${getVal('set2-j2')}`, tiebreak: getTB('tb2-j1', 'tb2-j2') },
                    set3: (getVal('set3-j1') && getVal('set3-j2')) ? `${getVal('set3-j1')}x${getVal('set3-j2')}` : ""
                };
            }

            // --- PULO DO GATO: Passamos a flag 'isModoArbitragem' ---
            // Se for arbitragem, a próxima função saberá que deve finalizar direto.
            await executarSalvamentoResultado(resultadoData, isModoArbitragem);
            
            fecharModalResultado();
            
        } catch(err) {
            console.error("ERRO AO SALVAR:", err);
            mostrarNotificacao("Erro ao salvar resultado: " + err.message, 'error');
        }
    }
}



/**
 * Executa o salvamento no Firebase.
 * ATUALIZADA: Aceita flag para finalizar direto (Arbitragem).
 */
/**
 * Executa o salvamento no Firebase.
 * ATUALIZADA: Lógica inteligente para o texto "Informado por".
 */
async function executarSalvamentoResultado(resultadoData, forcarFinalizacao = false) {
    if (!reservaResultadoEmEdicao) return;

    const jogadorLogadoCompleto = localStorage.getItem('jogadorLogado');
    const jogadorLogadoApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto.toUpperCase() === jogadorLogadoCompleto.toUpperCase()
    ) || jogadorLogadoCompleto;
    
    // --- ASSINATURA DA AUTORIA INTELIGENTE (AJUSTE SOLICITADO) ---
    const j1 = reservaResultadoEmEdicao.jogador1;
    const j2 = reservaResultadoEmEdicao.jogador2;

    // Verifica se quem está logado é um dos jogadores da partida
    const ehJogadorDaPartida = (jogadorLogadoApelido.toUpperCase() === j1.toUpperCase() || 
                                jogadorLogadoApelido.toUpperCase() === j2.toUpperCase());

    let informante = jogadorLogadoApelido;

    if (isUsuarioAdmin()) {
        // Se for Admin: "Informado por Admin: Nome"
        informante = `Admin: ${jogadorLogadoApelido}`;
    } else if (ehJogadorDaPartida) {
        // Se for Jogador: "Informado por: Nome" (Adicionei o ':' para ficar igual ao seu pedido)
        informante = `: ${jogadorLogadoApelido}`;
    } else {
        // Se não é Admin nem Jogador, é Delegado/Árbitro: "Informado por Árbitro: Nome"
        informante = `Árbitro: ${jogadorLogadoApelido}`;
    }
    
    resultadoData.informadoPor = informante;
    resultadoData.dataInformado = new Date().toISOString();

    const { reserva, key, quadra } = reservaResultadoEmEdicao;
    const updates = {};
    const path1 = `sistemas/reservas/${quadra}/${key}`;

    // --- DECISÃO DE STATUS ---
    let novoStatus;
    let executarFinalizacaoDireta = false;
    let mensagemSucesso = '';

    // A. Resolução de Disputa
    if ((isUsuarioAdmin() || isUsuarioArbitro()) && reserva.status === 'resultado_recusado') {
        novoStatus = 'finalizada';
        executarFinalizacaoDireta = true;
        mensagemSucesso = "Disputa resolvida! Resultado finalizado.";
    } 
    // B. MODO ARBITRAGEM -> Finaliza direto!
    else if (forcarFinalizacao) {
        novoStatus = 'finalizada';
        executarFinalizacaoDireta = true;
        mensagemSucesso = "Jogo finalizado pelo Árbitro com sucesso!";
    }
    // C. MODO SÚMULA (Padrão) -> Fica Pendente
    else {
        novoStatus = 'resultado_pendente';
        executarFinalizacaoDireta = false;
        mensagemSucesso = "Resultado salvo! Aguardando confirmação do oponente.";
    }

    updates[`${path1}/status`] = novoStatus;
    updates[`${path1}/resultado`] = resultadoData;

    if (reserva.duracao > 1) {
        const key2 = `${reserva.dia}_${reserva.hora + 1}`;
        updates[`sistemas/reservas/${quadra}/${key2}/status`] = novoStatus;
        updates[`sistemas/reservas/${quadra}/${key2}/resultado`] = resultadoData;
    }
    
    if (reserva.delegado) {
        updates[`${path1}/delegado`] = null;
        if (reserva.duracao > 1) {
            const key2 = `${reserva.dia}_${reserva.hora + 1}`;
            updates[`sistemas/reservas/${quadra}/${key2}/delegado`] = null;
        }
    }

    if (executarFinalizacaoDireta) {
        const tempReserva = { ...reserva, resultado: resultadoData };
        const rankUpdates = processarTrocaDeRanking(tempReserva);
        
        let textoDecisao = "confirmado";
        if (isUsuarioAdmin()) textoDecisao = "aprovado pelo Administrador";
        else if (forcarFinalizacao) textoDecisao = "finalizado pelo Árbitro de Cadeira";

        const notificacaoUpdates = enviarNotificacaoResultadoFinalizado(tempReserva, textoDecisao);
        
        Object.assign(updates, rankUpdates, notificacaoUpdates);
    }

    try {
        await database.ref().update(updates);
		atualizarIndicadorAba(quadra, false); 
        mostrarNotificacao(mensagemSucesso, 'success');
        fecharModalResultado();
    } catch (error) {
        console.error("Erro ao salvar resultado:", error);
        mostrarNotificacao("Ocorreu um erro ao salvar. Tente novamente.", 'error');
    }
}



/**
 * Fecha o modal de resultado e limpa a referência global. 
 */
// Função que fecha o modal (LIMPA)
function fecharModalResultado() {
    // Tenta sair da tela cheia apenas se estiver ativa
    if (document.fullscreenElement) {
        sairDaTelaCheia();
    }

    const modal = document.getElementById('modalResultadoPiramide');
    if (modal) {
        modal.style.display = 'none';
        modal.onclick = null;
        
        if (listenerTelaCheia) {
            modal.removeEventListener('click', listenerTelaCheia);
            modal.removeEventListener('touchstart', listenerTelaCheia);
            listenerTelaCheia = null;
        }
    }

    window.removeEventListener('resize', atualizarNomesPainelControle);

    try {
        reservaResultadoEmEdicao = null;
        if (typeof isArbitroEditing !== 'undefined') { isArbitroEditing = false; }
    } catch(e) {}
}




function fecharModalConfirmacaoResultado() {
    document.getElementById('modalConfirmacaoResultado').style.display = 'none';
}


// Adicione esta nova função ao seu script. Ela não irá interferir com a original.
function formatarNomeCompleto(nome) {
    if (!nome || typeof nome !== 'string') return "";
    // Esta versão garante a conversão para minúsculas antes de capitalizar
    return nome.toLowerCase().split(' ')
               .map(palavra => palavra.charAt(0).toUpperCase() + palavra.slice(1))
               .join(' ');
}



// COLE ESTAS 3 NOVAS FUNÇÕES NO FINAL DO SEU SCRIPT

/**
 * Verifica se o jogador logado precisa confirmar algum resultado pendente e mostra o modal.
 */
async function verificarConfirmacoesResultado(todasAsReservas) {
    const jogadorLogadoCompleto = localStorage.getItem('jogadorLogado');
    if (!jogadorLogadoCompleto) return;

    const jogadorLogadoApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto.toUpperCase() === jogadorLogadoCompleto.toUpperCase()
    );

    if (!jogadorLogadoApelido) return;

    const modal = document.getElementById('modalConfirmacaoResultado');
    
    for (const quadra in todasAsReservas) {
        const reservasDaQuadra = todasAsReservas[quadra];
        for (const key in reservasDaQuadra) {
            let reservaStale = reservasDaQuadra[key]; // Dados potencialmente desatualizados

            if (reservaStale.status === 'resultado_pendente' && reservaStale.resultado && 
                reservaStale.resultado.perdedor === jogadorLogadoApelido &&
                reservaStale.resultado.informadoPor !== jogadorLogadoApelido) { // Garante que não é o próprio informante
                
                // --- INÍCIO DA CORREÇÃO ---
                // Busca os dados mais recentes da reserva para evitar inconsistências
                const reservaRef = database.ref(`sistemas/reservas/${quadra}/${key}`);
                const snapshot = await reservaRef.once('value');
                const reserva = snapshot.val(); // Usa os dados frescos do banco

                if (!reserva || !reserva.resultado) continue; // Pula se a reserva foi alterada/removida

                const resumoPartida = document.getElementById('resumo-partida-confirmacao');
                const placarInformado = document.getElementById('placar-informado-confirmacao');
                
                resumoPartida.innerHTML = `
                    <strong>Quadra:</strong> ${quadra}<br>
                    <strong>Data:</strong> ${document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${reserva.dia})`).textContent}<br>
                    <strong>Vencedor:</strong> ${reserva.resultado.vencedor}
                `;
                
                // LÓGICA PARA RECONSTRUIR A ORDEM ORIGINAL DOS JOGADORES
                let jogador1Original, jogador2Original; 
                if (reserva.jogadores_completo) {
                    const jogadoresDaPartida = reserva.jogadores_completo.split(',').map(j => j.trim());
                    jogador1Original = jogadoresDaPartida[0];
                    jogador2Original = jogadoresDaPartida[1];
                } else {
                    // Fallback para reservas mais antigas sem o campo 'jogadores_completo'
                    jogador1Original = reserva.jogadores.split(',').map(j => j.trim())[0];
                    const keySegundaHora = `${reserva.dia}_${reserva.hora + 1}`;
                    const reservaSegundaParte = reservasDaQuadra[keySegundaHora];
                     if (reservaSegundaParte && reservaSegundaParte.jogadores) {
                        jogador2Original = reservaSegundaParte.jogadores.split(',').map(j => j.trim())[0];
                    } else {
                        // Se não for possível reconstruir, pula para evitar mais erros
                        console.error("Não foi possível reconstruir a lista de jogadores para a confirmação de resultado.", reserva);
                        continue; 
                    }
                }

                // CHAMADA CORRIGIDA: Usa a ordem original dos jogadores
                placarInformado.innerHTML = gerarPlacarHtml(reserva.resultado, jogador1Original, jogador2Original);
                // --- FIM DA CORREÇÃO ---

                document.getElementById('btnAprovarResultado').onclick = () => aprovarResultado(key, quadra);
                document.getElementById('btnRecusarResultado').onclick = () => recusarResultado(key, quadra);
                document.getElementById('btnDepoisResultado').onclick = fecharModalConfirmacaoResultado;
                
                modal.style.display = 'flex';
                return; 
            }
        }
    }
}



/**
 * Altera o status da reserva para 'finalizada' quando o perdedor aprova.
 */
async function aprovarResultado(reservaKey, quadra) {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    try {
        const reservaRef = database.ref(`sistemas/reservas/${quadra}/${reservaKey}`);
        const snapshot = await reservaRef.once('value');
        const reserva = snapshot.val();

        		
		if (!reserva) {
			mostrarNotificacao("Erro: A reserva não foi encontrada.", 'error');
			document.getElementById('modalConfirmacaoResultado').style.display = 'none';
			return;
		}

        let updates = {};
        // 1. Prepara a atualização do status da reserva
        updates[`sistemas/reservas/${quadra}/${reservaKey}/status`] = 'finalizada';
        if (reserva.duracao > 1) {
            const key2 = `${reserva.dia}_${reserva.hora + 1}`;
            updates[`sistemas/reservas/${quadra}/${key2}/status`] = 'finalizada';
        }

        // 2. Chama a nova função para obter as atualizações de ranking
        const rankUpdates = processarTrocaDeRanking(reserva);
        // 3. Combina todas as atualizações em um único objeto
        updates = { ...updates, ...rankUpdates };

        await database.ref().update(updates);
        //alert("Resultado confirmado com sucesso!");
		mostrarNotificacao("Resultado confirmado com sucesso!", 'success');
        document.getElementById('modalConfirmacaoResultado').style.display = 'none';

    } catch (error) {
        //alert("Erro ao confirmar o resultado. Tente novamente.");
		mostrarNotificacao("Erro ao confirmar o resultado. Tente novamente.", 'error');
        console.error("Erro em aprovarResultado:", error);
    }
}

/**
 * Altera o status da reserva para 'resultado_recusado' quando o perdedor recusa.
 */
async function recusarResultado(reservaKey, quadra) {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    const mensagem = "Tem certeza que deseja recusar este resultado?<br><br>A disputa deverá ser resolvida com o Árbitro.";
    
    const acaoAoConfirmar = async () => {
        // --- TODA A LÓGICA ORIGINAL QUE VINHA DEPOIS DO 'CONFIRM' ESTÁ AQUI DENTRO ---
        try {
            const reservaRef = database.ref(`sistemas/reservas/${quadra}/${reservaKey}`);
            const snapshot = await reservaRef.once('value');
            const reserva = snapshot.val();

            if (!reserva) {
                mostrarNotificacao("Erro: A reserva não foi encontrada. Ela pode ter sido excluída por outro jogador.", 'error');
                document.getElementById('modalConfirmacaoResultado').style.display = 'none';
                return;
            }

            const updates = {};
            updates[`sistemas/reservas/${quadra}/${reservaKey}/status`] = 'resultado_recusado';
            if (reserva.duracao > 1) {
                const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                updates[`sistemas/reservas/${quadra}/${key2}/status`] = 'resultado_recusado';
            }
        
            await database.ref().update(updates);
            mostrarNotificacao("Resultado recusado. O status foi atualizado para que o Árbitro possa resolver a disputa.", 'warning');
            document.getElementById('modalConfirmacaoResultado').style.display = 'none';
        } catch (error) {
            mostrarNotificacao("Erro ao recusar o resultado. Tente novamente.", 'error');
            console.error("Erro em recusarResultado:", error);
        }
    };

    mostrarConfirmacao(mensagem, acaoAoConfirmar);
}


// Adicione esta nova função ao seu script

/**
 * Gera o HTML do placar profissional com base nos dados da reserva.
 * @param {object} resultado - O objeto de resultado da reserva.
 * @param {string} jogador1Apelido - O apelido de um dos jogadores.
 * @param {string} jogador2Apelido - O apelido do outro jogador.
 * @returns {string} - O HTML completo do placar.
 */

// VERSÃO FINAL E COMPLETA DA FUNÇÃO - SUBSTITUA A SUA ATUAL POR ESTA

// SUBSTITUA A FUNÇÃO gerarPlacarHtml COMPLETA POR ESTA:
function gerarPlacarHtml(resultado, jogador1Apelido, jogador2Apelido) {
    if (!resultado) return "";
    
    // --- 1. Busca Dados ---
    const getInfo = (apelido) => {
        if (!apelido) return null;
        const key = Object.keys(jogadoresData).find(k => k.toUpperCase() === apelido.toUpperCase());
        return key ? jogadoresData[key] : null;
    };
    const j1Info = getInfo(jogador1Apelido);
    const j2Info = getInfo(jogador2Apelido);
    
    

    const isHorizontal = window.innerWidth > window.innerHeight;
	
    const j1NomeDisplay = formatarNomeInteligente(j1Info?.nomeCompleto || jogador1Apelido, jogador1Apelido, isHorizontal);
    const j2NomeDisplay = formatarNomeInteligente(j2Info?.nomeCompleto || jogador2Apelido, jogador2Apelido, isHorizontal);
	
    // --- 3. Vencedor ---
    const vencedorDoResultado = resultado.vencedor;
    let p1_is_match_winner = false;
    let p2_is_match_winner = false;
    if (jogador1Apelido.toUpperCase() === vencedorDoResultado.toUpperCase()) p1_is_match_winner = true;
    else if (jogador2Apelido.toUpperCase() === vencedorDoResultado.toUpperCase()) p2_is_match_winner = true;
    else {
        if (j1Info && j1Info.nomeCompleto.toUpperCase() === vencedorDoResultado.toUpperCase()) p1_is_match_winner = true;
        else if (j2Info && j2Info.nomeCompleto.toUpperCase() === vencedorDoResultado.toUpperCase()) p2_is_match_winner = true;
    }
    
    // --- 4. Ranking ---
    let posicaoHtmlP1 = '', posicaoHtmlP2 = '';
    if (j1Info && j1Info.piramide && j1Info.piramide !== "0") {
        const pp = parseInt(j1Info.piramide, 10);
        posicaoHtmlP1 = `<span class="placar-posicao">${pp >= 61 ? pp - 60 : pp}</span>`;
    }
    if (j2Info && j2Info.piramide && j2Info.piramide !== "0") {
        const pp = parseInt(j2Info.piramide, 10);
        posicaoHtmlP2 = `<span class="placar-posicao">${pp >= 61 ? pp - 60 : pp}</span>`;
    }

    // --- 5. Scores ---
    const scoresP1 = [];
    const scoresP2 = [];
    ['set1', 'set2', 'set3'].forEach(setKey => {
		const setData = resultado[setKey];
		if (setData && (setData.placar || typeof setData === 'string')) {
			const setPlacar = typeof setData === 'string' ? setData : setData.placar;
			if (setPlacar.includes('x')) {
				const [s1, s2] = setPlacar.split('x').map(Number);
				let classP1 = '', classP2 = '', tb1_html = '', tb2_html = '';
				if (setKey === 'set3') {
					if (s1 >= 10 && (s1 - s2) >= 2) classP1 = 'winner';
					else if (s2 >= 10 && (s2 - s1) >= 2) classP2 = 'winner';
				} else {
					let tb1 = NaN, tb2 = NaN;
					if (typeof setData === 'object' && setData.tiebreak && setData.tiebreak.includes('-')) {
						[tb1, tb2] = setData.tiebreak.split('-').map(Number);
						tb1_html = `<sup>${tb1}</sup>`; tb2_html = `<sup>${tb2}</sup>`;
					}
					const vencedorDoSet = determinarVencedorSet(s1, s2, tb1, tb2);
					if (vencedorDoSet === 'j1') classP1 = 'winner';
					if (vencedorDoSet === 'j2') classP2 = 'winner';
				}
				scoresP1.push(`<span class="set-score ${classP1}">${s1}${tb1_html}</span>`);
				scoresP2.push(`<span class="set-score ${classP2}">${s2}${tb2_html}</span>`);
			}
		}
	});

	const motivoTexto = resultado.motivo || resultado.motivoWo || resultado.motivoDesistencia;
	const motivoHtml = motivoTexto ? `<p class="motivo-resultado">Motivo: ${motivoTexto}</p>` : '';

    // --- 6. Rodapé "Informado por" (ATUALIZADO COM QUEBRA INTELIGENTE) ---
    let footerHtml = '';
    if (resultado.informadoPor && resultado.dataInformado) {
        const dataInfo = new Date(resultado.dataInformado).toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
        
        // AQUI ESTÁ O TRUQUE: Insere a quebra após os dois pontos
        const informadoPorFormatado = resultado.informadoPor.replace(':', ':<span class="break-mobile"></span>');
        
        footerHtml = `<p style="text-align: center; font-size: 0.8em; color: #888; margin-top: 15px;">Informado por ${informadoPorFormatado} em ${dataInfo}.</p>`;
    }
    // ----------------------------------------

    if (resultado.tipo === 'W.O.') {
        return `<div class="placar-container"><div class="placar-row">${posicaoHtmlP1}<span class="placar-nome ${p1_is_match_winner?'match-winner':''}">${j1NomeDisplay}</span><span class="placar-sets">${p1_is_match_winner?'<span class="set-score winner">W.O.</span>':''}</span></div><div class="placar-row">${posicaoHtmlP2}<span class="placar-nome ${p2_is_match_winner?'match-winner':''}">${j2NomeDisplay}</span><span class="placar-sets">${p2_is_match_winner?'<span class="set-score winner">W.O.</span>':''}</span></div></div>${motivoHtml}${footerHtml}`;
    }
    if (resultado.tipo === 'Desistência') {
        const p1_is_loser = jogador1Apelido.toUpperCase() === resultado.perdedor.toUpperCase(); 
        const p2_is_loser = jogador2Apelido.toUpperCase() === resultado.perdedor.toUpperCase(); 
        return `<div class="placar-container"><div class="placar-row">${posicaoHtmlP1}<span class="placar-nome ${p1_is_match_winner?'match-winner':''}">${j1NomeDisplay}</span>${p1_is_loser?'<span class="ret-indicator">RET</span>':''}<span class="placar-sets">${scoresP1.join('')}</span></div><div class="placar-row">${posicaoHtmlP2}<span class="placar-nome ${p2_is_match_winner?'match-winner':''}">${j2NomeDisplay}</span>${p2_is_loser?'<span class="ret-indicator">RET</span>':''}<span class="placar-sets">${scoresP2.join('')}</span></div></div>${motivoHtml}${footerHtml}`;
    }

    return `<div class="placar-container"><div class="placar-row">${posicaoHtmlP1}<span class="placar-nome ${p1_is_match_winner?'match-winner':''}">${j1NomeDisplay}</span><span class="placar-sets">${scoresP1.join('')}</span></div><div class="placar-row">${posicaoHtmlP2}<span class="placar-nome ${p2_is_match_winner?'match-winner':''}">${j2NomeDisplay}</span><span class="placar-sets">${scoresP2.join('')}</span></div></div>${footerHtml}`;
}





// COLE ESTA FUNÇÃO QUE ESTÁ FALTANDO NO SEU SCRIPT
function getDisplayRank(piramidePosStr) {
    if (!piramidePosStr || piramidePosStr === "0") {
        return null;
    }
    const piramidePos = parseInt(piramidePosStr, 10);
    if (isNaN(piramidePos)) {
        return null;
    }
    // Se a posição for 61 ou maior, subtrai 60 para obter o rank real da pirâmide feminina
    return piramidePos >= 61 ? piramidePos - 60 : piramidePos;
}

// Adicione esta nova função ao seu script
/**
 * Processa a lógica de troca de ranking de uma partida finalizada.
 * @param {object} reserva - O objeto da reserva contendo o resultado.
 * @returns {object} - Um objeto com as atualizações do banco de dados para os rankings, ou um objeto vazio se não houver troca.
 */
function processarTrocaDeRanking(reserva) {
    const rankUpdates = {};
    if (!reserva || !reserva.resultado) return rankUpdates;

    const vencedorApelido = reserva.resultado.vencedor;
    const perdedorApelido = reserva.resultado.perdedor;

    const vencedorInfo = jogadoresData[vencedorApelido];
    const perdedorInfo = jogadoresData[perdedorApelido];

    // Garante que ambos os jogadores foram encontrados e possuem ranking
    if (vencedorInfo && perdedorInfo && vencedorInfo.piramide && perdedorInfo.piramide && vencedorInfo.piramide !== "0" && perdedorInfo.piramide !== "0") {
        const rankVencedor = parseInt(vencedorInfo.piramide, 10);
        const rankPerdedor = parseInt(perdedorInfo.piramide, 10);

        // A troca só acontece se o vencedor tiver um ranking inferior (número MAIOR) ao do perdedor.
        if (rankVencedor > rankPerdedor) {
            console.log(`Troca de ranking ativada: ${vencedorApelido} (${rankVencedor}) venceu ${perdedorApelido} (${rankPerdedor}).`);

            rankUpdates[`sistemas/cadastro/jogadores/${vencedorInfo.nomeCompleto}/piramide`] = perdedorInfo.piramide;
            rankUpdates[`sistemas/cadastro/jogadores/${perdedorInfo.nomeCompleto}/piramide`] = vencedorInfo.piramide;
        }
    }
    return rankUpdates;
}


// Adicione estas duas novas funções ao seu script

/**
 * Fecha o modal de resolução do árbitro.
 */
function fecharModalArbitro() {
    document.getElementById('modalResolucaoArbitro').style.display = 'none';
}



/**
 * Ação do árbitro para APROVAR um resultado recusado.
 */
async function aprovarPeloArbitro(reservaKey, quadra) {
    const mensagem = "Tem certeza que deseja APROVAR este resultado?<br><br>A partida será finalizada e os jogadores notificados.";

    const acaoAoConfirmar = async () => {
       try {
            const reservaRef = database.ref(`sistemas/reservas/${quadra}/${reservaKey}`);
            const snapshot = await reservaRef.once('value');
            const reserva = snapshot.val();

            if (!reserva) {
                mostrarNotificacao("Erro: Reserva não encontrada.", 'error');
                return;
            }

            let updates = {};
            updates[`sistemas/reservas/${quadra}/${reservaKey}/status`] = 'finalizada';
            if (reserva.duracao > 1) {
                const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                updates[`sistemas/reservas/${quadra}/${key2}/status`] = 'finalizada';
            }

            const rankUpdates = processarTrocaDeRanking(reserva);
            const decisao = isUsuarioAdmin() ? "aprovado pelo Administrador" : "aprovado pelo Árbitro";
            const notificacaoUpdates = enviarNotificacaoResultadoFinalizado(reserva, decisao);
            
            updates = { ...updates, ...rankUpdates, ...notificacaoUpdates };

            await database.ref().update(updates);
            mostrarNotificacao("Resultado aprovado e finalizado com sucesso! Os jogadores serão notificados.", 'success');
            fecharModalArbitro();
        } catch (error) {
            mostrarNotificacao("Ocorreu um erro ao aprovar o resultado.", 'error');
            console.error("Erro em aprovarPeloArbitro:", error);
        }
    };

    // 2. Chama o nosso novo modal de confirmação
    mostrarConfirmacao(mensagem, acaoAoConfirmar);
}



/**
 * Ação do árbitro para ABRIR A EDIÇÃO de um resultado recusado.
 */
async function editarPeloArbitro(reservaKey, quadra) {
    const reservaRef = database.ref(`sistemas/reservas/${quadra}/${reservaKey}`);
    const snapshot = await reservaRef.once('value');
    const reserva = snapshot.val();

    if (!reserva) {
        mostrarNotificacao("Erro: Reserva não encontrada.", 'error');
        return;
    }

    fecharModalArbitro();
    await abrirModalResultado(reserva, reservaKey, quadra, false);
}


/**
 * Ação do árbitro para CANCELAR uma partida com resultado recusado.
 */
async function cancelarPeloArbitro(reservaKey, quadra) {
    const mensagem = "Tem certeza que deseja CANCELAR esta partida?<br><br>O resultado será mantido no histórico, a partida será invalidada e os jogadores notificados.";
    const acaoAoConfirmar = async () => {
        try {
            const reservaRef = database.ref(`sistemas/reservas/${quadra}/${reservaKey}`);
            const snapshot = await reservaRef.once('value');
            const reserva = snapshot.val();

            if (!reserva) {
                mostrarNotificacao("Erro: Reserva não encontrada.", 'error');
                return;
            }

            const updates = {};
            updates[`sistemas/reservas/${quadra}/${reservaKey}/status`] = 'Cancelada';
            if (reserva.duracao > 1) {
                const key2 = `${reserva.dia}_${reserva.hora + 1}`;
                updates[`sistemas/reservas/${quadra}/${key2}/status`] = 'Cancelada';
            }

            const decisao = isUsuarioAdmin() ? "cancelado pelo Administrador" : "cancelado pelo Árbitro";
            const notificacaoUpdates = enviarNotificacaoResultadoFinalizado(reserva, decisao);
            
            Object.assign(updates, notificacaoUpdates);

            await database.ref().update(updates);
            mostrarNotificacao("Partida cancelada com sucesso! Os jogadores serão notificados.", 'success');
            fecharModalArbitro();
        } catch (error) {
            mostrarNotificacao("Ocorreu um erro ao cancelar a partida.", 'error');
            console.error("Erro em cancelarPeloArbitro:", error);
        }
    };

    // 2. Chama o nosso novo modal de confirmação
    mostrarConfirmacao(mensagem, acaoAoConfirmar);
}



// SUBSTITUA SUA FUNÇÃO 'verificarDisputasArbitro' PELA VERSÃO ABAIXO
function verificarDisputasArbitro(todasAsReservas) {
    // Usa a nova verificação baseada em perfil
    if (!isUsuarioArbitro()) {
        return;
    }

    const modal = document.getElementById('modalResolucaoArbitro');
    const resumoPartida = document.getElementById('resumo-partida-arbitro');
    const placarRecusado = document.getElementById('placar-recusado-arbitro');
    
    for (const quadra in todasAsReservas) {
        const reservasDaQuadra = todasAsReservas[quadra];
        for (const key in reservasDaQuadra) {
            const reserva = reservasDaQuadra[key];

            if (reserva.status === 'resultado_recusado' && reserva.resultado) {
                
                // Texto do Resumo
                let dataTexto = "Data desconhecida";
                try {
                     dataTexto = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${reserva.dia})`).textContent;
                } catch(e) {}

                resumoPartida.innerHTML = `
                    <strong>Quadra:</strong> ${quadra}<br>
                    <strong>Data:</strong> ${dataTexto}<br>
                    <strong>Vencedor Informado:</strong> ${reserva.resultado.vencedor}<br>
                    <strong>Recusado por:</strong> ${reserva.resultado.perdedor}
                `;

                // Reconstrói jogadores sem depender de variáveis legadas
                let jogador1Original = "Jogador 1", jogador2Original = "Jogador 2";
                if (reserva.jogadores_completo) {
                    const parts = reserva.jogadores_completo.split(',');
                    if (parts[0]) jogador1Original = parts[0].trim();
                    if (parts[1]) jogador2Original = parts[1].trim();
                } else if (reserva.jogadores) {
                    jogador1Original = reserva.jogadores.split(',')[0].trim();
                    // Tenta achar o 2º jogador na próxima hora se for reserva antiga
                    const keySegundaHora = `${reserva.dia}_${reserva.hora + 1}`;
                    if (reservasDaQuadra[keySegundaHora] && reservasDaQuadra[keySegundaHora].jogadores) {
                        jogador2Original = reservasDaQuadra[keySegundaHora].jogadores.split(',')[0].trim();
                    }
                }
                
                placarRecusado.innerHTML = gerarPlacarHtml(reserva.resultado, jogador1Original, jogador2Original);

                document.getElementById('btnAprovarPeloArbitro').onclick = () => aprovarPeloArbitro(key, quadra);
                document.getElementById('btnEditarPeloArbitro').onclick = () => editarPeloArbitro(key, quadra);
                document.getElementById('btnCancelarPeloArbitro').onclick = () => cancelarPeloArbitro(key, quadra);
                document.getElementById('btnFecharArbitro').onclick = fecharModalArbitro;
                
                modal.style.display = 'flex';
                return;
            }
        }
    }
}



/**
 * Verifica se o jogador é Admin.
 * Atalho para a permissão mestre 'super_admin'.
 */
function isUsuarioAdmin() {
    return verificarPermissao('super_admin');
}


/**
 * Verifica se o usuário tem permissão de MANUTENÇÃO (Bloqueio de Quadras).
 * Baseado na permissão técnica 'controle_quadras' definida no banco.
 */
function isUsuarioManutencao() {
    return verificarPermissao('controle_quadras');
}


/**
 * Verifica se o jogador logado tem permissão de Árbitro (Gestor de Torneios).
 */
function isUsuarioArbitro() {
    // Agora verifica apenas a permissão do perfil, sem depender da variável antiga 'arbitro'
    return verificarPermissao('gestor_torneios');
}


/**
 * Verifica se o usuário logado é o Professor responsável pela quadra informada.
 * (Antiga isProfessorDaQuadra, renomeada para padronizar com isUsuario...)
 */
/**
 * Verifica se o usuário logado é o Professor responsável pela quadra informada.
 * CORREÇÃO: Agora verifica também o APELIDO para evitar erros com nomes do meio.
 */
/**
 * Verifica se o usuário logado é o Professor responsável pela quadra informada.
 * CORREÇÃO: Agora verifica também o APELIDO para casar "Adriano Feitosa" com a config.
 */
function isUsuarioProfessor(quadraNome) {
    if (!quadraNome) return false;

    // 1. Identifica a chave da quadra (Prioridade para 2 e 3)
    let quadraKey = "Quadra1"; // Padrão
    if (quadraNome.indexOf("2") !== -1) quadraKey = "Quadra2";
    else if (quadraNome.indexOf("3") !== -1) quadraKey = "Quadra3";

    // 2. Carrega Configuração Global
    if (typeof configAulasGlobal === 'undefined') return false;
    const config = configAulasGlobal[quadraKey];
    
    if (!config || !config.Professor) return false;

    const nomeLogado = localStorage.getItem('jogadorLogado');
    if (!nomeLogado) return false;

    const profConfig = config.Professor.toUpperCase().trim(); // Ex: "ADRIANO FEITOSA"
    const usuarioNome = nomeLogado.toUpperCase().trim();      // Ex: "ADRIANO GOMES FEITOSA"

    // 3. Validações

    // A. Comparação Direta
    if (profConfig === usuarioNome) return true;

    // B. Comparação por Inclusão
    if (usuarioNome.includes(profConfig)) return true;

    // C. Comparação por APELIDO (CORRIGIDO: Busca na chave do objeto)
    if (typeof jogadoresData !== 'undefined') {
        // Como 'apelido' virou chave, usamos Object.entries para recuperar [chave, valor]
        // Onde 'chave' é o Apelido e 'valor' contém o nomeCompleto
        const entry = Object.entries(jogadoresData).find(([nick, data]) => {
            return data.nomeCompleto && data.nomeCompleto.toUpperCase().trim() === usuarioNome;
        });
        
        if (entry) {
            const usuarioApelido = entry[0].toUpperCase().trim(); // A chave é o Apelido!
            
            // Verifica match do Apelido
            if (profConfig === usuarioApelido) return true;
            if (usuarioApelido.includes(profConfig) || profConfig.includes(usuarioApelido)) return true;
        }
    }

    return false;
}



// Pequena função auxiliar para criar pausas no código
const esperar = (ms) => new Promise(res => setTimeout(res, ms));

async function verificarNotificacoes() {
    const jogadorLogado = localStorage.getItem('jogadorLogado');
    if (!jogadorLogado) return;

    const notificacoesRef = database.ref(`sistemas/cadastro/jogadores/${jogadorLogado}/notificacoes`);
    
    try {
        const snapshot = await notificacoesRef.once('value');
        const notificacoes = snapshot.val();

        if (notificacoes) {
            // AGORA VAMOS PEGAR AS CHAVES E OS VALORES
            const listaDeNotificacoes = Object.entries(notificacoes);
            
            // Loop para mostrar cada notificação individualmente
            for (const [chave, notificacao] of listaDeNotificacoes) {
                if (notificacao && notificacao.mensagem && notificacao.tipo) {
                    mostrarNotificacao(notificacao.mensagem, notificacao.tipo);
                    
                    // A MÁGICA ESTÁ AQUI: APAGA A NOTIFICAÇÃO LOGO DEPOIS DE MOSTRAR
                    // Usamos a 'chave' específica de cada notificação para apagá-la
                    notificacoesRef.child(chave).remove();
                    
                    await esperar(4000); 
                }
            }
            
            // A linha "await notificacoesRef.remove();" não é mais necessária aqui,
            // pois já apagamos cada uma individualmente.
        }
    } catch (error) {
        console.error("Erro ao verificar notificações:", error);
        mostrarNotificacao("Não foi possível carregar suas notificações.", 'error');
    }
}




/**
 * Busca a próxima reserva, preenche o painel da agenda e retorna a reserva.
 * Esta função é chamada "sob demanda" (ao clicar no 📅).
 * @returns {object|null} - Retorna o objeto da próxima reserva ou null.
 */
// ATENÇÃO: Se você usa funções auxiliares como 'capitalizarNome' ou 'diasDaSemana',
// elas devem estar definidas em outro lugar do seu código.

// =================================================================
// FUNÇÃO CORRIGIDA: ATUALIZAR E EXIBIR PRÓXIMA RESERVA
// =================================================================
async function atualizarEExibirProximaReserva() {
    const agendaConteudo = document.getElementById('agenda-conteudo');
    const agendaTrigger = document.getElementById('agenda-trigger'); 

    if (!agendaConteudo) return null; 

    agendaConteudo.innerHTML = '<p class="agenda-nenhuma-reserva">Buscando sua próxima reserva...</p>';
    if (agendaTrigger) agendaTrigger.style.display = 'none';

    // 1. Limpa qualquer monitoramento anterior
    if (agendaListenerRef && agendaCallback) {
        agendaListenerRef.off('value', agendaCallback);
        agendaListenerRef = null;
        agendaCallback = null;
    }

    const jogadorLogadoCompleto = localStorage.getItem('jogadorLogado');

    // 2. Calcula o apelido a partir do Nome Completo
    if (!jogadorLogadoCompleto || Object.keys(jogadoresData).length === 0) {
        agendaConteudo.innerHTML = '<p class="agenda-nenhuma-reserva">Não foi possível identificar o usuário ou jogadores não carregados.</p>';
        return null;
    }

    const jogadorLogadoApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto.toUpperCase() === jogadorLogadoCompleto.toUpperCase()
    );

    if (!jogadorLogadoApelido) {
        agendaConteudo.innerHTML = '<p class="agenda-nenhuma-reserva">Apelido do usuário não encontrado no cadastro.</p>';
        return null;
    }
    
    // Busca inicial no Firebase
    const reservasRef = database.ref('sistemas/reservas');
    const snapshot = await reservasRef.once('value');
    const todasAsReservas = snapshot.val();

    if (!todasAsReservas) {
        agendaConteudo.innerHTML = '<p class="agenda-nenhuma-reserva">Nenhuma reserva futura agendada.</p>';
        if (agendaTrigger) agendaTrigger.style.display = 'flex';
        return null;
    }

    const hoje = new Date();
    const hojeIndex = hoje.getDay() === 0 ? 7 : hoje.getDay();
    // const horaAtual = hoje.getHours(); // Removido pois usaremos comparação de Data completa

    let proximaReserva = null;
    const quadras = ["Quadra 1 - Coberta", "Quadra 2 - Aberta", "Quadra 3 - Coberta"];

    // Lógica para encontrar a reserva mais próxima
    for (const quadra of quadras) {
        const reservasDaQuadra = todasAsReservas[quadra];
        if (!reservasDaQuadra) continue;

        for (const key in reservasDaQuadra) {
            const reserva = reservasDaQuadra[key];
            if (reserva.borda === undefined) continue;

            // =========================================================================
            //  CORREÇÃO DE DATA: Lógica robusta para detectar futuro/passado
            // =========================================================================
            const duracao = reserva.duracao === 3 ? 2 : (reserva.duracao || 1);
            
            // Calcula a diferença de dias (ex: Seg(1) - Dom(7) = -6)
            let diff = reserva.dia - hojeIndex;
            
            // --- ALTERAÇÃO AQUI ---
            // Removemos o "if (diff < 0) diff += 7;"
            // Isso impede que um jogo de ontem (diff = -1) seja jogado para a próxima semana.
            // Agora, se diff for negativo, a data calculada será no passado, e o filtro abaixo vai ignorá-la corretamente.
            // ----------------------

            // Cria uma data para o FINAL da reserva para comparar com AGORA
            const dataFimReserva = new Date(hoje);
            dataFimReserva.setDate(hoje.getDate() + diff);
            dataFimReserva.setHours(reserva.hora + duracao, 0, 0, 0);

            // Se a reserva termina antes de agora, ignora (é passado)
            if (dataFimReserva < hoje) continue;
            // =========================================================================

            // =========================================================================
            //  BLOCO DE BUSCA: RECONSTROI A LISTA PARA ENCONTRAR A RESERVA
            // =========================================================================
            let jogadoresNaReserva = (reserva.jogadores_completo || reserva.jogadores || "").split(',').map(j => j.trim());
            
            if (reserva.duracao > 1) {
                const keySegundaHora = `${reserva.dia}_${reserva.hora + 1}`;
                const reservaSegundaParte = todasAsReservas[quadra]?.[keySegundaHora];
                
                if (reservaSegundaParte && reservaSegundaParte.jogadores) {
                    const jogadoresParte2 = reservaSegundaParte.jogadores.split(',').map(j => j.trim());
                    jogadoresNaReserva.push(...jogadoresParte2);
                }
            }
            
            jogadoresNaReserva = [...new Set(jogadoresNaReserva.filter(j => j))];
            
            const isParticipante = jogadoresNaReserva.some(j => j.toUpperCase() === jogadorLogadoApelido.toUpperCase());
            const statusJogador = reserva.confirmacoes ? reserva.confirmacoes[jogadorLogadoApelido] : undefined;
            // =========================================================================

            if (isParticipante && statusJogador !== 'recusado') {
                const reservaInfo = { ...reserva, quadra, key, diffDias: diff }; // Guardamos diffDias para comparação
                
                if (!proximaReserva) {
                    proximaReserva = reservaInfo;
                } else {
                    // Compara qual reserva acontece antes (menor diferença de dias ou mesmo dia e hora menor)
                    if (reservaInfo.diffDias < proximaReserva.diffDias) {
                        proximaReserva = reservaInfo;
                    } else if (reservaInfo.diffDias === proximaReserva.diffDias && reserva.hora < proximaReserva.hora) {
                        proximaReserva = reservaInfo;
                    }
                }
            }
        }
    }

    if (proximaReserva) {
        
        // =================================================================
        // FUNÇÃO INTERNA DE RENDERIZAÇÃO (Agora assíncrona para buscar a parte 2)
        // =================================================================
        const renderizarAgenda = async (reservaDados) => {
            // 1. Pega os jogadores da primeira hora (que veio no snapshot)
            let listaJogadores = (reservaDados.jogadores_completo || reservaDados.jogadores || "").split(',').map(j => j.trim());

            // 2. CORREÇÃO PARA PIRÂMIDE: Se a duração > 1, buscamos a segunda hora NO BANCO
            const duracaoReal = reservaDados.duracao === 3 ? 2 : (reservaDados.duracao || 1);
            
            if (duracaoReal > 1) {
                const keySegundaHora = `${reservaDados.dia}_${reservaDados.hora + 1}`;
                try {
                    const snapshot2 = await database.ref(`sistemas/reservas/${proximaReserva.quadra}/${keySegundaHora}`).once('value');
                    const reservaParte2 = snapshot2.val();
                    
                    if (reservaParte2 && reservaParte2.jogadores) {
                         const jogadoresParte2 = reservaParte2.jogadores.split(',').map(j => j.trim());
                         listaJogadores.push(...jogadoresParte2);
                    }
                } catch (err) {
                    console.error("Erro ao buscar segunda parte da reserva na agenda:", err);
                }
            }

            // 3. Filtra vazios e duplicados e define a lista final para exibição
            const jogadoresNaReserva = [...new Set(listaJogadores.filter(j => j))];

            // 4. Configuração de exibição (Datas, Nomes, etc.)
            const nomesDiasMap = {
                1: "Segunda-Feira", 2: "Terça-Feira", 3: "Quarta-Feira", 4: "Quinta-Feira", 5: "Sexta-Feira", 6: "Sábado", 7: "Domingo"
            };
            const diaReserva = reservaDados.dia || proximaReserva.dia;
            
            const dataTabelaCell = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${diaReserva})`);
            const dataReservaTexto = dataTabelaCell ? dataTabelaCell.textContent : "Data não encontrada";

            const horaFim = reservaDados.hora + duracaoReal;
            const horario = `${String(reservaDados.hora).padStart(2, '0')}:00 - ${String(horaFim).padStart(2, '0')}:00`;

            // 5. Filtra Parceiros (Remove quem está logado)
            const todosParceiros = jogadoresNaReserva
                .filter(apelido => apelido.toUpperCase() !== jogadorLogadoApelido.toUpperCase());

            // Separa Sócios e Convidados
            const sociosParceiros = todosParceiros.filter(p => !p.trim().startsWith("Convidado"));
            const convidadosParceiros = todosParceiros
                .filter(p => p.trim().startsWith("Convidado - "))
                .map(p => p.substring(p.indexOf('-') + 2).trim());

            // Gera HTML para Sócios
            let sociosHtml = 'Nenhum';
            if (sociosParceiros.length > 0) {
                if (reservaDados.confirmacoes) {
                    sociosHtml = sociosParceiros.map(apelido => {
                        const status = reservaDados.confirmacoes[apelido];
                        let style = '';
                        if (status === true) { style = 'color: #28a745;'; } 
                        else if (status === false) { style = 'color: #ffc107;'; } 
                        else if (status === 'recusado') { style = 'color: #dc3545; text-decoration: line-through;'; }
                        return `<span style="${style}">${capitalizarNome(apelido)}</span>`;
                    }).join(', ');
                } else {
                    sociosHtml = sociosParceiros.map(capitalizarNome).join(', ');
                }
            }

            // Gera HTML para Convidados
            let convidadosHtml = ''; 
            if (convidadosParceiros.length > 0) {
                const label = convidadosParceiros.length > 1 ? 'Convidados' : 'Convidado';
                const nomes = convidadosParceiros.map(capitalizarNome).join(', ');
                convidadosHtml = `<p><strong>${label}:</strong> <i>${nomes}</i></p>`; 
            }

            const destaqueHoje = diaReserva === hojeIndex ? 'class="agenda-hoje-destaque"' : '';
            const textoDia = diaReserva === hojeIndex ? 'Hoje' : nomesDiasMap[diaReserva];

            // Renderiza o HTML Final
            agendaConteudo.innerHTML = `
                <div class="agenda-info">
                    <p><strong>Quadra:</strong> ${proximaReserva.quadra}</p>
                    <p><strong>Dia:</strong> <span ${destaqueHoje}>${textoDia}</span></p>
                    <p><strong>Data:</strong> ${dataReservaTexto}</p>
                    <p><strong>Horário:</strong> ${horario}</p>
                    <p><strong>Com:</strong> ${sociosHtml}</p>
                    ${convidadosHtml} 
                </div>
            `;
            
            if (agendaTrigger.classList.contains('expandido')) {
                 agendaConteudo.style.display = 'block'; 
            }
        };

        // 1. Executa a renderização inicial
        await renderizarAgenda(proximaReserva);

        // 2. Liga o monitoramento em tempo real da reserva
        agendaListenerRef = database.ref(`sistemas/reservas/${proximaReserva.quadra}/${proximaReserva.key}`);
        agendaCallback = agendaListenerRef.on('value', (snapshot) => {
            const dadosAtualizados = snapshot.val();
            if (dadosAtualizados) {
                renderizarAgenda(dadosAtualizados);
            } else {
                agendaConteudo.innerHTML = '<p class="agenda-nenhuma-reserva">Esta reserva foi cancelada.</p>';
                if (agendaListenerRef) agendaListenerRef.off('value', agendaCallback);
            }
        });

        // Mostra o botão da agenda
        if (agendaTrigger) agendaTrigger.style.display = 'flex';
        return proximaReserva;

    } else {
        agendaConteudo.innerHTML = '<p class="agenda-nenhuma-reserva">Você não possui nenhuma reserva futura agendada.</p>';
        if (agendaTrigger) agendaTrigger.style.display = 'flex'; 
        return null;
    }
}


/**
 * Abre o modal de resultado de duplas.
 * Futuramente, esta função também irá gerar os confrontos.
 */

// SUBSTITUA SUA FUNÇÃO ATUAL PELA VERSÃO CORRIGIDA ABAIXO
// ==========================================================
// ===== FUNÇÃO ABRIRMODALRESULTADODUPLAS ATUALIZADA =====
// ==========================================================
function abrirModalResultadoDuplas(reserva, key, quadra, modoVisualizacao = false) {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    const container = document.getElementById('duplasMatchupsContainer');
    const jogadoresInfo = document.getElementById('duplasJogadoresInfo'); // Declaração original mantida
    const modal = document.getElementById('modalResultadoDuplas');       // Declaração original mantida
    container.innerHTML = '';                                      // Limpeza original mantida

    let jogadores = []; // Array para guardar os apelidos
    if (reserva.jogadores_completo) {
        jogadores = reserva.jogadores_completo.split(',').map(j => j.trim());
    } else {
        const jogadoresParte1 = reserva.jogadores.split(',').map(j => j.trim());
        jogadores.push(...jogadoresParte1);
        if (reserva.duracao > 1) {
            const keySegundaParte = `${reserva.dia}_${reserva.hora + 1}`;
            const reservasDaQuadra = reservasPorQuadra[quadra] || {};
            const reservaSegundaParte = reservasDaQuadra[keySegundaParte];
            if (reservaSegundaParte && reservaSegundaParte.jogadores) {
                const jogadoresParte2 = reservaSegundaParte.jogadores.split(',').map(j => j.trim());
                jogadores.push(...jogadoresParte2);
            }
        }
    }
    jogadores = [...new Set(jogadores)]; // Remove duplicatas dos apelidos

    if (jogadores.length !== 4) {
        mostrarNotificacao("Erro: Esta função só é válida para reservas com 4 sócios.", 'error');
        return;
    }

    // --- INÍCIO DA MODIFICAÇÃO PARA NOMES COMPLETOS EM LINHA ÚNICA ---

    // 1. Mapeia os apelidos para nomes completos capitalizados
    const nomesCompletos = jogadores.map(apelido => {
        const jogadorInfo = jogadoresData[apelido.trim()]; // Busca info pelo apelido
        const nomeParaExibir = jogadorInfo ? jogadorInfo.nomeCompleto : apelido; // Usa nome completo ou fallback para apelido
        return capitalizarNome(nomeParaExibir); // Formata o nome
    });

    // 2. Constrói o HTML com título e nomes na mesma linha, separados por vírgula
    let jogadoresHtml = '<strong>Jogadores:</strong> '; // Título + espaço
    jogadoresHtml += nomesCompletos.join(', '); // Junta os nomes completos com ', '

    // 3. Define o conteúdo do elemento
    jogadoresInfo.innerHTML = jogadoresHtml;
    // --- FIM DA MODIFICAÇÃO ---


    // --- O RESTANTE DA FUNÇÃO ORIGINAL PERMANECE ABAIXO ---

    const confrontos = [
        { timeA: [jogadores[0], jogadores[1]], timeB: [jogadores[2], jogadores[3]] },
        { timeA: [jogadores[0], jogadores[2]], timeB: [jogadores[1], jogadores[3]] },
        { timeA: [jogadores[0], jogadores[3]], timeB: [jogadores[1], jogadores[2]] }
    ];

    confrontos.forEach((confronto, index) => {
        // Usa apelido capitalizado para os confrontos
        const timeANomes = `${capitalizarNome(confronto.timeA[0])}<br>${capitalizarNome(confronto.timeA[1])}`;
        const timeBNomes = `${capitalizarNome(confronto.timeB[0])}<br>${capitalizarNome(confronto.timeB[1])}`;
        const jogoNum = index + 1;

        let estiloTimeA = "font-weight: normal;";
        let estiloTimeB = "font-weight: normal;";

        if (modoVisualizacao && reserva.resultadoDuplas && reserva.resultadoDuplas.confrontos[index]) {
            const jogo = reserva.resultadoDuplas.confrontos[index];
            const [placarA, placarB] = jogo.placar.split('x').map(Number);
            if (placarA > placarB) {
                estiloTimeA = "font-weight: bold;";
            } else if (placarB > placarA) {
                estiloTimeB = "font-weight: bold;";
            }
        }

        const matchupHtml = `
            <div class="duplas-match-container">
                <div class="matchup-row">
                    <span class="team-names" style="${estiloTimeA}">${timeANomes}</span>
                    <div class="score-column">
                        <div class="score-input-container">
                            <input type="number" id="jogo${jogoNum}-placarA" class="score-input" min="0" oninput="controlarTieBreakDuplas(${jogoNum})">
                            <span>&times;</span>
                            <input type="number" id="jogo${jogoNum}-placarB" class="score-input" min="0" oninput="controlarTieBreakDuplas(${jogoNum})">
                        </div>
                        <div id="duplas-tiebreak${jogoNum}-container" class="tiebreak-container" style="display: none; justify-content: center; gap: 5px; margin-top: 5px;">
                            <span class="tiebreak-paren">(</span><input type="number" id="duplas-tb${jogoNum}-A" style="width: 40px; text-align: center;" min="0"><span>-</span><input type="number" id="duplas-tb${jogoNum}-B" style="width: 40px; text-align: center;" min="0"><span class="tiebreak-paren">)</span>
                        </div>
                    </div>
                    <span class="team-names" style="${estiloTimeB}">${timeBNomes}</span>
                </div>
            </div>
        `;
        container.innerHTML += matchupHtml;
    });

    if (modoVisualizacao && reserva.resultadoDuplas) {
        reserva.resultadoDuplas.confrontos.forEach((jogo, index) => {
            const jogoNum = index + 1;
            const [placarA, placarB] = jogo.placar.split('x');
            document.getElementById(`jogo${jogoNum}-placarA`).value = placarA;
            document.getElementById(`jogo${jogoNum}-placarB`).value = placarB;
            document.getElementById(`jogo${jogoNum}-placarA`).disabled = true;
            document.getElementById(`jogo${jogoNum}-placarB`).disabled = true;

            if (jogo.tiebreak && jogo.tiebreak.includes('-')) {
                const [tbA, tbB] = jogo.tiebreak.split('-');
                document.getElementById(`duplas-tb${jogoNum}-A`).value = tbA;
                document.getElementById(`duplas-tb${jogoNum}-B`).value = tbB;
                document.getElementById(`duplas-tb${jogoNum}-A`).disabled = true;
                document.getElementById(`duplas-tb${jogoNum}-B`).disabled = true;
                controlarTieBreakDuplas(jogoNum);
            }
        });
        document.getElementById('btnSalvarDuplas').style.display = 'none';
        document.getElementById('btnCancelarDuplas').style.display = 'none';
        document.getElementById('btnDepoisDuplas').textContent = 'Fechar';
    } else {
        document.getElementById('btnSalvarDuplas').style.display = 'inline-block';
        document.getElementById('btnCancelarDuplas').style.display = 'inline-block';
        document.getElementById('btnDepoisDuplas').textContent = 'Depois';
        document.getElementById('btnSalvarDuplas').onclick = () => salvarResultadoDuplas(reserva, key, quadra);
    }

    modal.style.display = 'flex';
}
// ==========================================================
// ===== FIM DA FUNÇÃO ABRIRMODALRESULTADODUPLAS ATUALIZADA =====
// ==========================================================




/**
 * Fecha o modal de resultado de duplas.
 */
function fecharModalResultadoDuplas() {
    document.getElementById('modalResultadoDuplas').style.display = 'none';
}


/**
 * Valida o placar de um único set, incluindo as regras de tie-break.
 * @param {number} score1 - Placar do jogador/time 1.
 * @param {number} score2 - Placar do jogador/time 2.
 * @param {number} tb1 - Placar do tie-break do jogador/time 1.
 * @param {number} tb2 - Placar do tie-break do jogador/time 2.
 * @returns {string|null} - Retorna 'j1' se o jogador 1 venceu, 'j2' se o jogador 2 venceu, ou null se o placar for inválido.
 */
function determinarVencedorSet(score1, score2, tb1, tb2) {
    if (isNaN(score1) || isNaN(score2)) return null;

    // Regra de vitória padrão (ex: 6-4, 6-3, 6-0 etc.)
    if ((score1 === 6 && score2 <= 4) || (score2 === 6 && score1 <= 4)) {
        return score1 > score2 ? 'j1' : 'j2';
    }
    // Regra de vitória por 7-5
    if ((score1 === 7 && score2 === 5) || (score2 === 7 && score1 === 5)) {
        return score1 > score2 ? 'j1' : 'j2';
    }

    // Lógica de TIE-BREAK (Placar de games 6-6, 7-6 ou 6-7)
    // CORREÇÃO: Agora aceita 6x6 como estado válido para analisar o Tie-break
    if ((score1 === 6 && score2 === 6) || (score1 === 7 && score2 === 6) || (score1 === 6 && score2 === 7)) {
        
        if (isNaN(tb1) || isNaN(tb2)) return null;

        const vencedorTB = Math.max(tb1, tb2);
        const perdedorTB = Math.min(tb1, tb2);
        let tiebreakValido = false;

        // CASO 1: Vitória Padrão no Tie-break (vencedor faz 7)
        if (vencedorTB === 7 && perdedorTB <= 5) {
            tiebreakValido = true;
        }
        // CASO 2: Vitória na "Prorrogação" (vencedor faz mais de 7 com diferença de 2)
        else if (vencedorTB > 7 && (vencedorTB - perdedorTB >= 2)) {
            tiebreakValido = true;
        }

        // Se o placar do tie-break for válido, verifica quem venceu
        if (tiebreakValido) {
            const tiebreakWinnerIsJ1 = tb1 > tb2;

            // CENÁRIO A: Placar 6x6 -> Quem ganhou o TB, ganhou o Set
            if (score1 === 6 && score2 === 6) {
                return tiebreakWinnerIsJ1 ? 'j1' : 'j2';
            }

            // CENÁRIO B: Placar 7x6 ou 6x7 -> Verifica consistência (Quem tem 7 games tem que ter ganhado o TB)
            const setWinnerIsJ1 = score1 > score2;
            if (setWinnerIsJ1 === tiebreakWinnerIsJ1) {
                return score1 > score2 ? 'j1' : 'j2';
            }
        }
    }

    // Se nenhuma regra for atendida, o placar do set é inválido ou incompleto
    return null;
}



/**
 * Mostra ou esconde os campos de tie-break para um jogo de duplas
 * com base no placar inserido.
 * @param {number} jogoNum - O número do jogo (1, 2 ou 3).
 */
function controlarTieBreakDuplas(jogoNum) {
    const placarA_input = document.getElementById(`jogo${jogoNum}-placarA`);
    const placarB_input = document.getElementById(`jogo${jogoNum}-placarB`);
    const tiebreakContainer = document.getElementById(`duplas-tiebreak${jogoNum}-container`);

    if (!placarA_input || !placarB_input || !tiebreakContainer) return;

    const placarA = parseInt(placarA_input.value, 10);
    const placarB = parseInt(placarB_input.value, 10);

    // Lógica correta, igual à da Pirâmide: Mostra o tie-break apenas se o placar for 7x6 ou 6x7
    if ((placarA === 6 && placarB === 7) || (placarA === 7 && placarB === 6)) {
        tiebreakContainer.style.display = 'inline-flex';
    } else {
        tiebreakContainer.style.display = 'none';
    }
}





/**
 * Valida, salva o resultado de uma partida de duplas e atualiza o ranking.
 */
async function salvarResultadoDuplas(reserva, key, quadra) {
    if (navigator.vibrate) { // Verifica se a função existe
		navigator.vibrate(50);
	}
    const vitorias = {};
    const confrontosInfo = [];

    // --- INÍCIO DA CORREÇÃO ---
    // Lógica robusta para obter a lista completa de jogadores, independentemente de como a reserva foi criada.
    let jogadoresApelidos = [];
    if (reserva.jogadores_completo) {
        jogadoresApelidos = reserva.jogadores_completo.split(',').map(j => j.trim());
    } else {
        const jogadoresParte1 = reserva.jogadores.split(',').map(j => j.trim());
        jogadoresApelidos.push(...jogadoresParte1);
        if (reserva.duracao > 1) {
            const keySegundaParte = `${reserva.dia}_${reserva.hora + 1}`;
            const reservasDaQuadra = reservasPorQuadra[quadra] || {};
            const reservaSegundaParte = reservasDaQuadra[keySegundaParte];
            if (reservaSegundaParte && reservaSegundaParte.jogadores) {
                const jogadoresParte2 = reservaSegundaParte.jogadores.split(',').map(j => j.trim());
                jogadoresApelidos.push(...jogadoresParte2);
            }
        }
    }
    jogadoresApelidos = [...new Set(jogadoresApelidos)];
    // --- FIM DA CORREÇÃO ---
    
    // O resto da sua lógica original para validar os placares e contar as vitórias.
    jogadoresApelidos.forEach(jogador => vitorias[jogador] = 0);

    const confrontosMap = [
        { timeA: [jogadoresApelidos[0], jogadoresApelidos[1]], timeB: [jogadoresApelidos[2], jogadoresApelidos[3]] },
        { timeA: [jogadoresApelidos[0], jogadoresApelidos[2]], timeB: [jogadoresApelidos[1], jogadoresApelidos[3]] },
        { timeA: [jogadoresApelidos[0], jogadoresApelidos[3]], timeB: [jogadoresApelidos[1], jogadoresApelidos[2]] }
    ];

    for (let i = 0; i < 3; i++) {
        const jogoNum = i + 1;
        const placarA = parseInt(document.getElementById(`jogo${jogoNum}-placarA`).value, 10);
        const placarB = parseInt(document.getElementById(`jogo${jogoNum}-placarB`).value, 10);
        const tbA = parseInt(document.getElementById(`duplas-tb${jogoNum}-A`).value, 10);
        const tbB = parseInt(document.getElementById(`duplas-tb${jogoNum}-B`).value, 10);
		
        if (isNaN(placarA) || isNaN(placarB)) {
			mostrarNotificacao(`Por favor, preencha o placar para o Jogo ${jogoNum}.`, 'error');
			return; // Mantém o return para parar a função
		}
        
		const vencedorDoSet = determinarVencedorSet(placarA, placarB, tbA, tbB);
		if (vencedorDoSet === null) {
			mostrarNotificacao(`O placar do Jogo ${jogoNum} (${placarA} x ${placarB}) é inválido.`, 'error');
			return;
		}
        const duplaVencedora = (vencedorDoSet === 'j1') ? confrontosMap[i].timeA : confrontosMap[i].timeB;
        duplaVencedora.forEach(jogador => vitorias[jogador]++);
        confrontosInfo.push({
            dupla1: confrontosMap[i].timeA.join(' / '),
            dupla2: confrontosMap[i].timeB.join(' / '),
            placar: `${placarA}x${placarB}`,
            tiebreak: (!isNaN(tbA) && !isNaN(tbB)) ? `${tbA}-${tbB}` : ""
        });
    }

    const jogadorLogadoApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto === localStorage.getItem('jogadorLogado')
    ) || localStorage.getItem('jogadorLogado');

    const resultadoDuplasObj = {
        dataInformado: new Date().toISOString(),
        informadoPor: jogadorLogadoApelido,
        confrontos: confrontosInfo
    };

    const updates = {};
    updates[`sistemas/reservas/${quadra}/${key}/status`] = 'finalizada';
    updates[`sistemas/reservas/${quadra}/${key}/resultadoDuplas`] = resultadoDuplasObj;
    const key2 = `${reserva.dia}_${reserva.hora + 1}`;
    updates[`sistemas/reservas/${quadra}/${key2}/status`] = 'finalizada';
    updates[`sistemas/reservas/${quadra}/${key2}/resultadoDuplas`] = resultadoDuplasObj;

    const nomesCompletos = jogadoresApelidos.map(apelido => {
        if (jogadoresData[apelido]) {
            return jogadoresData[apelido].nomeCompleto;
        }
        return undefined;
    });

    	
	if (nomesCompletos.some(nome => !nome)) {
		mostrarNotificacao("Erro: O nome completo de um dos jogadores não foi encontrado. O ranking não pode ser atualizado.", 'error');

		try {
			await database.ref().update({
				[`sistemas/reservas/${quadra}/${key}/status`]: 'finalizada',
				[`sistemas/reservas/${quadra}/${key}/resultadoDuplas`]: resultadoDuplasObj,
				[`sistemas/reservas/${quadra}/${key2}/status`]: 'finalizada',
				[`sistemas/reservas/${quadra}/${key2}/resultadoDuplas`]: resultadoDuplasObj
			});
			mostrarNotificacao("Resultado da partida salvo, mas houve um erro ao encontrar os jogadores para atualizar o ranking.", 'warning');
			fecharModalResultadoDuplas();
		} catch (error) {
			console.error("Erro ao salvar o resultado das duplas (sem ranking):", error);
			mostrarNotificacao("Ocorreu um erro ao salvar o resultado.", 'error');
		}
		return;
	}


    const promessasDeLeitura = nomesCompletos.map(nome =>
        database.ref(`sistemas/cadastro/jogadores/${nome}`).once('value')
    );
    const snapshots = await Promise.all(promessasDeLeitura);

    snapshots.forEach((snapshot, index) => {
        const nomeCompleto = nomesCompletos[index];
        const dadosAtuais = snapshot.val() || {};
        const jogosAtuais = dadosAtuais.jogosDeDuplasJogados || 0;
        const vitoriasAtuais = dadosAtuais.vitoriasEmDuplas || 0;
        const vitoriasNestaPartida = vitorias[jogadoresApelidos[index]] || 0;
        updates[`sistemas/cadastro/jogadores/${nomeCompleto}/jogosDeDuplasJogados`] = jogosAtuais + 3;
        updates[`sistemas/cadastro/jogadores/${nomeCompleto}/vitoriasEmDuplas`] = vitoriasAtuais + vitoriasNestaPartida;
    });

    
	try {
		await database.ref().update(updates);
		mostrarNotificacao("Resultado salvo e ranking atualizado com sucesso!", 'success');
		fecharModalResultadoDuplas();
	} catch (error) {
		console.error("Erro ao salvar o resultado e ranking das duplas:", error);
		mostrarNotificacao("Ocorreu um erro ao salvar o resultado.", 'error');
	}
	
	
}


/**
 * Gera o HTML para exibir o resultado de uma partida de duplas (3 jogos).
 * @param {object} resultadoDuplas - O objeto de resultado salvo na reserva.
 * @returns {string} - O HTML formatado para ser exibido no modal.
 */
/**
 * Gera o HTML para exibir o resultado de uma partida de duplas (3 jogos).
 * ATUALIZADO: Estrutura melhorada para cortar nomes longos no celular.
 */
function gerarPlacarDuplasHtml(resultadoDuplas) {
    if (!resultadoDuplas || !resultadoDuplas.confrontos) return "";

    let html = '<div class="placar-container">';

    resultadoDuplas.confrontos.forEach(jogo => {
        const [placarA, placarB] = jogo.placar.split('x').map(Number);
        const timeAVenceu = placarA > placarB;

        // --- NOVA LÓGICA DE FORMATAÇÃO DE NOMES ---
        // Envolve cada nome em uma div com classe específica para permitir o corte (...)
        const formatarNomes = (duplaStr) => {
            return duplaStr.split(' / ').map(nome => 
                `<div class="dupla-name-item">${nome}</div>`
            ).join('');
        };

        const dupla1Html = formatarNomes(jogo.dupla1);
        const dupla2Html = formatarNomes(jogo.dupla2);
        // -------------------------------------------

        let placarHtml;
        
        if (jogo.tiebreak) {
            const [tbA, tbB] = jogo.tiebreak.split('-');
            placarHtml = `
                <span class="set-score ${timeAVenceu ? 'winner' : ''}">${placarA}<sup>${tbA}</sup></span>
                <span>&times;</span>
                <span class="set-score ${!timeAVenceu ? 'winner' : ''}">${placarB}<sup>${tbB}</sup></span>
            `;
        } else {
            placarHtml = `
                <span class="set-score ${timeAVenceu ? 'winner' : ''}">${placarA}</span>
                <span>&times;</span>
                <span class="set-score ${!timeAVenceu ? 'winner' : ''}">${placarB}</span>
            `;
        }

        html += `
            <div class="matchup-row" style="padding: 4px 0; font-size: 0.95em; align-items: center;">
                <div class="team-names" style="font-weight: ${timeAVenceu ? 'bold' : 'normal'}; text-align: center; flex-basis: 40%; overflow: hidden;">
                    ${dupla1Html}
                </div>
                
                <div class="score-input-container" style="flex-basis: 20%; display: flex; justify-content: center; gap: 5px; font-weight: bold; font-size: 1.1em;">
                    ${placarHtml}
                </div>
                
                <div class="team-names" style="font-weight: ${!timeAVenceu ? 'bold' : 'normal'}; text-align: center; flex-basis: 40%; overflow: hidden;">
                    ${dupla2Html}
                </div>
            </div>
        `;
    });

    html += '</div>';
    
    // Formata a data/hora sem os segundos (dd/mm/aaaa hh:mm)
    const dataInformado = new Date(resultadoDuplas.dataInformado).toLocaleString('pt-BR', {
        day: '2-digit', month: '2-digit', year: 'numeric',
        hour: '2-digit', minute: '2-digit'
    });

    // Texto encurtado: "Informado por..."
    html += `<p style="text-align: center; font-size: 0.8em; color: #888; margin-top: 15px;">Informado por ${resultadoDuplas.informadoPor} em ${dataInformado}.</p>`;

    return html;
}






/**
 * Gera as atualizações do banco de dados para notificar os jogadores sobre uma decisão final,
 * com mensagens formatadas e detalhadas.
 * @param {object} reserva - O objeto da reserva com os dados do resultado.
 * @param {string} decisao - O texto que descreve a decisão (ex: "aprovado pelo Árbitro").
 * @returns {object} - Um objeto com as chaves de atualização do Firebase para as notificações.
 */

/* ========================================================== */
/* SUBSTITUA SUA FUNÇÃO ENVIARNOTIFICACAORESULTADOFINALIZADO  */
/* ========================================================== */

function enviarNotificacaoResultadoFinalizado(reserva, decisao) {
    const notificacaoUpdates = {};
    if (!reserva || !reserva.resultado) return notificacaoUpdates;

    const { vencedor, perdedor } = reserva.resultado;
    const vencedorInfo = jogadoresData[vencedor];
    const perdedorInfo = jogadoresData[perdedor];

    if (vencedorInfo && perdedorInfo) {
        // --- INÍCIO DA CORREÇÃO DEFINITIVA ---
        // Lógica robusta para encontrar a ordem original dos jogadores
        let jogador1Original, jogador2Original;
        if (reserva.jogadores_completo) {
            // Se o campo existe, usamos ele, que é garantido
            [jogador1Original, jogador2Original] = reserva.jogadores_completo.split(',').map(j => j.trim());
        } else {
            // Se não existe (reservas antigas), usamos a lógica de dedução
            // O primeiro jogador da reserva é sempre o "jogador1"
            jogador1Original = reserva.jogadores.split(',').map(j => j.trim())[0];
            // O segundo jogador é o outro participante (seja ele vencedor ou perdedor)
            jogador2Original = (jogador1Original === vencedor) ? perdedor : vencedor;
        }
        // --- FIM DA CORREÇÃO DEFINITIVA ---

        const dataReserva = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${reserva.dia})`).textContent;
        const hr = '<hr style="border: none; border-top: 1px solid #ddd; margin: 8px 0;">';
        
        let tipoNotificacao = 'success';
        if (decisao.includes("cancelad")) tipoNotificacao = 'error';
        if (decisao.includes("corrigid") || decisao.includes("informado")) tipoNotificacao = 'warning';

        const gerarPlacarArbitragemHtml = () => {
            const ehCancelado = decisao.includes("cancelad");
            // AGORA passamos os jogadores na ordem correta para o placar
            let placarHtml = gerarPlacarHtml(reserva.resultado, jogador1Original, jogador2Original)
                .replace('<div class="placar-container">', '<div class="placar-container" style="font-size: 1em; line-height: 1.5;">')
                .replace('<b>Resultado do Jogo:</b>', ehCancelado ? '<b>Resultado Informado:</b>' : '<b>Resultado Final:</b>');
            
            if (ehCancelado) {
                placarHtml = placarHtml.replace(/font-weight: bold;/g, 'font-weight: normal;').replace(/match-winner/g, '');
            }
            return placarHtml;
        };

        const construirMensagem = (jogadorPrincipal, oponente) => {
            let mensagem = `<h4 style="text-align:center; margin: 0 0 5px 0;">Arbitragem Finalizada</h4>`;
            mensagem += hr;
            mensagem += `<b>Data:</b> ${dataReserva}<br>`;
            //mensagem += `<b>Decisão do Árbitro:</b> ${capitalizarNome(decisao.replace(/pelo |pelo /g, "").trim())}`;
			
			// --- INÍCIO DA CORREÇÃO ---
            const decisaoLimpa = decisao.split(' ')[0]; // Pega apenas a primeira palavra (ex: "cancelado")
            mensagem += `<b>Decisão do Árbitro:</b> ${capitalizarNome(decisaoLimpa)}`;
            // --- FIM DA CORREÇÃO ---
			
			
            mensagem += hr;

            if (decisao.includes("cancelad")) {
                mensagem += `${gerarPlacarArbitragemHtml()}<br>`;
                mensagem += `O placar acima foi <b>invalidado</b>. A partida <b>não afetará</b> o ranking.`;
            } else if (decisao.includes("corrigid") || decisao.includes("informado")) {
                mensagem += `${gerarPlacarArbitragemHtml()}<br>`;
                mensagem += `O placar original foi alterado. O ranking foi atualizado.`;
            } else { // Aprovado
                mensagem += `${gerarPlacarArbitragemHtml()}<br>`;
                mensagem += `O ranking foi atualizado.`;
            }
            return mensagem;
        };
        
        const mensagemFinal = construirMensagem();
        const notificacaoParaAmbos = { mensagem: mensagemFinal, tipo: tipoNotificacao };

        const notificacaoKeyVencedor = database.ref().push().key;
        notificacaoUpdates[`sistemas/cadastro/jogadores/${vencedorInfo.nomeCompleto}/notificacoes/${notificacaoKeyVencedor}`] = notificacaoParaAmbos;
        
        const notificacaoKeyPerdedor = database.ref().push().key;
        notificacaoUpdates[`sistemas/cadastro/jogadores/${perdedorInfo.nomeCompleto}/notificacoes/${notificacaoKeyPerdedor}`] = notificacaoParaAmbos;
    }
    
    return notificacaoUpdates;
}




/**
 * Formata o objeto de resultado em uma string de placar legível.
 * @param {object} resultado - O objeto de resultado da partida.
 * @returns {string} - O placar formatado (ex: "Placar final: 6x4, 7x6(7-5).").
 */
function formatarPlacarParaMensagem(resultado) {
    if (!resultado) return "";
    //let placarString = "Placar Final: ";
	let placarString = "<b>Placar Final:</b> ";
    const sets = [];
    if (resultado.set1 && resultado.set1.placar) {
        let setStr = resultado.set1.placar;
        if (resultado.set1.tiebreak) setStr += `(${resultado.set1.tiebreak})`;
        sets.push(setStr);
    }
    if (resultado.set2 && resultado.set2.placar) {
        let setStr = resultado.set2.placar;
        if (resultado.set2.tiebreak) setStr += `(${resultado.set2.tiebreak})`;
        sets.push(setStr);
    }
    if (resultado.set3) {
        sets.push(resultado.set3);
    }
    placarString += sets.join(', ');
    return placarString;
}



/* ========================================================== */
/* ETAPA 2.3: FUNÇÃO JAVASCRIPT PARA NOTIFICAÇÕES             */
/* ========================================================== */


/**
 * Exibe uma notificação customizada na tela.
 * @param {string} mensagem - O texto a ser exibido.
 * @param {string} tipo - O tipo de notificação ('success' ou 'error').
 */
/* ========================================================== */
/* FUNÇÃO DE NOTIFICAÇÃO INTELIGENTE (COM TEMPO DINÂMICO)     */
/* ========================================================== */

function mostrarNotificacao(mensagem, tipo = 'success') {
    const notificacao = document.getElementById('notificacao');
    if (!notificacao) return;

    clearTimeout(notificacaoTimer);

    notificacao.innerHTML = mensagem; 
    notificacao.className = 'notificacao';
    notificacao.classList.add(tipo);
    notificacao.classList.add('show');

    // --- LÓGICA DO TEMPO INTELIGENTE ---
    const tempoMinimo = 5000; // 4 segundos no mínimo
    const tempoMaximo = 30000; // 10 segundos no máximo
    const palavrasPorMinuto = 100; // Velocidade de leitura média 

    // Remove tags HTML para contar apenas as palavras visíveis
    const textoPuro = mensagem.replace(/<[^>]*>?/gm, '');
    const numeroDePalavras = textoPuro.split(/\s+/).length;

    // Calcula o tempo necessário para ler (em milissegundos)
    const tempoCalculado = (numeroDePalavras / palavrasPorMinuto) * 60 * 1000;
    
    // O tempo de exibição será o maior entre o mínimo e o calculado, mas nunca maior que o máximo
    let tempoDeExibicao = Math.max(tempoMinimo, tempoCalculado);
    tempoDeExibicao = Math.min(tempoDeExibicao, tempoMaximo); // Garante que não passe do máximo

    // Define o timer com o tempo de exibição dinâmico
    notificacaoTimer = setTimeout(() => {
        notificacao.classList.remove('show');
    }, tempoDeExibicao);
}



/* ========================================================== */
/* PASSO 3: LÓGICA JAVASCRIPT DO MODAL DE CONFIRMAÇÃO         */
/* ========================================================== */
/**
 * Exibe um modal de confirmação customizado.
 * @param {string} mensagem - A pergunta a ser exibida no modal.
 * @param {function} acaoAoConfirmar - A função a ser executada se o usuário clicar em "Confirmar".
 * @param {function} [acaoAoCancelar] - (Opcional) A função a ser executada se o usuário clicar em "Cancelar".
 */
// VERSÃO ATUALIZADA da função mostrarConfirmacao
/**
 * Exibe o modal de confirmação PADRÃO (Logout, Excluir, etc).
 * CORREÇÃO TOTAL: Limpa qualquer resquício da versão customizada.
 */
/**
 * Exibe o modal de confirmação PADRÃO (Logout, Excluir).
 * FAXINA: Remove a classe 'mobile-custom-grid' para não quebrar o layout.
 */
/**
 * Exibe o modal de confirmação PADRÃO (Logout, Excluir).
 * FAXINA: Remove a classe 'mobile-grid-layout' para não quebrar o layout padrão.
 */
function mostrarConfirmacao(mensagem, acaoAoConfirmar, acaoAoCancelar, tipoAcao = 'primary') {
    const modalOverlay = document.getElementById('modalConfirmacaoOverlay');
    const modalMensagem = document.getElementById('modalConfirmacaoMensagem');
    let btnContainer = document.querySelector('#modalConfirmacaoOverlay .modal-botoes-container');

    if (!modalOverlay || !modalMensagem || !btnContainer) return;

    // --- AUTO-REPARO (A Mágica acontece aqui) ---
    // Se os botões originais foram apagados pelo menu de agendamento, recria eles.
    if (!document.getElementById('btnConfirmarAcao')) {
        btnContainer.innerHTML = ''; // Garante limpeza
        btnContainer.className = 'modal-botoes-container'; // Restaura classe
        
        // Recria Botão Cancelar
        const btnCan = document.createElement('button');
        btnCan.id = 'btnCancelarAcao';
        btnCan.className = 'btn-cancelar';
        btnCan.textContent = 'Cancelar';
        btnContainer.appendChild(btnCan);

        // Recria Botão Confirmar
        const btnConf = document.createElement('button');
        btnConf.id = 'btnConfirmarAcao';
        btnConf.className = 'btn-confirmar';
        btnConf.textContent = 'Confirmar';
        btnContainer.appendChild(btnConf);
    }
    // ---------------------------------------------

    // Agora pegamos as referências garantindo que existem
    const btnConfirmar = document.getElementById('btnConfirmarAcao');
    const btnCancelar = document.getElementById('btnCancelarAcao');

    // --- RESTANTE DA LÓGICA ORIGINAL (Mantida e Ajustada) ---

    // 1. Limpa estilos residuais de layout
    btnContainer.style.display = 'flex';
    btnContainer.style.justifyContent = 'center'; 
    btnContainer.style.gap = '15px'; 
    btnContainer.style.flexDirection = 'row'; // Garante linha (não coluna)

    // 2. Reseta estilos visuais dos botões (para garantir consistência)
    const resetEstilo = (btn) => {
        btn.style.width = 'auto';
        btn.style.minWidth = '100px';
        btn.style.padding = '10px 20px';
        btn.style.borderRadius = '6px';
        btn.style.border = 'none';
        btn.style.cursor = 'pointer';
        btn.style.fontWeight = 'bold';
        btn.style.color = 'white';
        btn.style.display = 'block'; // Garante que apareça
    };
    resetEstilo(btnConfirmar);
    resetEstilo(btnCancelar);

    // 3. Define a mensagem
    modalMensagem.innerHTML = mensagem;

    // 4. Define Cores baseadas no Tipo
    // Padrão (Logout/Info) = Azul ou Verde | Perigo (Excluir) = Vermelho
    if (tipoAcao === 'danger' || tipoAcao === 'perigo' || tipoAcao === 'vermelho') {
        btnConfirmar.style.backgroundColor = '#dc3545'; // Vermelho
        btnCancelar.style.backgroundColor = '#6c757d';  // Cinza
    } else {
        btnConfirmar.style.backgroundColor = '#007bff'; // Azul
        btnCancelar.style.backgroundColor = '#dc3545';  // Vermelho (Cancelar padrão)
    }

    // 5. Configura os Cliques
    
    // IMPORTANTE: Removemos event listeners antigos clonando o nó
    // Isso evita que um clique dispare a ação de um modal anterior
    const novoBtnConf = btnConfirmar.cloneNode(true);
    const novoBtnCanc = btnCancelar.cloneNode(true);
    
    btnConfirmar.parentNode.replaceChild(novoBtnConf, btnConfirmar);
    btnCancelar.parentNode.replaceChild(novoBtnCanc, btnCancelar);

    novoBtnConf.onclick = function() {
        modalOverlay.style.display = 'none';
        if (typeof acaoAoConfirmar === 'function') acaoAoConfirmar();
    };

    novoBtnCanc.onclick = function() {
        modalOverlay.style.display = 'none';
        if (typeof acaoAoCancelar === 'function') acaoAoCancelar();
    };

    // Exibe o modal
    modalOverlay.style.display = 'flex';
}



/**
 * Exibe um modal de escolha com 3 opções (Opção 1, Opção 2 e Cancelar),
 * baseado na lógica do arquivo 58 (layout flex), mas com as cores da planilha.
 */
/**
 * Exibe um modal de escolha com 3 opções (Opção 1, Opção 2 e Cancelar).
 * Versão COMPLETA E ROBUSTA (Baseada na v58).
 */
/**
 * Exibe um modal de escolha com 3 opções (Opção 1, Opção 2 e Cancelar).
 * CORES E FONTES RESTAURADAS (Padrão Planilha).
 */
/**
 * Exibe um modal de escolha com 3 opções (Opção 1, Opção 2 e Cancelar).
 * VERSÃO BLINDADA: Usa !important via JS para vencer o CSS global.
 */
/**
 * Exibe modal com layout ajustado para CELULAR (2 em cima, 1 embaixo).
 */
/**
 * Exibe modal com layout ajustado para CELULAR (Grid: 2 em cima, 1 embaixo).
 * VERSÃO DEFINITIVA COM CSS GRID.
 */
/**
 * Exibe modal com layout HÍBRIDO (Corrigido Alinhamento PC):
 * - Celular: Grid (2 botões em cima, 1 embaixo)
 * - PC: Flex (3 botões lado a lado, perfeitamente alinhados)
 */
/**
 * Exibe modal Customizado.
 * CORREÇÃO FINAL:
 * - AULA: Altera para 🏃.
 * - OUTROS (Manutenção/Jogo/Cancelar): Mantém o texto/ícone original intocado.
 */
function mostrarConfirmacaoCustomizada(mensagem, acaoConfirmar, acaoCancelar, textoConfirmar, textoCancelar) {
    const modalOverlay = document.getElementById('modalConfirmacaoOverlay');
    const modalMensagem = document.getElementById('modalConfirmacaoMensagem');
    const btnContainer = document.querySelector('#modalConfirmacaoOverlay .modal-botoes-container');
    const btnConfirmar = document.getElementById('btnConfirmarAcao'); // Botão Direito
    const btnCancelar = document.getElementById('btnCancelarAcao');   // Botão Esquerdo

    if (!modalOverlay || !modalMensagem || !btnConfirmar || !btnCancelar) return;

    modalMensagem.innerHTML = mensagem;
    
    // --- 1. ESTILO HÍBRIDO (MANTIDO) ---
    const estiloAntigo = document.getElementById('estilo-hibrido-botoes');
    if (estiloAntigo) estiloAntigo.remove();

    const style = document.createElement('style');
    style.id = 'estilo-hibrido-botoes';
    style.innerHTML = `
        /* CELULAR: Grid */
        @media (max-width: 600px) {
            .layout-hibrido {
                display: grid !important;
                grid-template-columns: 1fr 1fr !important;
                gap: 10px !important;
                width: 100% !important;
            }
            .layout-hibrido button { width: 100% !important; }
            .layout-hibrido #btnCancelarAcao { grid-column: 1 / 2 !important; }
            .layout-hibrido #btnConfirmarAcao { grid-column: 2 / 3 !important; }
            .layout-hibrido #btnExtraCancelar { grid-column: 1 / -1 !important; margin-top: 5px !important; }
        }
        /* PC: Flex */
        @media (min-width: 601px) {
            .layout-hibrido {
                display: flex !important;
                justify-content: space-between !important;
                align-items: stretch !important;
                gap: 15px !important;
                width: 100% !important;
            }
            .layout-hibrido button {
                flex: 1 !important; width: auto !important; margin: 0 !important;
            }
            .layout-hibrido #btnExtraCancelar {
                margin-top: 0 !important; margin-bottom: 0 !important;
            }
        }
    `;
    document.head.appendChild(style);
    btnContainer.classList.add('layout-hibrido');

    // --- 2. LÓGICA RESTRITA DE ALTERAÇÃO ---
    const aplicarEstilo = (btn, textoOriginal) => {
        btn.style.cssText = ''; 
        const setProp = (prop, val) => btn.style.setProperty(prop, val, 'important');

        // Estilo Base
        setProp('padding', '12px 0');
        setProp('text-align', 'center');
        setProp('border-radius', '6px');
        setProp('cursor', 'pointer');
        setProp('font-weight', 'bold');
        setProp('font-size', '16px');
        setProp('box-shadow', '0 2px 4px rgba(0,0,0,0.2)');
        setProp('height', 'auto'); 
        
        const t = textoOriginal.toLowerCase();
        const isDark = document.body.classList.contains('dark-mode');

        // === AQUI ESTÁ A LÓGICA SOLICITADA ===

        // CASO 1: AULA (ÚNICO QUE MUDA ÍCONE)
        if (t.includes('aula')) {
            setProp('background-color', 'lightcoral'); 
            setProp('color', 'black'); 
            setProp('border', '1px solid #d67f7f');
            btn.innerHTML = "🏃 Aula"; // Força o bonequinho
        } 
        
        // CASO 2: JOGO (MANTÉM ORIGINAL)
        else if (t.includes('jogo')) {
            setProp('background-color', '#4CAF50');
            setProp('color', 'white');
            setProp('border', 'none');
            btn.innerHTML = textoOriginal; // Mantém o que veio (🎾 Jogo)
        } 
        
        // CASO 3: MANUTENÇÃO (MANTÉM ORIGINAL - GOTINHAS)
        else if (t.includes('manutenção') || t.includes('manutencao')) {
            setProp('background-color', isDark ? '#252525' : '#e9ecef');
            setProp('color', isDark ? '#999' : '#555');
            setProp('border', '1px solid #ccc');
            btn.innerHTML = textoOriginal; // Mantém o que veio (💦 Manutenção)
        } 
        
        // CASO 4: CANCELAR (MANTÉM ORIGINAL - SEM ÍCONE)
        else if (t.includes('cancelar')) {
            setProp('background-color', '#6c757d');
            setProp('color', 'white');
            setProp('border', 'none');
            btn.innerHTML = textoOriginal; // Mantém "Cancelar"
        }
        
        // OUTROS
        else {
            setProp('background-color', '#007bff');
            setProp('color', 'white');
            setProp('border', 'none');
            btn.innerHTML = textoOriginal;
        }
    };

    // --- 3. APLICAÇÃO ---
    aplicarEstilo(btnCancelar, textoCancelar); 
    aplicarEstilo(btnConfirmar, textoConfirmar); 

    let btnExtra = document.getElementById('btnExtraCancelar');
    if (!btnExtra) {
        btnExtra = document.createElement('button');
        btnExtra.id = 'btnExtraCancelar';
        btnContainer.appendChild(btnExtra); 
    }
    aplicarEstilo(btnExtra, "Cancelar");
    btnExtra.style.display = 'block'; 

    // --- 4. LISTENERS ---
    const novoBtnCancelar = btnCancelar.cloneNode(true);
    btnCancelar.parentNode.replaceChild(novoBtnCancelar, btnCancelar);
    
    const novoBtnConfirmar = btnConfirmar.cloneNode(true);
    btnConfirmar.parentNode.replaceChild(novoBtnConfirmar, btnConfirmar);

    const novoBtnExtra = btnExtra.cloneNode(true);
    btnExtra.parentNode.replaceChild(novoBtnExtra, btnExtra);

    novoBtnCancelar.addEventListener('click', () => {
        if (navigator.vibrate) navigator.vibrate(50);
        modalOverlay.style.display = 'none';
        if (acaoCancelar) acaoCancelar();
    });

    novoBtnConfirmar.addEventListener('click', () => {
        if (navigator.vibrate) navigator.vibrate(50);
        modalOverlay.style.display = 'none';
        if (acaoConfirmar) acaoConfirmar();
    });

    novoBtnExtra.addEventListener('click', () => {
        if (navigator.vibrate) navigator.vibrate(50);
        modalOverlay.style.display = 'none';
    });
    
    modalOverlay.style.display = 'flex';
}




/**
 * Verifica se um placar de set é conclusivo (6-4, 7-5, 7-6, etc.).
 * Usado para a lógica de negrito em desistências.
 */
function isSetConcluido(s1, s2) {
    return (
        (s1 === 6 && s2 <= 4) || (s2 === 6 && s1 <= 4) ||
        (s1 === 7 && s2 === 5) || (s2 === 7 && s1 === 5) ||
        (s1 === 7 && s2 === 6) || (s2 === 7 && s1 === 6)
    );
}

/**
 * Habilita ou desabilita os campos de placar e também os limpa se estiver desabilitando.
 */
function setPlacarFieldsState(disabled) {
    const container = document.getElementById('placar-fields-container');
    const inputs = container.querySelectorAll('input[type="number"]');
    inputs.forEach(input => {
        input.disabled = disabled;
        if (disabled) {
            input.value = '';
        }
    });
}


/**
 * Verifica se o horário atual está dentro do período de uma reserva.
 * @param {object} reserva - O objeto da reserva.
 * @returns {boolean} - Retorna true se estiver no período do jogo.
 */
function isPeriodoDaReservaAtivo(reserva) {
    //return true; // <-- TESTES: aqui delegar placar aparece em qualquer horario, senao aparece apenas no horario da partida, como deveria ser
	
    try {
        const agora = new Date();

        // Pega a data da reserva da sua tabela (ex: "04/10/2025")
        const dataString = document.getElementById('tabelaQuadra').rows[1].cells[reserva.dia - 1].textContent;
        const [dia, mes, ano] = dataString.split('/');

        // Define o início da reserva
        const inicioReserva = new Date(ano, mes - 1, dia, reserva.hora, 0, 0);

        // Define o fim da reserva (duração de 2h para pirâmide)
        const duracao = reserva.duracao === 3 ? 2 : (reserva.duracao || 1);
        const fimReserva = new Date(inicioReserva);
        fimReserva.setHours(inicioReserva.getHours() + duracao);

        // Adiciona uma margem de tolerância de 15 minutos após o fim
        fimReserva.setMinutes(fimReserva.getMinutes() + 15); 

        // Verifica se a hora atual está entre o início e o fim da reserva
        return agora >= inicioReserva && agora <= fimReserva;
    } catch (e) {
        console.error("Erro ao verificar período da reserva:", e);
        return false; // Em caso de erro, não mostra o botão por segurança.
    }
}



function abrirModalDelegacao(reserva, key, quadra) {
    // Guarda as informações da reserva na variável global
    delegacaoEmAndamento = { reserva, key, quadra }; 

    document.getElementById('modalDelegacao').style.display = 'flex';
    carregarJogadoresOnlineParaDelegacao(reserva, quadra);
}

function fecharModalDelegacao() {
    // --- ADIÇÃO IMPORTANTE ---
    // Se existe um monitoramento ativo, nós o desligamos.
    if (listenerJogadoresOnline) {
        const onlineUsersRef = database.ref('sistemas/usuariosOnline');
        onlineUsersRef.off('value', listenerJogadoresOnline); // Desliga o monitoramento
        listenerJogadoresOnline = null; // Limpa a variável de controle
    }
    // --- FIM DA ADIÇÃO ---

    delegacaoEmAndamento = null; // Limpa a variável de contexto que já existia
    document.getElementById('modalDelegacao').style.display = 'none';
}
document.getElementById('btnCancelarDelegacao').onclick = fecharModalDelegacao;




/**
 * VERSÃO FINAL E CORRIGIDA (SEM VARIÁVEL 'ADMINISTRADORES' ANTIGA): 
 * - Remove referência quebrada a 'administradores'.
 * - Filtra dinamicamente admins baseados nos Perfis.
 * - Escreve as duas versões do nome no HTML.
 */
function carregarJogadoresOnlineParaDelegacao(reserva, quadra) {
    const container = document.getElementById('lista-jogadores-online');
    container.innerHTML = '<p style="text-align: center; color: #888;">Carregando...</p>';

    // --- INJEÇÃO DE CSS DINÂMICO (Para alternar os nomes) ---
    const styleId = 'estilo-delegacao-nomes';
    if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.innerHTML = `
            /* Por padrão (Celular em Pé), mostra o curto e esconde o longo */
            .nome-versao-mobile { display: block; }
            .nome-versao-desktop { display: none; }

            /* Se a tela for larga (Horizontal/PC > 500px), inverte */
            @media (min-width: 500px) {
                .nome-versao-mobile { display: none; }
                .nome-versao-desktop { display: block; }
            }
        `;
        document.head.appendChild(style);
    }
    // --------------------------------------------------------

    const onlineUsersRef = database.ref('sistemas/usuariosOnline');

    if (listenerJogadoresOnline) {
        onlineUsersRef.off('value', listenerJogadoresOnline);
    }

    listenerJogadoresOnline = onlineUsersRef.on('value', (snapshot) => {
        const onlineUsers = snapshot.val();

        if (!onlineUsers) {
            container.innerHTML = '<p style="text-align: center; color: #888;">Nenhum outro jogador online no momento.</p>';
            return;
        }

        // --- LÓGICA DE EXCLUSÃO (Jogadores que NÃO devem aparecer na lista) ---
        let listaDeExclusao = [];
        let jogadoresDaPartida = [];
        
        // 1. Jogadores da própria partida
        if (reserva.jogadores_completo) {
            jogadoresDaPartida = reserva.jogadores_completo.split(',').map(j => j.trim());
        } else {
            jogadoresDaPartida.push(...(reserva.jogadores || '').split(',').map(j => j.trim()));
            const keySegundaHora = `${reserva.dia}_${reserva.hora + 1}`;
            const reservaSegundaParte = reservasPorQuadra[quadra]?.[keySegundaHora];
            if (reservaSegundaParte && reservaSegundaParte.jogadores) {
                jogadoresDaPartida.push(...(reservaSegundaParte.jogadores || '').split(',').map(j => j.trim()));
            }
        }
        const jogadoresDaPartidaUpper = [...new Set(jogadoresDaPartida.filter(j => j))].map(j => j.toUpperCase());
        listaDeExclusao.push(...jogadoresDaPartidaUpper);

        // 2. O próprio usuário logado
        const jogadorLogadoApelido = Object.keys(jogadoresData).find(
            apelido => jogadoresData[apelido].nomeCompleto.toUpperCase() === (localStorage.getItem('jogadorLogado') || '').toUpperCase()
        );
        if (jogadorLogadoApelido) listaDeExclusao.push(jogadorLogadoApelido.toUpperCase());
        
        // 3. (ATUALIZADO) Exclui Árbitros e Admins da lista de delegação (via Perfil)
        Object.values(jogadoresData).forEach(j => {
            if (j.perfis) {
                // Verifica se é Admin ou Árbitro/Gestor
                const ehAutoridade = Object.keys(j.perfis).some(pName => 
                    j.perfis[pName] === true && (
                        perfisConfigGlobal[pName]?.permissoes?.super_admin === true ||
                        perfisConfigGlobal[pName]?.permissoes?.gestor_torneios === true
                    )
                ); 
                
                if (ehAutoridade) {
                    // Encontra o apelido correspondente e remove da lista de delegação
                    const apelidoAuth = Object.keys(jogadoresData).find(key => jogadoresData[key].nomeCompleto === j.nomeCompleto);
                    if (apelidoAuth) listaDeExclusao.push(apelidoAuth.toUpperCase());
                }
            }
        });

        // Remove duplicatas da lista de exclusão
        listaDeExclusao = [...new Set(listaDeExclusao)];
        // -----------------------------------------------------------------

        let htmlJogadores = '';
        let count = 0;

        for (const id in onlineUsers) {
            const usuario = onlineUsers[id];
            const apelidoOnline = Object.keys(jogadoresData).find(
                apelido => jogadoresData[apelido].nomeCompleto.toUpperCase() === usuario.usuario.toUpperCase()
            );

            if (apelidoOnline && !listaDeExclusao.includes(apelidoOnline.toUpperCase())) {
                
                // PREPARA AS DUAS VERSÕES DO NOME
                const nomeCompleto = capitalizarNome(usuario.usuario);
                const apelido = capitalizarNome(apelidoOnline);
                
                // 1. Versão Curta (Só Apelido em Negrito)
                const htmlMobile = `<b>${apelido}</b>`;

                // 2. Versão Longa (Nome Completo com Apelido em Negrito)
                let htmlDesktop = "";
                if (nomeCompleto.toLowerCase().includes(apelido.toLowerCase())) {
                    const regex = new RegExp(`(${apelido})`, 'gi');
                    htmlDesktop = nomeCompleto.replace(regex, '<b>$1</b>');
                } else {
                    htmlDesktop = `${nomeCompleto} (<b>${apelido}</b>)`;
                }

                htmlJogadores += `
                    <div style="
                        display: flex !important; 
                        align-items: center !important; 
                        justify-content: flex-start !important; 
                        width: 100% !important;
                        padding: 10px 15px !important;
                        border-bottom: 1px solid #eee !important; 
                        background-color: #fff !important;
                        cursor: pointer !important;
                        box-sizing: border-box !important;
                        text-align: left !important;
                        "
                        onclick="document.getElementById('delegado_${apelidoOnline}').checked = true; this.style.backgroundColor='#f0f8ff'; setTimeout(()=>this.style.backgroundColor='#fff', 200);">
                        
                        <input type="radio" name="delegado" value="${apelidoOnline}" id="delegado_${apelidoOnline}" 
                               style="
                                   width: 15px !important; 
                                   height: 15px !important;
                                   min-width: 15px !important;
                                   margin: 0 15px 0 0 !important; 
                                   padding: 0 !important;
                                   cursor: pointer; 
                                   flex-shrink: 0;">
                        
                        <label for="delegado_${apelidoOnline}" 
                               style="
                                cursor: pointer; 
                                font-size: 1.0rem !important; 
                                color: #333 !important; 
                                margin: 0 !important; 
                                width: auto !important; 
                                text-align: left !important; 
                                font-weight: 400 !important; 
                                line-height: 1.2 !important;
                                flex-grow: 1;">
                            
                            <span class="nome-versao-mobile">${htmlMobile}</span>
                            <span class="nome-versao-desktop">${htmlDesktop}</span>

                        </label>
                    </div>
                `;
                count++;
            }
        }

        if (count === 0) {
            container.innerHTML = '<p style="text-align: center; color: #888;">Nenhum outro jogador disponível para delegação.</p>';
        } else {
            container.style.padding = '0';
            container.innerHTML = htmlJogadores;
        }
    }, (error) => {
        console.error("Erro ao monitorar jogadores online:", error);
        container.innerHTML = '<p style="text-align: center; color: red;">Erro ao carregar lista.</p>';
    });
}





async function confirmarDelegacao() {
    const selecionado = document.querySelector('input[name="delegado"]:checked');

    if (!selecionado) {
        alert("Por favor, selecione um jogador para delegar.");
        return;
    }

    const apelidoDelegado = selecionado.value;

    // --- CORREÇÃO PRINCIPAL: Usa a variável 'delegacaoEmAndamento' ---
    if (!delegacaoEmAndamento) {
        alert("Erro: Não foi possível identificar a reserva. Tente novamente.");
        return;
    }

    const { key, quadra } = delegacaoEmAndamento; // Pega os dados da variável correta
    const path = `sistemas/reservas/${quadra}/${key}/delegado`;
    const path2 = `sistemas/reservas/${quadra}/${key.replace(/_(\d+)$/, (_, h) => `_${parseInt(h) + 1}`)}/delegado`;

    try {
        const updates = {};
        updates[path] = apelidoDelegado;
        updates[path2] = apelidoDelegado;

        await database.ref().update(updates);
        alert(`A anotação do placar foi delegada para ${apelidoDelegado} com sucesso!`);

        fecharModalDelegacao();

    } catch (error) {
        console.error("Erro ao salvar delegação:", error);
        alert("Ocorreu um erro ao salvar a delegação.");
    }
}
document.getElementById('btnConfirmarDelegacao').onclick = confirmarDelegacao;



/**
 * Gerencia o texto e a cor do botão de ação com base no estado do jogo.
 */
function atualizarBotaoSalvarResultado(isResultadoConclusivo = false) {
    const btnSalvar = document.getElementById('btnSalvarResultado');
    const btnCancelar = document.getElementById('btnCancelarResultado');
    const containerSumula = document.getElementById('simple-score-container');
    
    // 1. Verifica em qual modo estamos
    const isModoSumula = containerSumula && containerSumula.style.display !== 'none';
    const isModoArbitragem = !isModoSumula && document.getElementById('placar-fields-container').style.display !== 'none';

    // 2. Reset Básico
    btnSalvar.className = 'btn-modern btn-save'; 
    btnSalvar.style.display = 'flex';
    btnSalvar.onclick = salvarResultadoPiramide;
    btnCancelar.textContent = 'Cancelar';

    // --- MODO CLÁSSICO (Súmula, WO, Desistência) ---
    if (!isModoArbitragem) {
        
        // WO ou Desistência: Sempre Verde e Habilitado (pois o usuário seleciona o vencedor no menu)
        if (modoResultado === 'wo' || modoResultado === 'desistencia') {
            btnSalvar.textContent = 'Salvar';
            btnSalvar.disabled = false;
            btnSalvar.style.backgroundColor = '#28a745'; // Verde
            btnSalvar.style.color = 'white';
            btnSalvar.style.cursor = 'pointer';
            btnSalvar.style.opacity = '1';
        } 
        // SÚMULA: Regra estrita de vencedor
        else {
            btnSalvar.textContent = 'Salvar'; // Sempre "Salvar", nunca mais "Parciais"

            if (isResultadoConclusivo) {
                // TEM VENCEDOR: Botão Verde
                btnSalvar.disabled = false;
                btnSalvar.style.backgroundColor = '#28a745'; // Verde
                btnSalvar.style.color = 'white';
                btnSalvar.style.cursor = 'pointer';
                btnSalvar.style.opacity = '1';
            } else {
                // NÃO TEM VENCEDOR: Botão Cinza
                btnSalvar.disabled = true;
                btnSalvar.style.backgroundColor = '#cccccc'; // Cinza
                btnSalvar.style.color = '#666666'; // Texto Cinza Escuro
                btnSalvar.style.cursor = 'not-allowed';
                btnSalvar.style.opacity = '0.7';
            }
        }
        return;
    }

    // --- MODO ARBITRAGEM (Dinâmico e Automático) - SEM ALTERAÇÕES ---
    if (isResultadoConclusivo) {
        btnSalvar.textContent = 'Salvar'; 
        btnSalvar.style.backgroundColor = '#28a745';
        btnSalvar.disabled = false;
        btnSalvar.style.cursor = 'pointer';
        btnSalvar.style.opacity = '1';
    } else {
        if (verificarMatchPoint()) {
            btnSalvar.textContent = 'MATCH POINT';
            btnSalvar.className = 'btn-modern btn-status-matchpoint';
            btnSalvar.onclick = null; 
        } else {
            if (btnSalvar.textContent !== 'Salvando...') {
                btnSalvar.textContent = 'Salvo ✓';
                btnSalvar.className = 'btn-modern btn-status-saved';
            }
        }
        btnSalvar.disabled = false; // Na arbitragem o botão (mesmo que visual) fica ativo para interações
        btnCancelar.textContent = 'Sair';
    }
}




/**
 * Calcula o tempo restante e atualiza o display do contador.
 * @param {number} expiraEmTimestamp - O timestamp de quando a reserva expira.
 */
function atualizarDisplayContador(expiraEmTimestamp) {
    const contadorElemento = document.getElementById('modal-expira-em');
    if (!contadorElemento) return;

    const agora = Date.now();
    const tempoRestante = expiraEmTimestamp - agora;

    if (tempoRestante <= 0) {
        contadorElemento.textContent = "Expirado!";
        contadorElemento.style.color = "#dc3545"; // Vermelho
        if (timerContadorExpiracao) clearInterval(timerContadorExpiracao);
        return;
    }

    const horas = Math.floor((tempoRestante / (1000 * 60 * 60)) % 24);
    const minutos = Math.floor((tempoRestante / 1000 / 60) % 60);
    const segundos = Math.floor((tempoRestante / 1000) % 60);

    let tempoFormatado = '';
    if (horas > 0) tempoFormatado += `${horas}h `;
    tempoFormatado += `${String(minutos).padStart(2, '0')}m ${String(segundos).padStart(2, '0')}s`;

    contadorElemento.textContent = tempoFormatado;

    if (tempoRestante < 5 * 60 * 1000) { // Menos de 5 minutos
        contadorElemento.style.color = document.body.classList.contains('dark-mode') ? '#FFA726' : 'orange';
    } else {
        contadorElemento.style.color = "#dc3545"; // Cor padrão (vermelho)
    }
}



/**
 * Inicia um contador regressivo para a expiração da reserva.
 * @param {number} expiraEmTimestamp - O timestamp de quando a reserva expira.
 */
/**
 * Inicia um contador regressivo para a expiração da reserva.
 * @param {number} expiraEmTimestamp - O timestamp de quando a reserva expira.
 */
/**
 * Inicia um contador regressivo para a expiração da reserva.
 * @param {object} reserva - O objeto da reserva (apenas para obter o timestamp).
 */
function iniciarContadorExpiracao(reserva) {
    const expiraEmTimestamp = reserva.expiraEm;

    const atualizarDisplay = () => {
        const contadorElemento = document.getElementById('modal-expira-em');
        if (!contadorElemento) return;

        const agora = Date.now();
        const tempoRestante = expiraEmTimestamp - agora;

        if (tempoRestante <= 0) {
            // TEMPO ACABOU!
            clearInterval(timerContadorExpiracao); // Para o timer
            fecharModalDetalhes(); // Fecha o modal que está aberto
            
            // --- SUA SUGESTÃO IMPLEMENTADA AQUI ---
            // Chama a função global para limpar TODAS as reservas expiradas
            limparReservasExpiradas(); 
            
            mostrarNotificacao("<b>Reserva Expirada</b><br>O prazo para confirmação terminou. A reserva foi removida junto com outras que também possam ter expirado.", 'warning');
            return;
        }

        const horas = Math.floor(tempoRestante / (1000 * 60 * 60));
        const minutos = Math.floor((tempoRestante / 1000 / 60) % 60);
        const segundos = Math.floor((tempoRestante / 1000) % 60);

        let tempoFormatado = '';
        if (horas > 0) tempoFormatado += `${horas}h `;
        tempoFormatado += `${String(minutos).padStart(2, '0')}m ${String(segundos).padStart(2, '0')}s`;

        contadorElemento.textContent = tempoFormatado;
        
        if (tempoRestante < 5 * 60 * 1000) {
             contadorElemento.style.color = document.body.classList.contains('dark-mode') ? '#FFA726' : 'orange';
        } else {
             contadorElemento.style.color = "#dc3545";
        }
    };

    atualizarDisplay(); // Executa imediatamente
    timerContadorExpiracao = setInterval(atualizarDisplay, 1000);
}



/**
 * Fecha a tela de Placar Ao Vivo e desliga o monitoramento em tempo real.
 */
function fecharPlacarAoVivo() {
    sairDaTelaCheia();
    const overlay = document.getElementById('placarAoVivoOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }

    // Desliga o monitoramento do jogo
    if (listenerPlacarAoVivo) {
        listenerPlacarAoVivo.ref.off('value', listenerPlacarAoVivo.callback);
        listenerPlacarAoVivo = null;
    }

    // --- NOVO: Sai da "sala" de espectadores ---
    if (espectadorRef) {
        espectadorRef.remove(); // Remove meu nome da lista
        espectadorRef = null;
    }
    if (contadorEspectadoresRef && contadorEspectadoresCallback) {
        contadorEspectadoresRef.off('value', contadorEspectadoresCallback); // Para de contar
        contadorEspectadoresRef = null;
        contadorEspectadoresCallback = null;
    }
}

/**
 * Abre a tela de Placar Ao Vivo e inicia o monitoramento da partida.
 * VERSÃO FINAL - LIMPA E CORRIGIDA
 */
async function abrirPlacarAoVivo(key, quadra) {
    const overlay = document.getElementById('placarAoVivoOverlay');
    const placarRef = database.ref(`sistemas/reservas/${quadra}/${key}`);

    if (listenerPlacarAoVivo) {
        listenerPlacarAoVivo.ref.off('value', listenerPlacarAoVivo.callback);
    }

    const callbackDoPlacar = async snapshot => {
        const reserva = snapshot.val();

        if (!reserva || !reserva.resultado) {
            fecharPlacarAoVivo();
            return;
        }

        // --- PREPARAÇÃO DOS JOGADORES ---
        let jogadoresApelidos = [];
        if (reserva.jogadores_completo) {
            jogadoresApelidos = reserva.jogadores_completo.split(',').map(j => j.trim());
        } else {
            const jogador1 = (reserva.jogadores || "").split(',').map(j => j.trim())[0];
            const keySegundaParte = `${reserva.dia}_${reserva.hora + 1}`;
            const reserva2Ref = database.ref(`sistemas/reservas/${quadra}/${keySegundaParte}`);
            const snapshot2 = await reserva2Ref.once('value');
            const reservaSegundaParte = snapshot2.val();
            if (reservaSegundaParte && reservaSegundaParte.jogadores) {
                const jogador2 = reservaSegundaParte.jogadores.split(',').map(j => j.trim())[0];
                jogadoresApelidos = [jogador1, jogador2];
            }
        }

        if (jogadoresApelidos.length < 2) { fecharPlacarAoVivo(); return; }
        const [j1Apelido, j2Apelido] = jogadoresApelidos;
        const j1Info = jogadoresData[j1Apelido];
        const j2Info = jogadoresData[j2Apelido];
        const j1NomeCompleto = j1Info ? capitalizarNome(j1Info.nomeCompleto) : capitalizarNome(j1Apelido);
        const j2NomeCompleto = j2Info ? capitalizarNome(j2Info.nomeCompleto) : capitalizarNome(j2Apelido);

        document.getElementById('placar-quadra').textContent = quadra;
        document.getElementById('placar-j1-posicao').textContent = getDisplayRank(j1Info?.piramide) || 'N/A';
        document.getElementById('placar-j2-posicao').textContent = getDisplayRank(j2Info?.piramide) || 'N/A';

        const j1NomeEl = document.getElementById('placar-j1-nome');
        const j2NomeEl = document.getElementById('placar-j2-nome');
        j1NomeEl.setAttribute('data-nome-completo', j1NomeCompleto);
        j1NomeEl.setAttribute('data-apelido', j1Apelido);
        j2NomeEl.setAttribute('data-nome-completo', j2NomeCompleto);
        j2NomeEl.setAttribute('data-apelido', j2Apelido);

        const resultado = reserva.resultado;
        const jogoFinalizado = (reserva.status === 'finalizada' || reserva.status === 'resultado_pendente');

        // =========================================================
        // === 1. LÓGICA DE VISIBILIDADE DE PONTOS (DIREITA) ===
        // =========================================================
        const pontosJ1El = document.getElementById('placar-j1-points');
        const pontosJ2El = document.getElementById('placar-j2-points');
        
        let p1Display = '';
        let p2Display = '';
        let set3EstaNaDireita = false;

        if (jogoFinalizado) {
            p1Display = ''; p2Display = '';
        } else {
            // A. Verifica Super Tie-break (3º Set)
            let s3Placar = "";
            if (resultado.set3) {
                 if (typeof resultado.set3 === 'string') s3Placar = resultado.set3;
                 else if (resultado.set3.placar) s3Placar = resultado.set3.placar;
            }
            if (s3Placar.includes('x')) {
                 const [s3_1, s3_2] = s3Placar.split('x');
                 if (parseInt(s3_1) > 0 || parseInt(s3_2) > 0) {
                     p1Display = s3_1; p2Display = s3_2;
                     set3EstaNaDireita = true;
                 }
            }

            // B. Verifica Tie-Break Normal (1º ou 2º Set)
            if (!set3EstaNaDireita) {
                
                const getPlacarStr = (obj) => {
                    if (typeof obj === 'string') return obj;
                    if (obj && obj.placar) return obj.placar;
                    return "";
                };

                const s1Str = getPlacarStr(resultado.set1);
                const s2Str = getPlacarStr(resultado.set2);

                // Verifica se é exatamente '6x6'
                const isS1Empate = s1Str.trim() === '6x6';
                const isS2Empate = s2Str.trim() === '6x6';

                if (isS1Empate || isS2Empate) {
                    
                    // 1. Padrão: Força 0x0 IMEDIATAMENTE
                    p1Display = '0';
                    p2Display = '0';
                    
                    // 2. Tenta ler valores reais do banco
                    let tbSaved = "";
                    if (isS2Empate) {
                        tbSaved = (typeof resultado.set2 === 'object') ? (resultado.set2.tiebreak || "") : "";
                    } else {
                        tbSaved = (typeof resultado.set1 === 'object') ? (resultado.set1.tiebreak || "") : "";
                    }

                    // Se existir um placar real (ex: "1-0"), usa ele. 
                    // PROTEÇÃO: Só sobrescreve se o valor não for vazio.
                    if (tbSaved && tbSaved.includes('-')) {
                        const [t1, t2] = tbSaved.split('-');
                        
                        if (t1.trim() !== "") {
                            p1Display = t1;
                        }
                        if (t2.trim() !== "") {
                            p2Display = t2;
                        }
                    } 
                } 
                else if (resultado.pontos) {
                    // Modo Pontos Normais (15, 30, 40)
                    p1Display = resultado.pontos.j1 || '0';
                    p2Display = resultado.pontos.j2 || '0';
                }
            }
        }

        pontosJ1El.textContent = p1Display;
        pontosJ2El.textContent = p2Display;

        // --- ATUALIZAÇÃO DO SACADOR ---
        const ballJ1 = document.getElementById('placar-j1-server');
        const ballJ2 = document.getElementById('placar-j2-server');
        ballJ1.classList.remove('visible');
        ballJ2.classList.remove('visible');
        if (!jogoFinalizado) {
            if (resultado.sacador === 'j1') ballJ1.classList.add('visible');
            else if (resultado.sacador === 'j2') ballJ2.classList.add('visible');
        }

        // =========================================================
        // === 2. LÓGICA DOS SETS (MEIO) ===
        // =========================================================
        const j1SetsContainer = document.getElementById('placar-j1-sets');
        const j2SetsContainer = document.getElementById('placar-j2-sets');

        if (resultado.tipo === 'W.O.') {
             const vencedorWO = resultado.vencedor;
            const j1VenceuWO = (j1Apelido.toUpperCase() === vencedorWO.toUpperCase()) || (j1Info && j1Info.nomeCompleto.toUpperCase() === vencedorWO.toUpperCase());
            j1SetsContainer.classList.remove('contains-wo'); j2SetsContainer.classList.remove('contains-wo');
            if (j1VenceuWO) {
                j1SetsContainer.innerHTML = '<span class="placar-set set-vencedor wo-indicator">W.O.</span>';
                j1SetsContainer.classList.add('contains-wo'); j2SetsContainer.innerHTML = '';
            } else {
                j1SetsContainer.innerHTML = '';
                j2SetsContainer.innerHTML = '<span class="placar-set set-vencedor wo-indicator">W.O.</span>';
                j2SetsContainer.classList.add('contains-wo');
            }
        } else {
            j1SetsContainer.innerHTML = `
                <span class="placar-set" id="placar-j1-set1"></span>
                <span class="placar-set" id="placar-j1-set2"></span>
                <span class="placar-set" id="placar-j1-set3"></span>`;
            j2SetsContainer.innerHTML = `
                <span class="placar-set" id="placar-j2-set1"></span>
                <span class="placar-set" id="placar-j2-set2"></span>
                <span class="placar-set" id="placar-j2-set3"></span>`;

            let set1Finalizado = false;

            // SET 1
            const s1El_J1 = document.getElementById('placar-j1-set1');
            const s1El_J2 = document.getElementById('placar-j2-set1');
            s1El_J1.textContent = '0'; s1El_J2.textContent = '0';
            
            if (resultado.set1 && (resultado.set1.placar || typeof resultado.set1 === 'string')) {
                const placarStr = typeof resultado.set1 === 'string' ? resultado.set1 : resultado.set1.placar;
                const [s1, s2] = placarStr.split('x').map(Number);
                if (!isNaN(s1) && !isNaN(s2)) {
                    let tbHtml1 = '', tbHtml2 = '';
                    if ((s1===7 || s2===7) && resultado.set1.tiebreak && resultado.set1.tiebreak.includes('-')) {
                        const [tb1, tb2] = resultado.set1.tiebreak.split('-');
                        tbHtml1 = `<sup>${tb1}</sup>`; tbHtml2 = `<sup>${tb2}</sup>`;
                    }
                    s1El_J1.innerHTML = `${s1}${tbHtml1}`;
                    s1El_J2.innerHTML = `${s2}${tbHtml2}`;
                    if ((s1===6 && s2<=4) || (s2===6 && s1<=4) || (s1===7) || (s2===7)) {
                        set1Finalizado = true;
                        if (s1 > s2) s1El_J1.classList.add('set-vencedor');
                        else s1El_J2.classList.add('set-vencedor');
                    }
                }
            }

            // SET 2
            const s2El_J1 = document.getElementById('placar-j1-set2');
            const s2El_J2 = document.getElementById('placar-j2-set2');
            s2El_J1.textContent = ''; s2El_J2.textContent = '';
            if (set1Finalizado) {
                s2El_J1.textContent = '0'; s2El_J2.textContent = '0';
                if (resultado.set2 && (resultado.set2.placar || typeof resultado.set2 === 'string')) {
                    const placarStr = typeof resultado.set2 === 'string' ? resultado.set2 : resultado.set2.placar;
                    const [s1, s2] = placarStr.split('x').map(Number);
                    if (!isNaN(s1) && !isNaN(s2)) {
                        let tbHtml1 = '', tbHtml2 = '';
                        if ((s1===7 || s2===7) && resultado.set2.tiebreak && resultado.set2.tiebreak.includes('-')) {
                            const [tb1, tb2] = resultado.set2.tiebreak.split('-');
                            tbHtml1 = `<sup>${tb1}</sup>`; tbHtml2 = `<sup>${tb2}</sup>`;
                        }
                        s2El_J1.innerHTML = `${s1}${tbHtml1}`;
                        s2El_J2.innerHTML = `${s2}${tbHtml2}`;
                        if ((s1===6 && s2<=4) || (s2===6 && s1<=4) || (s1===7) || (s2===7)) {
                             if (s1 > s2) s2El_J1.classList.add('set-vencedor');
                             else s2El_J2.classList.add('set-vencedor');
                        }
                    }
                }
            }

            // SET 3
            const s3El_J1 = document.getElementById('placar-j1-set3');
            const s3El_J2 = document.getElementById('placar-j2-set3');
            s3El_J1.textContent = ''; s3El_J2.textContent = '';
            if (jogoFinalizado || !set3EstaNaDireita) {
                 if (resultado.set3) {
                     let placarStr = typeof resultado.set3 === 'string' ? resultado.set3 : resultado.set3.placar;
                     if (placarStr && placarStr.includes('x')) {
                         const [s1, s2] = placarStr.split('x').map(Number);
                         if (!isNaN(s1) && !isNaN(s2) && (s1 > 0 || s2 > 0)) {
                             s3El_J1.innerHTML = s1;
                             s3El_J2.innerHTML = s2;
                             if ((s1>=10 && s1-s2>=2) || (s2>=10 && s2-s1>=2)) {
                                 if (s1 > s2) s3El_J1.classList.add('set-vencedor');
                                 else s3El_J2.classList.add('set-vencedor');
                             }
                         }
                     }
                 }
            }
        }

        const liveIndicatorElement = document.querySelector('.live-indicator-placar');
        const vencedorDeclaracao = document.getElementById('placar-vencedor-declaracao');
        const j1NameElement = document.getElementById('placar-j1-nome');
        const j2NameElement = document.getElementById('placar-j2-nome');
        const j1RetElement = document.getElementById('placar-j1-ret');
        const j2RetElement = document.getElementById('placar-j2-ret');
        const motivoDesistenciaElement = document.getElementById('placar-motivo-desistencia');
        const mpAlert = document.getElementById('placar-mp-alert');

        if (jogoFinalizado) {
            liveIndicatorElement.innerHTML = '✓ JOGO FINALIZADO';
            liveIndicatorElement.style.color = '#4CAF50';
            mpAlert.style.display = 'none';

            const vencedorDoResultado = reserva.resultado.vencedor;
            const tipoVitoria = reserva.resultado.tipo === 'Placar Normal' ? '' : ` por ${reserva.resultado.tipo}`;
            const vencedorApelidoReal = (j1Apelido.toUpperCase() === vencedorDoResultado.toUpperCase() || (j1Info && j1Info.nomeCompleto.toUpperCase() === vencedorDoResultado.toUpperCase())) ? j1Apelido : j2Apelido;
            const vencedorInfoCompleto = jogadoresData[vencedorApelidoReal];
            const nomeParaExibir = vencedorInfoCompleto ? vencedorInfoCompleto.nomeCompleto : vencedorApelidoReal;
            
            vencedorDeclaracao.innerHTML = `🏆 Vitória de ${capitalizarNome(nomeParaExibir)}${tipoVitoria}`;
            vencedorDeclaracao.style.display = 'block';

            j1RetElement.innerHTML = ''; j2RetElement.innerHTML = '';
            if (reserva.resultado.tipo === 'Desistência') {
                const perdedorApelido = reserva.resultado.perdedor;
                if (j1Apelido.toUpperCase() === perdedorApelido.toUpperCase()) j1RetElement.innerHTML = '<span class="ret-indicator-placar">RET</span>';
                else if (j2Apelido.toUpperCase() === perdedorApelido.toUpperCase()) j2RetElement.innerHTML = '<span class="ret-indicator-placar">RET</span>';
            }

			const motivoReal = reserva.resultado.motivo || reserva.resultado.motivoWo || reserva.resultado.motivoDesistencia;
			if (motivoReal) {
				motivoDesistenciaElement.textContent = `Motivo: ${motivoReal}`;
				motivoDesistenciaElement.style.display = 'block';
			} else {
                motivoDesistenciaElement.style.display = 'none';
                motivoDesistenciaElement.textContent = '';
            }

            let j1_is_match_winner = false; let j2_is_match_winner = false;
            if (j1Apelido.toUpperCase() === vencedorDoResultado.toUpperCase()) j1_is_match_winner = true;
            else if (j2Apelido.toUpperCase() === vencedorDoResultado.toUpperCase()) j2_is_match_winner = true;
            if (!j1_is_match_winner && !j2_is_match_winner) {
                 if (j1Info && j1Info.nomeCompleto.toUpperCase() === vencedorDoResultado.toUpperCase()) j1_is_match_winner = true;
                 else if (j2Info && j2Info.nomeCompleto.toUpperCase() === vencedorDoResultado.toUpperCase()) j2_is_match_winner = true;
            }
            j1NameElement.classList.toggle('match-winner', j1_is_match_winner);
            j2NameElement.classList.toggle('match-winner', j2_is_match_winner);

        } else { 
            liveIndicatorElement.innerHTML = '<span class="live-indicator"></span> AO VIVO';
            liveIndicatorElement.style.color = '#ff4d4d';
            vencedorDeclaracao.style.display = 'none';
            if (reserva.resultado.isMatchPoint) mpAlert.style.display = 'inline-block';
            else mpAlert.style.display = 'none';
            j1RetElement.innerHTML = ''; j2RetElement.innerHTML = '';
            motivoDesistenciaElement.style.display = 'none';
            j1NameElement.classList.remove('match-winner'); j2NameElement.classList.remove('match-winner');
        }
        atualizarNomesPlacarAoVivo();
    };

    const listenerCallback = placarRef.on('value', callbackDoPlacar);
    listenerPlacarAoVivo = { ref: placarRef, callback: listenerCallback };
	
    const sessionId = localStorage.getItem("sessionId");
    if (sessionId) {
        espectadorRef = database.ref(`sistemas/espectadores/${quadra}/${key}/${sessionId}`); 
        espectadorRef.set({ entrada: firebase.database.ServerValue.TIMESTAMP, usuario: localStorage.getItem('jogadorLogado') || 'Anônimo' });
        espectadorRef.onDisconnect().remove();
        contadorEspectadoresRef = database.ref(`sistemas/espectadores/${quadra}/${key}`);
        contadorEspectadoresCallback = contadorEspectadoresRef.on('value', (snapshot) => {
            const espectadores = snapshot.val() || {};
            const numEspectadores = Object.keys(espectadores).length;
            const contadorEl = document.getElementById('placar-espectadores');
            const numeroEl = document.getElementById('numero-espectadores');
            if (contadorEl && numeroEl) {
                if (numEspectadores > 1) {
                    contadorEl.classList.add('mudou');
                    setTimeout(() => contadorEl.classList.remove('mudou'), 300);
                    numeroEl.textContent = numEspectadores - 1; 
                    contadorEl.style.display = 'inline-flex';
                    contadorEl.title = `${numEspectadores - 1} outra(s) pessoa(s) assistindo agora`;
                } else { contadorEl.style.display = 'none'; }
            }
        });
    }

    overlay.style.display = 'flex';
    entrarEmTelaCheia(overlay);
}








/**
 * Atualiza os nomes no placar ao vivo com base na orientação da tela.
 * Lê os nomes dos atributos data-* e define o textContent.
 */
// SUBSTITUA A FUNÇÃO atualizarNomesPlacarAoVivo COMPLETA POR ESTA:
function atualizarNomesPlacarAoVivo() {
    const j1NomeEl = document.getElementById('placar-j1-nome');
    const j2NomeEl = document.getElementById('placar-j2-nome');

    // Se os elementos não existirem (placar fechado), não faz nada.
    if (!j1NomeEl || !j2NomeEl) {
        return;
    }

    // 1. Lógica de detecção de tela (Horizontal vs Vertical)
    const isHorizontal = window.innerWidth > window.innerHeight;

    // Recupera os dados brutos salvos nos atributos data-*
    const j1NomeCompleto = j1NomeEl.getAttribute('data-nome-completo');
    const j1Apelido = j1NomeEl.getAttribute('data-apelido');
    
    const j2NomeCompleto = j2NomeEl.getAttribute('data-nome-completo');
    const j2Apelido = j2NomeEl.getAttribute('data-apelido');

    // 2. Aplica a formatação inteligente usando a função GLOBAL
    // Note que passamos 'isHorizontal' como terceiro parâmetro
    j1NomeEl.innerHTML = formatarNomeInteligente(j1NomeCompleto, j1Apelido, isHorizontal);
    j2NomeEl.innerHTML = formatarNomeInteligente(j2NomeCompleto, j2Apelido, isHorizontal);
}



/**
 * Pede ao navegador para colocar um elemento em modo de tela cheia.
 * @param {HTMLElement} element - O elemento a ser exibido em tela cheia.
 */
function entrarEmTelaCheia(element) {
    if (element.requestFullscreen) {
        element.requestFullscreen();
    } else if (element.webkitRequestFullscreen) { /* Safari */
        element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) { /* IE11 */
        element.msRequestFullscreen();
    }
}

/**
 * Pede ao navegador para sair do modo de tela cheia.
 */
/**
 * Pede ao navegador para sair do modo de tela cheia, SE ESTIVER ATIVO.
 */
function sairDaTelaCheia() {
    // A correção está aqui: verifica se o modo tela cheia está ativo antes de tentar sair.
    if (document.fullscreenElement) {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
    }
}


/**
 * Tenta enviar logs pendentes armazenados no localStorage para o GitHub.
 */
async function tentarEnviarLogsPendentes() {
    console.log("🔄 Verificando logs pendentes no localStorage...");
    const logsFallbackString = localStorage.getItem('logs_fallback');
    if (!logsFallbackString) {
        console.log("✅ Nenhum log pendente encontrado.");
        return; // Sai se não houver logs
    }

    let logsPendentes;
    try {
        logsPendentes = JSON.parse(logsFallbackString);
        if (!Array.isArray(logsPendentes) || logsPendentes.length === 0) {
            console.log("✅ logs_fallback está vazio ou inválido. Limpando.");
            localStorage.removeItem('logs_fallback');
            return;
        }
    } catch (e) {
        console.error("❌ Erro ao parsear logs_fallback do localStorage. Limpando:", e);
        localStorage.removeItem('logs_fallback');
        return;
    }

    console.log(`⏳ Encontrados ${logsPendentes.length} logs pendentes. Tentando enviar para o GitHub...`);

    const token = githubToken; // Usa o token global já carregado
    if (!token) {
        console.warn("⚠️ Token do GitHub não disponível. Não é possível enviar logs pendentes.");
        return; // Não pode continuar sem o token
    }
    const usuarioGit = 'clube-olimpico';
    const repo = 'Reservas';
    const caminhoArquivo = 'logs/reservas-excluidas.json';
    const url = `https://api.github.com/repos/${usuarioGit}/${repo}/contents/${caminhoArquivo}`;

    try {
        // 1. Obter a versão atual do arquivo no GitHub
        let response = await fetch(url, {
            headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
        });

        if (!response.ok) {
           // Se o arquivo não existir (404), trata como um array vazio
            if (response.status === 404) {
                console.log("ℹ️ Arquivo de log não encontrado no GitHub. Será criado um novo.");
                fileData = { sha: null, content: '' }; // Simula dados de arquivo vazio
            } else {
                throw new Error(`Erro ao buscar arquivo existente: ${response.status} ${response.statusText}`);
            }
        } else {
             fileData = await response.json();
        }


        let logsExistentes = [];
        if (fileData.content) {
            try {
                // Decodifica o conteúdo existente
                logsExistentes = JSON.parse(b64_to_utf8(fileData.content)) || [];
            } catch (e) {
                console.warn('Falha ao decodificar logs existentes do GitHub, iniciando novo', e);
            }
        }

        // 2. Combinar logs existentes com os pendentes
        const todosLogs = [...logsExistentes, ...logsPendentes];

        // 3. Enviar a versão atualizada para o GitHub
        response = await fetch(url, {
            method: 'PUT',
            headers: { 'Authorization': `token ${token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: `Sincronização: ${logsPendentes.length} logs pendentes enviados do localStorage`,
                // Codifica o conteúdo combinado
                content: utf8_to_b64(JSON.stringify(todosLogs, null, 2)),
                sha: fileData.sha // Envia o SHA da versão que lemos para evitar conflitos
            })
        });

        if (!response.ok) {
            throw new Error(`Falha no upload para o GitHub: ${response.status} ${response.statusText}`);
        }

        // 4. Se o envio foi bem-sucedido, limpar o localStorage
        localStorage.removeItem('logs_fallback');
        console.log(`✅ ${logsPendentes.length} logs pendentes enviados com sucesso e removidos do localStorage.`);

    } catch (erro) {
        console.error('❌ Erro ao tentar enviar logs pendentes para o GitHub:', erro);
        // Não remove do localStorage se falhar, para tentar novamente depois
    }
}

window.addEventListener('online', () => {
    console.log("🟢 Conexão reestabelecida. Verificando logs pendentes..."); 
    if (githubToken) { // Verifica se o token já está disponível
        tentarEnviarLogsPendentes();
    }
});


// EM "app-reservas - ativo.html" (Linha 8247)
// SUBSTITUA O BLOCO "LEGENDA RECOLHÍVEL" INTEIRO POR ESTE:

// === JAVASCRIPT PARA LEGENDA E AGENDA RECOLHÍVEL ===
document.addEventListener('DOMContentLoaded', function() {
    
    // --- LÓGICA DA LEGENDA (Sem alterações) ---
    legendaTrigger = document.getElementById('legenda-trigger');
    legendaConteudo = document.getElementById('legenda');
    const legendaIcone = document.getElementById('legenda-icone');

    if (legendaTrigger && legendaConteudo && legendaIcone) {
        legendaTrigger.addEventListener('click', function() {
            if (navigator.vibrate) { navigator.vibrate(50); } // Vibração
            const isVisivel = legendaConteudo.style.display === 'block';

            if (isVisivel) {
                legendaConteudo.style.display = 'none';
                legendaTrigger.classList.remove('expandido');
            } else {
                legendaConteudo.style.display = 'block';
                legendaTrigger.classList.add('expandido');
                atualizarLegenda(piramideAtivaGlobal);
            }
        });
        atualizarLegenda(piramideAtivaGlobal); 
    }
    
    // ============================================
    // --- LÓGICA DA AGENDA (SOB DEMANDA) ---
    // ============================================
    agendaTrigger = document.getElementById('agenda-trigger');
    agendaConteudo = document.getElementById('agenda-conteudo');

    if (agendaTrigger && agendaConteudo) {
        agendaTrigger.addEventListener('click', async () => { // <-- Ação agora é async
            if (navigator.vibrate) { 
                navigator.vibrate(50);
            }

            const isVisivel = agendaConteudo.style.display === 'block';

            if (isVisivel) {
                // Se está visível, apenas esconde
                agendaConteudo.style.display = 'none';
                agendaTrigger.classList.remove('expandido');
            } else {
                // Se está escondido:
                // 1. Mostra o painel e gira a seta
                agendaConteudo.style.display = 'block';
                agendaTrigger.classList.add('expandido');
                
                // 2. Chama a função para buscar, formatar e preencher o painel
                const reservaEncontrada = await atualizarEExibirProximaReserva();
                
                // 3. Se uma reserva foi retornada, muda a quadra (Item 3 aprovado)
                if (reservaEncontrada) {
                    if (quadraSelecionada !== reservaEncontrada.quadra) {
                        selecionarQuadra(reservaEncontrada.quadra);
                    }
                }
            }
        });
    }
    // ============================================

});
// === FIM DO JAVASCRIPT ===


/**
 * Verifica se QUALQUER campo de placar tem valor REAL (diferente de zero e vazio).
 * @returns {boolean} True se houver jogo iniciado, False se estiver 0x0.
 */
/**
 * Verifica se há placar digitado APENAS na tela ativa no momento.
 * Isso evita que dados antigos nos campos ocultos atrapalhem a lógica do menu.
 */
function hasPlacarParcial() {
    const containerSumula = document.getElementById('simple-score-container');
    // Verifica se estamos no modo Súmula
    const isModoSumula = containerSumula && containerSumula.style.display !== 'none';

    let idsToCheck = [];

    if (isModoSumula) {
        // Se estiver na Súmula, olha SÓ para a Súmula
        idsToCheck = [
            'simple-s1-j1', 'simple-s1-j2', 'simple-s2-j1', 'simple-s2-j2', 'simple-s3-j1', 'simple-s3-j2',
            'simple-tb1-j1', 'simple-tb1-j2', 'simple-tb2-j1', 'simple-tb2-j2'
        ];
    } else {
        // Se estiver na Arbitragem, olha SÓ para a Arbitragem
        idsToCheck = [
            'set1-j1', 'set1-j2', 'set2-j1', 'set2-j2', 'set3-j1', 'set3-j2',
            'tb1-j1', 'tb1-j2', 'tb2-j1', 'tb2-j2'
        ];
    }
    
    return idsToCheck.some(id => {
        const input = document.getElementById(id);
        // Jogo iniciado = Tem valor E não é '0' E não é vazio
        return input && input.value.trim() !== '' && input.value.trim() !== '0'; 
    });
}



// Variável global para armazenar temporariamente os valores de placar não salvos
let tempUnsavedScores = {};

/**
 * Salva o valor atual de todos os inputs de placar em um cache temporário.
 */
function saveUnsavedScores() {
    const idsToSave = [
        'set1-j1', 'set1-j2', 'set2-j1', 'set2-j2', 
        'set3-j1', 'set3-j2', 'tb1-j1', 'tb1-j2', 'tb2-j1', 'tb2-j2'
    ];
    idsToSave.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            // Salva o valor atual (mesmo que seja '')
            tempUnsavedScores[id] = input.value; 
        }
    });
}

/**
 * Restaura os valores do cache temporário para os inputs de placar.
 */
function restoreUnsavedScores() {
    const idsToRestore = Object.keys(tempUnsavedScores);
    idsToRestore.forEach(id => {
        const input = document.getElementById(id);
        if (input && tempUnsavedScores[id] !== undefined) {
            // Restaura o valor do cache
            input.value = tempUnsavedScores[id]; 
        }
    });
    // Limpar o cache temporário após a restauração para evitar contaminação
    tempUnsavedScores = {}; 
}



/**
 * Aplica/remove o estilo de itálico do <select> se um convidado nomeado estiver selecionado.
 */
function atualizarEstiloSelectConvidado(selectElement) {
    if (!selectElement) return;
    
    const valorSelecionado = selectElement.value;
    
    // Verifica se o valor é "Convidado - Nome" OU se é o "Convidado" genérico
    if (valorSelecionado.startsWith("Convidado - ") || valorSelecionado === "Convidado") {
        selectElement.classList.add('select-convidado-nomeado');
    } else {
        selectElement.classList.remove('select-convidado-nomeado');
    }
}


/**
 * Chamada sempre que um dropdown de jogador é alterado.
 * Se "Convidado" for selecionado, chama o modal de input.
 * Se outro valor for selecionado, limpa o mapa.
 */
function handleConvidadoSelect(selectElement) {
    // 1. Verifica se a opção selecionada é "Convidado"
    if (selectElement.value === "Convidado") {
        // Chama o nosso novo modal elegante
        mostrarModalInputNome(selectElement);

    } else {
        // Se o usuário selecionou um sócio ou um convidado já nomeado,
        // limpa qualquer nome antigo que estava salvo para este campo.
        delete nomesConvidadosMap[selectElement.id];
    }
	atualizarEstiloSelectConvidado(selectElement);
}


/**
 * Abre o modal de input de nome e guarda qual dropdown o chamou.
 */
function mostrarModalInputNome(selectElement) {
    // Guarda a referência de qual <select> estamos editando
    elementoSelectConvidadoAtual = selectElement;

    // Limpa o campo de texto do modal e foca nele
    const inputNome = document.getElementById('inputNomeConvidado');
    inputNome.value = '';
    
    // Mostra o modal
    document.getElementById('modalInputNomeOverlay').style.display = 'flex';
    
    // Foca no campo de texto para o usuário já sair digitando
    inputNome.focus();
}

/**
 * Chamada pelo botão "Confirmar" do novo modal.
 * Valida o nome, salva no mapa e fecha o modal.
 */
// CÓDIGO NOVO E CORRIGIDO
function confirmarNomeConvidado() {
    if (!elementoSelectConvidadoAtual) return;

    const inputNome = document.getElementById('inputNomeConvidado');
    const nomeConvidado = inputNome.value.trim();
    const modalEdicao = document.getElementById('modalEdicaoReserva'); // Pega o modal de edição

    if (nomeConvidado !== "") {
        const nomeCapitalizado = capitalizarNome(nomeConvidado); // ex: "Jose Maria"
        const nomeFormatado = `Convidado - ${nomeCapitalizado}`; // ex: "Convidado - Jose Maria"
        
        // Salva no mapa (para o 'salvarEdicao' ou 'atualizarTabela' ler)
        nomesConvidadosMap[elementoSelectConvidadoAtual.id] = nomeFormatado;

        // --- INÍCIO DA NOVA LÓGICA ---
        // Verifica se o dropdown que estamos editando está DENTRO do modal de edição
        const isInEditModal = modalEdicao && modalEdicao.contains(elementoSelectConvidadoAtual);

        if (isInEditModal) {
            // Estamos no modal "Editar Jogadores"
            
            // 1. Remove qualquer <option> de convidado nomeado antiga (ex: "Joao Maria")
            const oldGuestOption = elementoSelectConvidadoAtual.querySelector('.convidado-nomeado-option');
            if (oldGuestOption) {
                oldGuestOption.remove();
            }

            // 2. Cria a nova <option> para o novo convidado
            const newGuestOption = document.createElement('option');
            newGuestOption.value = nomeFormatado;        // Valor interno: "Convidado - Jose Maria"
            newGuestOption.textContent = nomeCapitalizado; // Texto visível: "Jose Maria"
            newGuestOption.classList.add('convidado-nomeado-option'); // Adiciona a classe de estilo
            
            // 3. Adiciona e seleciona a nova opção
            elementoSelectConvidadoAtual.appendChild(newGuestOption);
            elementoSelectConvidadoAtual.value = nomeFormatado;
			atualizarEstiloSelectConvidado(elementoSelectConvidadoAtual);
            
        } else {
            // Estamos no formulário de agendamento principal
            // Apenas mantém o valor "Convidado"
            elementoSelectConvidadoAtual.value = "Convidado"; 
			atualizarEstiloSelectConvidado(elementoSelectConvidadoAtual);
        }
        // --- FIM DA NOVA LÓGICA ---
        
        document.getElementById('modalInputNomeOverlay').style.display = 'none';
    } else {
        mostrarNotificacao("O nome do convidado não pode ficar em branco.", 'error');
    }
}



/**
 * Chamada pelo botão "Cancelar" do novo modal.
 * Reseta o dropdown e fecha o modal.
 */
function cancelarNomeConvidado() {
    if (elementoSelectConvidadoAtual) {
        // Reseta o dropdown para "Selecione um jogador"
        elementoSelectConvidadoAtual.value = ""; 
        // Limpa o mapa
        delete nomesConvidadosMap[elementoSelectConvidadoAtual.id];
    }
    document.getElementById('modalInputNomeOverlay').style.display = 'none';
}


/**
 * Função acionada pelos botões + e -
 * ATUALIZADA: Com Rotação Automática no Tie-Break
 */
function ajustarPonto(jogador, delta) {
    const oponente = jogador === 'j1' ? 'j2' : 'j1';
    const setAtivo = setEmEdicao || determinarSetAtivo();
    const isTieBreak = (setEmEdicao !== null) || verificarSeEhTieBreak(setAtivo);
    
    estadoPontos.tiebreakMode = isTieBreak;
    const isNoAd = document.getElementById('chk-modo-no-ad') ? document.getElementById('chk-modo-no-ad').checked : false;

    let pJog = estadoPontos[jogador];
    let pOp = estadoPontos[oponente];

    // --- CENÁRIO A: TIE-BREAK ---
    if (isTieBreak) {
        const pontosAntes = pJog + pOp; // Guardamos o total antes
        
        pJog += delta;
        if (pJog < 0) pJog = 0;

        // Atualiza campos ocultos do Set 1 e 2
        if (setAtivo !== 3) {
            const inputTbJ1 = document.getElementById(`tb${setAtivo}-j1`);
            const inputTbJ2 = document.getElementById(`tb${setAtivo}-j2`);
            if (inputTbJ1 && inputTbJ2) {
                if (jogador === 'j1') { inputTbJ1.value = pJog; inputTbJ2.value = pOp; }
                else { inputTbJ1.value = pOp; inputTbJ2.value = pJog; }
            }
        }
        
        // --- AUTOMAÇÃO DE SAQUE (TIE-BREAK) ---
        // Regra: No Tie-break, o saque muda sempre que a SOMA DOS PONTOS for ÍMPAR (1, 3, 5...)
        // Executamos apenas se estamos ADICIONANDO ponto (delta > 0) para evitar confusão no "desfazer"
        if (delta > 0) {
            const somaPontos = pJog + pOp;
            // Se a soma é ímpar, troca o sacador
            if (somaPontos % 2 !== 0) {
                inverterSacador();
            }
        }
        // --------------------------------------

        // Verifica vitória do Tie-break
        const alvo = (setAtivo === 3) ? 10 : 7;
        if (delta > 0 && pJog >= alvo && (pJog - pOp) >= 2) {
            const gameAtual = parseInt(document.getElementById(`set${setAtivo}-${jogador}`).value) || 0;
            const gameOponente = parseInt(document.getElementById(`set${setAtivo}-${oponente}`).value) || 0;
            const podeIncrementar = setAtivo !== 3 && gameAtual < 7 && gameOponente < 7;

            if (podeIncrementar) {
                incrementarGame(setAtivo, jogador);
            }
            
            // Verifica consistência para limpar pontos
            let vencedorCoerente = true;
            if (setEmEdicao && setAtivo !== 3 && ((gameAtual === 7 && gameOponente === 6) || (gameAtual === 6 && gameOponente === 7))) {
                if (gameAtual !== 7) vencedorCoerente = false;
            }

            if (vencedorCoerente) {
                if (setAtivo !== 3) {
                    pJog = 0; pOp = 0;
                }
                setEmEdicao = null; 
            }
        }
    } 
    // --- CENÁRIO B: GAME NORMAL ---
    else {
        if (setAtivo !== 3) {
            const inputTbJ1 = document.getElementById(`tb${setAtivo}-j1`);
            const inputTbJ2 = document.getElementById(`tb${setAtivo}-j2`);
            if (inputTbJ1) inputTbJ1.value = '';
            if (inputTbJ2) inputTbJ2.value = '';
        }

        if (delta > 0) {
            if (pJog === 3 && pOp < 3) { incrementarGame(setAtivo, jogador); pJog = 0; pOp = 0; }
            else if (pJog === 3 && pOp === 3) { 
                if (isNoAd) { incrementarGame(setAtivo, jogador); pJog = 0; pOp = 0; } 
                else { pJog = 4; }
            }
            else if (pJog === 4) { incrementarGame(setAtivo, jogador); pJog = 0; pOp = 0; }
            else if (pJog === 3 && pOp === 4) { pOp = 3; }
            else { pJog++; }
        } else {
            if (pJog > 0) pJog--;
            if (pJog === 3 && pOp === 3) { } 
        }
    }

    estadoPontos[jogador] = pJog;
    estadoPontos[oponente] = pOp;
    
    if (setAtivo === 3) {
        document.getElementById(`set3-j1`).value = estadoPontos.j1;
        document.getElementById(`set3-j2`).value = estadoPontos.j2;
    }
    
    atualizarDisplayPontos();
    calcularVencedorPiramide(); 
	
	atualizarBotaoSalvarResultado(false);
	triggerAutoSave();
}






// --- FUNÇÕES AUXILIARES ---

function atualizarDisplayPontos() {
    const dispJ1 = document.getElementById('pontos-j1');
    const dispJ2 = document.getElementById('pontos-j2');
    
    // --- BLINDAGEM CONTRA ERRO DE ELEMENTO NÃO ENCONTRADO ---
    if (!dispJ1 || !dispJ2) {
        console.warn("⚠️ Aviso: Elementos de placar 'pontos-j1' ou 'pontos-j2' não encontrados. Ignorando atualização visual.");
        return; // Sai da função suavemente sem quebrar o sistema
    }
    // --------------------------------------------------------

    if (estadoPontos.tiebreakMode) {
        // Mostra número puro (1, 2, 3...)
        dispJ1.textContent = estadoPontos.j1;
        dispJ2.textContent = estadoPontos.j2;
    } else {
        // Mostra formato Tênis (15, 30, 40)
        dispJ1.textContent = mapaPontos[estadoPontos.j1] || estadoPontos.j1;
        dispJ2.textContent = mapaPontos[estadoPontos.j2] || estadoPontos.j2;
    }
}



function incrementarGame(setNum, jogador) {
    // Super Tie-break (Set 3) não incrementa game
    if (setNum === 3) return; 

    const inputId = `set${setNum}-${jogador}`;
    const input = document.getElementById(inputId);
    
    if (input) {
        let valorAtual = parseInt(input.value) || 0;
        input.value = valorAtual + 1;
        
        // --- AUTOMAÇÃO DE SAQUE (GAME) ---
        // Sempre que um game termina, o saque troca de lado
        inverterSacador();
        // ---------------------------------
        
        calcularVencedorPiramide(); 
		
		triggerAutoSave();
    }
}



function determinarSetAtivo() {
    // --- SET 1 ---
    const s1j1 = parseInt(document.getElementById('set1-j1').value) || 0;
    const s1j2 = parseInt(document.getElementById('set1-j2').value) || 0;
    
    // 1. Se o placar de games não finalizou (ex: 4-4, 6-6), é aqui mesmo
    if (!isSetFinalizado(s1j1, s1j2)) return 1;
    
    // 2. CORREÇÃO: Se finalizou em TIE-BREAK (7-6), mas os pontos estão incompletos
    if ((s1j1 === 7 && s1j2 === 6) || (s1j1 === 6 && s1j2 === 7)) {
        const tb1 = parseInt(document.getElementById('tb1-j1').value) || 0;
        const tb2 = parseInt(document.getElementById('tb1-j2').value) || 0;
        
        // Um tie-break só acaba quando alguém tem 7+ pontos E diferença de 2
        const tbAcabou = (tb1 >= 7 || tb2 >= 7) && Math.abs(tb1 - tb2) >= 2;
        
        // Se o tie-break não acabou (ex: está 0-0 ou 5-4), CONTINUA NO SET 1
        if (!tbAcabou) return 1;
    }

    // --- SET 2 ---
    const s2j1 = parseInt(document.getElementById('set2-j1').value) || 0;
    const s2j2 = parseInt(document.getElementById('set2-j2').value) || 0;

    if (!isSetFinalizado(s2j1, s2j2)) return 2;

    // Mesma lógica para Set 2
    if ((s2j1 === 7 && s2j2 === 6) || (s2j1 === 6 && s2j2 === 7)) {
        const tb1 = parseInt(document.getElementById('tb2-j1').value) || 0;
        const tb2 = parseInt(document.getElementById('tb2-j2').value) || 0;
        const tbAcabou = (tb1 >= 7 || tb2 >= 7) && Math.abs(tb1 - tb2) >= 2;
        if (!tbAcabou) return 2;
    }

    return 3;
}




function verificarSeEhTieBreak(setAtivo) {
    // O 3º Set é SEMPRE numérico (Super Tie-break)
    if (setAtivo === 3) return true; 
    
    const el1 = document.getElementById(`set${setAtivo}-j1`);
    const el2 = document.getElementById(`set${setAtivo}-j2`);
    
    // Função auxiliar interna para ignorar o "(5)" e ler só o "7"
    const cleanVal = (val) => parseInt(val.toString().split('(')[0]) || 0;
    
    const g1 = cleanVal(el1.value);
    const g2 = cleanVal(el2.value);
    
    // É Tie-break se:
    // 1. Estiver empatado em 6-6
    // 2. JÁ TIVER ACABADO em 7-6 ou 6-7 (Estamos editando)
    if (g1 === 6 && g2 === 6) return true;
    if (g1 === 7 && g2 === 6) return true;
    if (g1 === 6 && g2 === 7) return true;

    return false;
}


function isSetFinalizado(val1, val2) {
    const v1 = parseInt(val1) || 0;
    const v2 = parseInt(val2) || 0;
    // 6-0, 6-1, 6-2, 6-3, 6-4
    if ((v1 === 6 && v2 <= 4) || (v2 === 6 && v1 <= 4)) return true;
    // 7-5
    if ((v1 === 7 && v2 === 5) || (v2 === 7 && v1 === 5)) return true;
    // 7-6 (Tie-break)
    if ((v1 === 7 && v2 === 6) || (v2 === 7 && v1 === 6)) return true;
    
    return false;
}




/**
 * Analisa os placares, aplica negrito, auto-corrige 6x6 e controla a visibilidade do Botão de Opções.
 */
function calcularVencedorPiramide() {
    // 0. DETECÇÃO DE MODO E HELPERS
    const containerSumula = document.getElementById('simple-score-container');
    const isModoSumula = containerSumula && containerSumula.style.display !== 'none';

    const p = isModoSumula ? 'simple-' : ''; 
    const tipoInput = isModoSumula ? 's' : 'set';
    
    const getVal = (id) => {
        const el = document.getElementById(id);
        if (!el) return 0;
        const valLimpo = el.value.replace(/[^0-9]/g, '');
        return valLimpo === '' ? 0 : parseInt(valLimpo, 10);
    };
    
    // 1. LEITURA DOS VALORES
    let s1j1 = getVal(`${p}${tipoInput}1-j1`); 
    let s1j2 = getVal(`${p}${tipoInput}1-j2`);
    let s2j1 = getVal(`${p}${tipoInput}2-j1`); 
    let s2j2 = getVal(`${p}${tipoInput}2-j2`);
    const s3j1 = getVal(`${p}${tipoInput}3-j1`); 
    const s3j2 = getVal(`${p}${tipoInput}3-j2`);
    
    const tb1j1 = getVal(`${p}tb1-j1`); 
    const tb1j2 = getVal(`${p}tb1-j2`);
    const tb2j1 = getVal(`${p}tb2-j1`); 
    const tb2j2 = getVal(`${p}tb2-j2`);

    // =========================================================================
    // === AUTO-CORREÇÃO INTELIGENTE (Monitora quem ganhou o TB) ===
    // =========================================================================
    const aplicarCorrecaoSet = (s1, s2, t1, t2, idInput1, idInput2) => {
        const isTieBreakScenario = (s1 === 6 && s2 === 6) || (s1 === 7 && s2 === 6) || (s1 === 6 && s2 === 7);

        if (isTieBreakScenario) {
            const max = Math.max(t1, t2);
            const min = Math.min(t1, t2);
            const diff = max - min;
            const tbFinished = (max === 7 && diff >= 2) || (max > 7 && diff >= 2);

            if (tbFinished) {
                if (t1 > t2) {
                    document.getElementById(idInput1).value = 7;
                    document.getElementById(idInput2).value = 6;
                    return { novoS1: 7, novoS2: 6 };
                } else {
                    document.getElementById(idInput1).value = 6;
                    document.getElementById(idInput2).value = 7;
                    return { novoS1: 6, novoS2: 7 };
                }
            } else {
                if (s1 !== 6 || s2 !== 6) {
                    document.getElementById(idInput1).value = 6;
                    document.getElementById(idInput2).value = 6;
                    return { novoS1: 6, novoS2: 6 };
                }
            }
        }
        return null; 
    };

    const corr1 = aplicarCorrecaoSet(s1j1, s1j2, tb1j1, tb1j2, `${p}${tipoInput}1-j1`, `${p}${tipoInput}1-j2`);
    if (corr1) { s1j1 = corr1.novoS1; s1j2 = corr1.novoS2; }

    const corr2 = aplicarCorrecaoSet(s2j1, s2j2, tb2j1, tb2j2, `${p}${tipoInput}2-j1`, `${p}${tipoInput}2-j2`);
    if (corr2) { s2j1 = corr2.novoS1; s2j2 = corr2.novoS2; }
    // =========================================================================


    // 2. ATUALIZAÇÃO VISUAL DOS BADGES
    const isTb1 = (s1j1 === 6 && s1j2 === 6) || (s1j1 === 7 && s1j2 === 6) || (s1j2 === 7 && s1j1 === 6);
    const isTb2 = (s2j1 === 6 && s2j2 === 6) || (s2j1 === 7 && s2j2 === 6) || (s2j2 === 7 && s2j1 === 6);

    if (isTb1) {
        const v1 = isModoSumula ? tb1j1 : document.getElementById('tb1-j1').value;
        const v2 = isModoSumula ? tb1j2 : document.getElementById('tb1-j2').value;
        if(document.getElementById('view-tb1-j1')) document.getElementById('view-tb1-j1').textContent = v1;
        if(document.getElementById('view-tb1-j2')) document.getElementById('view-tb1-j2').textContent = v2;
    } else {
        if(document.getElementById('view-tb1-j1')) document.getElementById('view-tb1-j1').textContent = '';
        if(document.getElementById('view-tb1-j2')) document.getElementById('view-tb1-j2').textContent = '';
    }

    if (isTb2) {
        const v1 = isModoSumula ? tb2j1 : document.getElementById('tb2-j1').value;
        const v2 = isModoSumula ? tb2j2 : document.getElementById('tb2-j2').value;
        if(document.getElementById('view-tb2-j1')) document.getElementById('view-tb2-j1').textContent = v1;
        if(document.getElementById('view-tb2-j2')) document.getElementById('view-tb2-j2').textContent = v2;
    } else {
        if(document.getElementById('view-tb2-j1')) document.getElementById('view-tb2-j1').textContent = '';
        if(document.getElementById('view-tb2-j2')) document.getElementById('view-tb2-j2').textContent = '';
    }

    // 3. LÓGICA DE VENCEDOR
    let setsJ1 = 0;
    let setsJ2 = 0;
    let vencedorFinal = null;
    let jogoConcluido = false;
    let isTieBreakAtivo = false;

    const vencedorSet1 = determinarVencedorSet(s1j1, s1j2, tb1j1, tb1j2);
    let vencedorSet2 = null;
    let vencedorSet3 = null;

    if ((s1j1 === 6 && s1j2 === 6) || (s2j1 === 6 && s2j2 === 6)) isTieBreakAtivo = true;
    if (setEmEdicao && ((setEmEdicao===1 && isTb1) || (setEmEdicao===2 && isTb2))) isTieBreakAtivo = true;

    const wrapperSet2J1 = document.getElementById('wrapper-set2-j1');
    const wrapperSet2J2 = document.getElementById('wrapper-set2-j2');
    const elSet2J1 = document.getElementById('set2-j1'); 
    const elSet2J2 = document.getElementById('set2-j2');
    const elSet3J1 = document.getElementById('set3-j1');
    const elSet3J2 = document.getElementById('set3-j2');

    if (vencedorSet1) {
        if (vencedorSet1 === 'j1') setsJ1++; else setsJ2++;
        
        if(wrapperSet2J1) wrapperSet2J1.classList.remove('sb-hidden'); 
        if(wrapperSet2J2) wrapperSet2J2.classList.remove('sb-hidden');
        if(document.getElementById('header-set2')) document.getElementById('header-set2').classList.remove('sb-hidden');
        if(elSet2J1) elSet2J1.disabled = false; 
        if(elSet2J2) elSet2J2.disabled = false;

        vencedorSet2 = determinarVencedorSet(s2j1, s2j2, tb2j1, tb2j2);

        if (vencedorSet2) {
            if (vencedorSet2 === 'j1') setsJ1++; else setsJ2++;

            if (setsJ1 === 2) { vencedorFinal = 'j1'; jogoConcluido = true; }
            else if (setsJ2 === 2) { vencedorFinal = 'j2'; jogoConcluido = true; }
            else {
                if(elSet3J1) { elSet3J1.disabled = false; elSet3J1.classList.remove('sb-hidden'); }
                if(elSet3J2) { elSet3J2.disabled = false; elSet3J2.classList.remove('sb-hidden'); }
                if(document.getElementById('header-set3')) document.getElementById('header-set3').classList.remove('sb-hidden');
                isTieBreakAtivo = true; 
                if ((s3j1 >= 10 && (s3j1 - s3j2) >= 2) || (s3j2 >= 10 && (s3j2 - s3j1) >= 2)) {
                    jogoConcluido = true;
                    vencedorFinal = (s3j1 > s3j2) ? 'j1' : 'j2';
                    vencedorSet3 = vencedorFinal;
                    isTieBreakAtivo = false;
                }
            }
        } else {
            if(elSet3J1) elSet3J1.classList.add('sb-hidden');
            if(elSet3J2) elSet3J2.classList.add('sb-hidden');
            if(document.getElementById('header-set3')) document.getElementById('header-set3').classList.add('sb-hidden');
        }
    } else {
        if(wrapperSet2J1) wrapperSet2J1.classList.add('sb-hidden');
        if(wrapperSet2J2) wrapperSet2J2.classList.add('sb-hidden');
        if(document.getElementById('header-set2')) document.getElementById('header-set2').classList.add('sb-hidden');
        if(elSet3J1) elSet3J1.classList.add('sb-hidden');
        if(elSet3J2) elSet3J2.classList.add('sb-hidden');
        if(document.getElementById('header-set3')) document.getElementById('header-set3').classList.add('sb-hidden');
    }

    const aplicarEstiloVencedor = (setNum, vencedor) => {
        const idsJ1 = [`set${setNum}-j1`, `simple-s${setNum}-j1`, `tb${setNum}-j1`, `simple-tb${setNum}-j1`, `view-tb${setNum}-j1`];
        const idsJ2 = [`set${setNum}-j2`, `simple-s${setNum}-j2`, `tb${setNum}-j2`, `simple-tb${setNum}-j2`, `view-tb${setNum}-j2`];

        idsJ1.forEach(id => { const el = document.getElementById(id); if (el) el.classList.toggle('input-winner', vencedor === 'j1'); });
        idsJ2.forEach(id => { const el = document.getElementById(id); if (el) el.classList.toggle('input-winner', vencedor === 'j2'); });
    };

    aplicarEstiloVencedor(1, vencedorSet1);
    aplicarEstiloVencedor(2, vencedorSet2);
    aplicarEstiloVencedor(3, vencedorSet3);

    const nomes = {
        j1: [document.getElementById('apelido-j1'), document.getElementById('simple-name-j1')],
        j2: [document.getElementById('apelido-j2'), document.getElementById('simple-name-j2')]
    };

    nomes.j1.forEach(el => { if(el) { el.style.fontWeight = '400'; el.style.color = ''; } });
    nomes.j2.forEach(el => { if(el) { el.style.fontWeight = '400'; el.style.color = ''; } });

    let nomeVencedorFinal = '';
    if (vencedorFinal === 'j1') {
        nomes.j1.forEach(el => { if(el) el.style.fontWeight = '900'; });
        const el = document.getElementById('apelido-j1');
        if(el) nomeVencedorFinal = el.getAttribute('data-apelido');
    } else if (vencedorFinal === 'j2') {
        nomes.j2.forEach(el => { if(el) el.style.fontWeight = '900'; });
        const el = document.getElementById('apelido-j2');
        if(el) nomeVencedorFinal = el.getAttribute('data-apelido');
    }

    const labelGame = document.getElementById('label-game-points');
    if (labelGame) {
        labelGame.textContent = isTieBreakAtivo ? "TIE-BREAK" : "GAME";
        labelGame.style.color = isTieBreakAtivo ? "#e67e22" : ""; 
        labelGame.style.fontSize = isTieBreakAtivo ? "0.6rem" : ""; 
    }

    const elResultadoVencedor = document.getElementById('resultado-vencedor');
    if(elResultadoVencedor) elResultadoVencedor.textContent = nomeVencedorFinal || '';
    
    atualizarBotaoSalvarResultado(jogoConcluido);

    // =========================================================================
    // === 4. CONTROLE DO BOTÃO DE OPÇÕES (⋮) ===
    // Se o jogo acabou (tem vencedor), esconde o botão de opções.
    // Se o usuário editar (apagar o vencedor), o botão reaparece.
    // =========================================================================
    const btnMaisOpcoes = document.getElementById('btn-mais-opcoes');
    if (btnMaisOpcoes) {
        if (nomeVencedorFinal) {
            btnMaisOpcoes.style.display = 'none';
            // Garante que o menu feche se estiver aberto
            const menu = document.getElementById('menu-opcoes-resultado');
            if (menu) menu.classList.remove('visivel');
        } else {
            // Remove o display inline (none) para que o CSS (flex/block) assuma
            btnMaisOpcoes.style.display = '';
        }
    }
    // =========================================================================

    return nomeVencedorFinal;
}





// --- FUNÇÕES AUXILIARES PARA LIMPEZA (Adicione logo abaixo) ---

function bloquearSet2() {
    const elSet2J1 = document.getElementById('set2-j1');
    const elSet2J2 = document.getElementById('set2-j2');
    // Desabilita e Limpa
    elSet2J1.disabled = true;
    elSet2J2.disabled = true;
    elSet2J1.value = '';
    elSet2J2.value = '';
    // Esconde visualmente
    elSet2J1.classList.add('sb-hidden');
    elSet2J2.classList.add('sb-hidden');
    document.getElementById('header-set2').classList.add('sb-hidden');
}

function bloquearSet3() {
    const elSet3J1 = document.getElementById('set3-j1');
    const elSet3J2 = document.getElementById('set3-j2');
    // Desabilita e Limpa
    elSet3J1.disabled = true;
    elSet3J2.disabled = true;
    elSet3J1.value = '';
    elSet3J2.value = '';
    // Esconde visualmente
    elSet3J1.classList.add('sb-hidden');
    elSet3J2.classList.add('sb-hidden');
    document.getElementById('header-set3').classList.add('sb-hidden');
}


// Variável global para saber qual set o usuário clicou por último
let setEmEdicao = null;

/**
 * Função de "Recall" e Seleção de Set
 */
function carregarTieBreakParaEdicao(setNum) {
    // 1. DEFINE O SET ATIVO MANUALMENTE
    setEmEdicao = setNum; 
    console.log(`Set ativo definido manualmente para: ${setEmEdicao}`);

    // 2. Lógica de carregar histórico (Recall)
    const val1 = document.getElementById(`set${setNum}-j1`).value;
    const val2 = document.getElementById(`set${setNum}-j2`).value;
    const s1 = parseInt(val1.split('(')[0]) || 0;
    const s2 = parseInt(val2.split('(')[0]) || 0;

    const isTieBreakCenario = (s1 === 6 && s2 === 6) || 
                              (s1 === 7 && s2 === 6) || 
                              (s1 === 6 && s2 === 7);

    if (isTieBreakCenario) {
        const tb1 = parseInt(document.getElementById(`tb${setNum}-j1`).value) || 0;
        const tb2 = parseInt(document.getElementById(`tb${setNum}-j2`).value) || 0;

        estadoPontos.j1 = tb1;
        estadoPontos.j2 = tb2;
        estadoPontos.tiebreakMode = true; 
        atualizarDisplayPontos();

        // Feedback Visual
        const labelGame = document.getElementById('label-game-points');
        if (labelGame) {
            labelGame.textContent = "EDITANDO TB";
            labelGame.style.color = "#3498db";
        }
    }
}


/**
 * Atualiza os nomes (Arbitragem, Súmula e Selects) com lógica responsiva.
 * Horizontal = Nome Completo | Vertical = Apelido
 */
function atualizarNomesPainelControle() {
    const isHorizontal = window.innerWidth > window.innerHeight;

    // 1. ATUALIZA LABELS (SÚMULA E ARBITRAGEM)
    const idsLabels = ['apelido-j1', 'apelido-j2', 'simple-name-j1', 'simple-name-j2'];
    
    const formatarLabel = (nomeCompleto, apelido) => {
        if (!nomeCompleto || !apelido) return apelido || "";
        if (!isHorizontal) return apelido; // Vertical: Só apelido

        // Horizontal: Nome com apelido em negrito
        const index = nomeCompleto.toLowerCase().indexOf(apelido.toLowerCase());
        if (index !== -1) {
            const regex = new RegExp(`(${apelido})`, 'gi');
            return nomeCompleto.replace(regex, '<b>$1</b>');
        } else {
            return `${nomeCompleto} (<b>${apelido}</b>)`;
        }
    };

    idsLabels.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            const nc = el.getAttribute('data-nome-completo');
            const ap = el.getAttribute('data-apelido');
            if (nc && ap) el.innerHTML = formatarLabel(nc, ap);
        }
    });

    // 2. ATUALIZA SELECTS (W.O. E DESISTÊNCIA) - NOVO!
    const idsSelects = ['select-vencedor-wo', 'select-desistente'];
    
    idsSelects.forEach(id => {
        const select = document.getElementById(id);
        if (select) {
            // Itera por cada opção do menu
            Array.from(select.options).forEach(opt => {
                if (opt.value === "") return; // Pula o "Selecione"
                
                const nc = opt.getAttribute('data-nome-completo');
                const ap = opt.getAttribute('data-apelido');
                
                if (nc && ap) {
                    // Select não aceita HTML (<b>), então usamos texto puro
                    opt.textContent = isHorizontal ? nc : ap;
                }
            });
        }
    });
}







// Variável global para controlar o evento de toque na tela cheia
let listenerTelaCheia = null;

// 3. Função FINAL para abrir o modal de resultado (CORREÇÃO SÚMULA NOVO JOGO)
async function abrirModalResultado(reserva, key, quadra, modoVisualizacao) {
    // 1. REFERÊNCIAS INICIAIS
    const modal = document.getElementById('modalResultadoPiramide');
    if (modal) {
        modal.style.display = 'flex';
        // Marca o modal se for visualização para o CSS de tela cheia funcionar
        if (modoVisualizacao) {
            modal.classList.add('visualizando-resultado');
        } else {
            modal.classList.remove('visualizando-resultado');
        }
    }

    // 2. RESETA ESTADOS GLOBAIS
    modoResultado = 'placar';
    setEmEdicao = null;
    estadoPontos = { j1: 0, j2: 0, tiebreakMode: false };
    atualizarDisplayPontos();

    // --- LIMPEZA INICIAL ---
    const markerJ1 = document.getElementById('server-marker-j1');
    const markerJ2 = document.getElementById('server-marker-j2');
    if (markerJ1) markerJ1.innerHTML = '';
    if (markerJ2) markerJ2.innerHTML = '';

    // 3. LÓGICA DE JOGADORES (Identificação)
    let listaDeJogadores = [];
    if (reserva.jogadores_completo) {
        listaDeJogadores = reserva.jogadores_completo.split(',').map(j => j.trim());
    } else {
        const j1 = (reserva.jogadores || "").split(',')[0].trim();
        let j2 = "Oponente";
        if (reserva.duracao > 1) {
            const horaSeguinte = parseInt(reserva.hora) + 1;
            const keySegundaHora = `${reserva.dia}_${horaSeguinte}`;
            let reservaParte2 = null;
            if (typeof reservasPorQuadra !== 'undefined' && reservasPorQuadra[quadra] && reservasPorQuadra[quadra][keySegundaHora]) {
                reservaParte2 = reservasPorQuadra[quadra][keySegundaHora];
            }
            if (!reservaParte2) {
                try {
                    const snapshot = await database.ref(`sistemas/reservas/${quadra}/${keySegundaHora}`).once('value');
                    reservaParte2 = snapshot.val();
                } catch (e) {}
            }
            if (reservaParte2 && reservaParte2.jogadores) {
                j2 = reservaParte2.jogadores.split(',')[0].trim();
            }
        }
        listaDeJogadores = [j1, j2];
    }

    const jogador1Apelido = listaDeJogadores[0];
    const jogador2Apelido = listaDeJogadores[1];

    // Configura objeto global de edição
    reservaResultadoEmEdicao = {
        reserva, key, quadra,
        jogador1: jogador1Apelido,
        jogador2: jogador2Apelido,
        readOnly: modoVisualizacao
    };

    // 4. PREPARA NOMES E SELECTS
    const j1Info = jogadoresData[jogador1Apelido];
    const j2Info = jogadoresData[jogador2Apelido];
    const j1NomeCompleto = j1Info ? capitalizarNome(j1Info.nomeCompleto) : capitalizarNome(jogador1Apelido);
    const j2NomeCompleto = j2Info ? capitalizarNome(j2Info.nomeCompleto) : capitalizarNome(jogador2Apelido);
    const j1ApelidoCap = capitalizarNome(jogador1Apelido);
    const j2ApelidoCap = capitalizarNome(jogador2Apelido);

    const elJ1 = document.getElementById('apelido-j1'); const elJ2 = document.getElementById('apelido-j2');
    const elSimpleJ1 = document.getElementById('simple-name-j1'); const elSimpleJ2 = document.getElementById('simple-name-j2');

    if (elJ1) {
        elJ1.setAttribute('data-apelido', j1ApelidoCap); elJ1.setAttribute('data-nome-completo', j1NomeCompleto);
        elJ2.setAttribute('data-apelido', j2ApelidoCap); elJ2.setAttribute('data-nome-completo', j2NomeCompleto);
    }
    if (elSimpleJ1) {
        elSimpleJ1.textContent = j1ApelidoCap;
        elSimpleJ1.setAttribute('data-apelido', j1ApelidoCap); elSimpleJ1.setAttribute('data-nome-completo', j1NomeCompleto);
        elSimpleJ2.textContent = j2ApelidoCap;
        elSimpleJ2.setAttribute('data-apelido', j2ApelidoCap); elSimpleJ2.setAttribute('data-nome-completo', j2NomeCompleto);
    }

    const selectVencedorWo = document.getElementById('select-vencedor-wo');
    const selectDesistente = document.getElementById('select-desistente');
    const criarOption = (val, apelido, nomeComp) => `<option value="${val}" data-apelido="${apelido}" data-nome-completo="${nomeComp}">${apelido}</option>`;
    const optionsHtml = `<option value="">Selecione...</option>` + criarOption(jogador1Apelido, j1ApelidoCap, j1NomeCompleto) + criarOption(jogador2Apelido, j2ApelidoCap, j2NomeCompleto);

    if (selectVencedorWo) selectVencedorWo.innerHTML = optionsHtml;
    if (selectDesistente) selectDesistente.innerHTML = optionsHtml;

    atualizarNomesPainelControle();
    window.addEventListener('resize', atualizarNomesPainelControle);

    // 5. CONFIGURAÇÃO VISUAL (Limpeza)
    const containerPlacar = document.getElementById('placar-fields-container');
    const containerSumula = document.getElementById('simple-score-container');

    if (containerPlacar) containerPlacar.querySelectorAll('input').forEach(inp => inp.value = '');
    if (containerSumula) containerSumula.querySelectorAll('input').forEach(inp => {
        inp.value = '';
        if (inp.classList.contains('simple-tb-input')) inp.style.display = 'none';
    });

    document.getElementById('select-motivo-wo').value = '';
    document.getElementById('select-motivo-desistencia').value = '';
    document.getElementById('resultado-vencedor').textContent = '';

    const elSelectWO = document.getElementById('select-vencedor-wo');
    const elSelectDes = document.getElementById('select-desistente');
    if (elSelectWO) { elSelectWO.value = ''; elSelectWO.removeAttribute('style'); }
    if (elSelectDes) { elSelectDes.value = ''; elSelectDes.removeAttribute('style'); }

    const winnerDisplay = document.querySelector('.winner-display');
    if (winnerDisplay) winnerDisplay.style.display = 'block';
    const actionsDiv = document.querySelector('.modern-actions');
    if (actionsDiv) actionsDiv.style.marginTop = '';

    document.querySelector('label[for="select-desistente"]').textContent = 'Quem desistiu?';

    document.getElementById('wo-controls').style.display = 'none';
    document.getElementById('desistencia-controls').style.display = 'none';
    const menu = document.getElementById('menu-opcoes-resultado');
    if (menu) menu.classList.remove('visivel');

    const chkArb = document.getElementById('chk-modo-arbitragem');
    if (chkArb) chkArb.checked = false;
    if (containerPlacar) containerPlacar.style.display = 'none';
    if (containerSumula) containerSumula.style.display = 'block';

    // 6. CARREGA DADOS OU INICIA NOVO JOGO
    if (reserva.resultado) {
        const r = reserva.resultado;
        const jogoEstaFinalizado = r.status === 'finalizada' || (r.vencedor && r.vencedor !== '');

        const tituloModal = document.querySelector('#modalResultadoPiramide h3');
        if (tituloModal) {
            if (r.tipo === 'Placar Normal' && jogoEstaFinalizado) {
                tituloModal.textContent = 'Resultado Final';
            } else {
                tituloModal.textContent = 'Súmula';
            }
        }

        if (r.tipo === 'W.O.' || r.vencedorWo) {
            modoResultado = 'wo';
            containerSumula.style.display = 'none';
            document.getElementById('wo-controls').style.display = 'block';
            if (tituloModal) tituloModal.textContent = 'W.O.';
            if (winnerDisplay) winnerDisplay.style.display = 'none';
            if (actionsDiv) actionsDiv.style.marginTop = '-15px';

            const valVencedor = r.vencedorWo || r.vencedor || '';
            elSelectWO.value = valVencedor;
            if (valVencedor) {
                elSelectWO.style.color = '#27ae60'; elSelectWO.style.fontWeight = '800'; elSelectWO.style.borderColor = '#27ae60'; elSelectWO.style.backgroundColor = '#eafaf1';
            }
            document.getElementById('select-motivo-wo').value = r.motivoWo || r.motivo || '';
            document.getElementById('resultado-vencedor').textContent = '';
            atualizarBotaoSalvarResultado(true);
            bloquearEdicao(modoVisualizacao);
        }
        else if (r.tipo === 'Desistência' || r.desistente) {
            modoResultado = 'desistencia';
            containerSumula.style.display = 'none';
            document.getElementById('desistencia-controls').style.display = 'block';
            if (tituloModal) tituloModal.textContent = 'Desistência';
            if (winnerDisplay) winnerDisplay.style.display = 'none';
            if (actionsDiv) actionsDiv.style.marginTop = '-15px';

            const valVencedor = r.vencedor || '';
            elSelectDes.value = valVencedor;
            if (valVencedor) {
                elSelectDes.style.color = '#27ae60'; elSelectDes.style.fontWeight = '800'; elSelectDes.style.borderColor = '#27ae60'; elSelectDes.style.backgroundColor = '#eafaf1';
            }
            document.getElementById('select-motivo-desistencia').value = r.motivoDesistencia || r.motivo || '';
            document.getElementById('resultado-vencedor').textContent = '';
            carregarPlacarNosInputs(r);
            atualizarBotaoSalvarResultado(true);
            bloquearEdicao(modoVisualizacao);
        }
        else {
            carregarPlacarNosInputs(r);

            if (r.sacador && !jogoEstaFinalizado) {
                toggleSacador(r.sacador, true);
            }

            if (r.set3 && (typeof r.set3 === 'string' ? r.set3 : r.set3.placar)) {
                document.getElementById('simple-header-set3').style.display = 'block';
                document.getElementById('simple-group-set3-j1').style.display = 'flex';
                document.getElementById('simple-group-set3-j2').style.display = 'flex';
            }

            setTimeout(() => {
                sincronizarParaSumula();
                calcularVencedorPiramide();
                bloquearEdicao(modoVisualizacao);
            }, 50);
        }
    } else {
        // === NOVO JOGO ===
        bloquearEdicao(false);
        
        // CORREÇÃO: Preenche apenas Set 1 e 2 com "0". Deixa Set 3 vazio.
        ['simple-s1-j1', 'simple-s1-j2', 'simple-s2-j1', 'simple-s2-j2'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.value = '0';
        });
        
        // Garante que o 3º set comece limpo
        document.getElementById('simple-s3-j1').value = '';
        document.getElementById('simple-s3-j2').value = '';

        verificarTieBreakManual(1); 
        verificarTieBreakManual(2); 
        
        // Esconde o 3º set explicitamente
        verificarNecessidadeSet3();

        document.querySelector('#modalResultadoPiramide h3').textContent = 'Súmula';
        atualizarBotaoSalvarResultado(false);
    }

    // Lógica dos Botões Salvar/Cancelar/Fechar
    const actionsContainer = document.querySelector('.modern-actions');
    if (modoVisualizacao) {
        if (actionsContainer) actionsContainer.style.setProperty('display', 'none', 'important');
    } else {
        if (actionsContainer) {
            actionsContainer.style.setProperty('display', 'flex', 'important');
            actionsContainer.style.marginTop = '';
        }
        const btnSalvar = document.getElementById('btnSalvarResultado');
        if (btnSalvar) btnSalvar.style.display = 'block';
        
        const btnCancelar = document.getElementById('btnCancelarResultado');
        if (btnCancelar) {
            btnCancelar.textContent = 'Cancelar';
            btnCancelar.onclick = fecharModalResultado;
        }
    }

    // Configuração do Botão X vs Menu
    const btnMenu = document.getElementById('btn-mais-opcoes');
    const btnX = document.getElementById('btn-fechar-visualizacao');
    const header = document.querySelector('.modern-modal-header');

    if (modoVisualizacao) {
        if (btnMenu) btnMenu.style.setProperty('display', 'none', 'important');
        if (header) header.style.position = 'relative';

        if (btnX) {
            btnX.removeAttribute('style');
            btnX.style.setProperty('display', 'flex', 'important');
            btnX.style.setProperty('align-items', 'center', 'important');
            btnX.style.setProperty('justify-content', 'center', 'important');
            btnX.style.setProperty('position', 'absolute', 'important');
            btnX.style.setProperty('top', '50%', 'important');
            btnX.style.setProperty('transform', 'translateY(-50%)', 'important');
            btnX.style.setProperty('left', 'auto', 'important'); 
            btnX.style.setProperty('right', '-10px', 'important');
            btnX.style.setProperty('width', '40px', 'important');
            btnX.style.setProperty('height', '40px', 'important');
            btnX.style.setProperty('z-index', '10000', 'important');
            btnX.style.setProperty('margin', '0', 'important');
            btnX.style.setProperty('background', 'transparent', 'important');
            btnX.style.setProperty('border', 'none', 'important');
            btnX.style.setProperty('cursor', 'pointer', 'important');
            btnX.style.setProperty('padding', '0', 'important');
            btnX.onclick = fecharModalResultado;
        }
    } else {
        if (btnMenu) {
            btnMenu.style.display = 'flex';
            btnMenu.style.right = '-10px';
        }
        if (btnX) btnX.style.display = 'none';
    }
}






// --- Helper 1: Carrega dados nos inputs (Normal e Desistência) ---
function carregarPlacarNosInputs(r) {
    const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val; };

    if (r.set1) {
        if (r.set1.placar && r.set1.placar.includes('x')) {
            const [s1, s2] = r.set1.placar.split('x');
            setVal('set1-j1', s1); setVal('set1-j2', s2);
        }
        if (r.set1.tiebreak && r.set1.tiebreak.includes('-')) {
            const [tb1, tb2] = r.set1.tiebreak.split('-');
            setVal('tb1-j1', tb1); setVal('tb1-j2', tb2);
        }
    }
    if (r.set2) {
        if (r.set2.placar && r.set2.placar.includes('x')) {
            const [s1, s2] = r.set2.placar.split('x');
            setVal('set2-j1', s1); setVal('set2-j2', s2);
        }
        if (r.set2.tiebreak && r.set2.tiebreak.includes('-')) {
            const [tb1, tb2] = r.set2.tiebreak.split('-');
            setVal('tb2-j1', tb1); setVal('tb2-j2', tb2);
        }
    }
    if (r.set3) {
        const placar3 = (typeof r.set3 === 'string') ? r.set3 : r.set3.placar;
        if (placar3 && placar3.includes('x')) {
            const [s1, s2] = placar3.split('x');
            setVal('set3-j1', s1); setVal('set3-j2', s2);
        }
    }
}

// --- Helper 2: Bloqueia/Desbloqueia edição (Modo Visualização) ---
function bloquearEdicao(bloquear) {
    const containerPlacar = document.getElementById('placar-fields-container');
    const containerSumula = document.getElementById('simple-score-container');
    const chkArb = document.getElementById('chk-modo-arbitragem');
    
    const inputsArb = containerPlacar ? containerPlacar.querySelectorAll('input') : [];
    const inputsSum = containerSumula ? containerSumula.querySelectorAll('input') : [];
    const buttons = containerPlacar ? containerPlacar.querySelectorAll('button') : [];
    
    inputsArb.forEach(i => i.disabled = bloquear);
    inputsSum.forEach(i => i.disabled = bloquear);
    buttons.forEach(b => b.style.display = bloquear ? 'none' : 'flex'); 
    
    if (bloquear) {
        if(document.getElementById('apelido-j1')) document.getElementById('apelido-j1').onclick = null;
        if(document.getElementById('apelido-j2')) document.getElementById('apelido-j2').onclick = null;
        if (chkArb) chkArb.disabled = true;
    } else {
        if(document.getElementById('apelido-j1')) document.getElementById('apelido-j1').onclick = () => toggleSacador('j1');
        if(document.getElementById('apelido-j2')) document.getElementById('apelido-j2').onclick = () => toggleSacador('j2');
        if (chkArb) chkArb.disabled = false;
    }
}



/**
 * Alterna o indicador de sacador (bolinha).
 * @param {string} jogador - 'j1' ou 'j2'
 * @param {boolean} ignorarSave - Se true, apenas desenha a bolinha sem salvar.
 */
function toggleSacador(jogador, ignorarSave = false) {
    const markerJ1 = document.getElementById('server-marker-j1');
    const markerJ2 = document.getElementById('server-marker-j2');
    const ballHtml = '<div class="server-ball"></div>';

    // Verifica quem tem a bola atualmente
    const j1TemBola = markerJ1.innerHTML.trim() !== '';
    const j2TemBola = markerJ2.innerHTML.trim() !== '';

    // Limpa ambos
    markerJ1.innerHTML = '';
    markerJ2.innerHTML = '';

    // Lógica de Toggle:
    if (jogador === 'j1' && !j1TemBola) {
        markerJ1.innerHTML = ballHtml;
    } else if (jogador === 'j2' && !j2TemBola) {
        markerJ2.innerHTML = ballHtml;
    }
    
    // A CORREÇÃO ESTÁ AQUI:
    // Só chama o Auto-Save se NÃO for uma carga inicial (ignorarSave = false)
    if (!ignorarSave) {
        triggerAutoSave();
    }
}



/**
 * Monitora a digitação na Súmula. Se detectar 6-6, 7-6 ou 6-7, mostra os campinhos de TB.
 * CORREÇÃO: Se o usuário editar manualmente para 6x6, zera qualquer tie-break "vencedor" antigo.
 */
function verificarTieBreakManual(setNum) {
    if (setNum === 3) return;

    const tbInput1 = document.getElementById(`simple-tb${setNum}-j1`);
    const tbInput2 = document.getElementById(`simple-tb${setNum}-j2`);

    if (!tbInput1 || !tbInput2) return;

    const v1 = parseInt(document.getElementById(`simple-s${setNum}-j1`).value) || 0;
    const v2 = parseInt(document.getElementById(`simple-s${setNum}-j2`).value) || 0;

    // Regra: É tie-break se 6x6, 7x6 ou 6x7
    const isTB = (v1 === 6 && v2 === 6) || (v1 === 7 && v2 === 6) || (v1 === 6 && v2 === 7);

    if (isTB) {
        tbInput1.style.display = 'block';
        tbInput2.style.display = 'block';

        // === CORREÇÃO AQUI ===
        // Se o usuário digitou 6x6, mas os campos de tie-break ainda mostram um vencedor (ex: 7-1),
        // significa que ele está editando um set que já tinha acabado. Devemos zerar o tie-break.
        if (v1 === 6 && v2 === 6) {
            const t1 = parseInt(tbInput1.value) || 0;
            const t2 = parseInt(tbInput2.value) || 0;
            const max = Math.max(t1, t2);
            const min = Math.min(t1, t2);

            // Se o tie-break antigo define um vencedor (7-5, 7-0, etc), zera tudo.
            if ((max === 7 && min <= 5) || (max > 7 && (max - min) >= 2)) {
                tbInput1.value = '0';
                tbInput2.value = '0';
                // Também limpa os campos ocultos da arbitragem para garantir sincronia
                const arbTB1 = document.getElementById(`tb${setNum}-j1`);
                const arbTB2 = document.getElementById(`tb${setNum}-j2`);
                if(arbTB1) arbTB1.value = '0';
                if(arbTB2) arbTB2.value = '0';
            }
        }
    } else {
        tbInput1.style.display = 'none';
        tbInput2.style.display = 'none';
        tbInput1.value = '0'; 
        tbInput2.value = '0';
    }
}




// Listener do Checkbox "Modo Arbitragem" (COM CORREÇÃO DE SAÍDA DE TELA CHEIA)
document.addEventListener('DOMContentLoaded', function() {
    const chkArbitragem = document.getElementById('chk-modo-arbitragem');
    
    if (chkArbitragem) {
        chkArbitragem.addEventListener('change', function() {
            
            // --- CORREÇÃO: SE DESLIGAR A ARBITRAGEM, SAI DA TELA CHEIA AUTOMATICAMENTE ---
            if (!this.checked) {
                const modal = document.getElementById('modalResultadoPiramide');
                
                // Verifica se a tela cheia está ativa (seja pela classe CSS ou API do navegador)
                if (modal.classList.contains('modo-cheio') || document.fullscreenElement) {
                    
                    // 1. Remove a classe visual que estica a janela
                    modal.classList.remove('modo-cheio');
                    
                    // 2. Sai do modo tela cheia do navegador (se estiver ativo)
                    if (document.fullscreenElement) {
                        sairDaTelaCheia(); // Chama a função que já existe no seu código
                    }
                    
                    // 3. Reseta o ícone do botão para "Maximizar" visualmente
                    const btn = document.getElementById('btn-fullscreen-toggle');
                    if(btn) {
                        btn.innerHTML = `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="15" y1="3" x2="21" y2="3"></line><line x1="21" y1="3" x2="21" y2="9"></line><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="9" y2="21"></line><line x1="3" y1="21" x2="3" y2="15"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>`;
                    }
                }
            }
            // -----------------------------------------------------------------------------

            // Continua com a troca normal de telas (Arbitragem <-> Súmula)
            alternarModo(this.checked);
        });
    }
});



/**
 * Troca entre Súmula (False) e Arbitragem (True)
 * ATUALIZADA: Com Inteligência Contextual para o Saque
 */
function alternarModo(ativarArbitragem) {
    const containerArbitragem = document.getElementById('placar-fields-container');
    const containerSumula = document.getElementById('simple-score-container');
    const menu = document.getElementById('menu-opcoes-resultado');
    const tituloModal = document.querySelector('#modalResultadoPiramide h3');
    
    if (ativarArbitragem) {
        // >>> INDO PARA ARBITRAGEM <<<
        sincronizarParaArbitragem();
        
        containerSumula.style.display = 'none';
        containerArbitragem.style.display = 'flex';
        
        if (tituloModal) tituloModal.textContent = 'Painel de Controle';
        
        calcularVencedorPiramide();

        // --- LÓGICA INTELIGENTE DO SAQUE ---
        // 1. Verifica se alguém já tem a bolinha
        const temBolaJ1 = document.getElementById('server-marker-j1').innerHTML.trim() !== '';
        const temBolaJ2 = document.getElementById('server-marker-j2').innerHTML.trim() !== '';

        // Só pergunta se NINGUÉM tiver a bola
        if (!temBolaJ1 && !temBolaJ2) {
            setTimeout(() => {
                // 2. Verifica se o jogo já começou (tem algum ponto/game marcado)
                // Como já chamamos sincronizarParaArbitragem, podemos usar a função hasPlacarParcial() com segurança
                const jogoEmAndamento = hasPlacarParcial(); 
                
                const tituloToss = document.getElementById('tossTitle');
                const msgToss = document.getElementById('tossMessage');

                if (jogoEmAndamento) {
                    // CASO 2: Jogo já começou (Vindo da Súmula)
                    if(tituloToss) tituloToss.textContent = "🎾 Definir Sacador";
                    if(msgToss) msgToss.textContent = "Quem está sacando neste momento?";
                } else {
                    // CASO 1: Jogo 0x0 (Início)
                    if(tituloToss) tituloToss.textContent = "🪙 Toss Inicial";
                    if(msgToss) msgToss.textContent = "Quem começa sacando?";
                }

                abrirModalToss(); 
            }, 300);
        }
        // -----------------------------
        
    } else {
        // >>> INDO PARA SÚMULA <<<
        sincronizarParaSumula();
        
        containerArbitragem.style.display = 'none';
        containerSumula.style.display = 'block';
        
        if (tituloModal) tituloModal.textContent = 'Súmula';
    }
    
    // Fecha menu
    if (menu) menu.classList.remove('visivel');
}




// Copia: Súmula -> Arbitragem e CARREGA O ESTADO DOS PONTOS (Correção Tie-Break Finalizado)
function sincronizarParaArbitragem() {
    // 1. Copia visual dos Sets
    ['1', '2', '3'].forEach(n => {
        document.getElementById(`set${n}-j1`).value = document.getElementById(`simple-s${n}-j1`).value;
        document.getElementById(`set${n}-j2`).value = document.getElementById(`simple-s${n}-j2`).value;
    });

    // 2. Copia visual dos Tie-breaks (Inputs Ocultos)
    ['1', '2'].forEach(n => {
        document.getElementById(`tb${n}-j1`).value = document.getElementById(`simple-tb${n}-j1`).value;
        document.getElementById(`tb${n}-j2`).value = document.getElementById(`simple-tb${n}-j2`).value;
    });

    // =================================================================
    // === LÓGICA DE PRIORIDADE: QUAL SET ESTÁ ATIVO? ===
    // =================================================================
    
    // Reseta o estado
    estadoPontos = { j1: 0, j2: 0, tiebreakMode: false };

    // Lê os games atuais
    const s1_1 = parseInt(document.getElementById('set1-j1').value) || 0;
    const s1_2 = parseInt(document.getElementById('set1-j2').value) || 0;
    const s2_1 = parseInt(document.getElementById('set2-j1').value) || 0;
    const s2_2 = parseInt(document.getElementById('set2-j2').value) || 0;
    const s3_1 = document.getElementById('set3-j1').value;
    const s3_2 = document.getElementById('set3-j2').value;

    // Lê os pontos de tie-break
    const tb1_1 = parseInt(document.getElementById('tb1-j1').value) || 0;
    const tb1_2 = parseInt(document.getElementById('tb1-j2').value) || 0;
    const tb2_1 = parseInt(document.getElementById('tb2-j1').value) || 0;
    const tb2_2 = parseInt(document.getElementById('tb2-j2').value) || 0;

    // --- HELPER: Verifica se o tie-break já tem um vencedor ---
    const tbTemVencedor = (t1, t2) => {
        const max = Math.max(t1, t2);
        const min = Math.min(t1, t2);
        // Venceu se: (7 a <=5) OU (Maior que 7 com diferença >= 2)
        return (max === 7 && min <= 5) || (max > 7 && (max - min) >= 2);
    };

    // --- CENÁRIOS DE TIE-BREAK ---

    // SET 1: É tie-break (6-6 ou 7-6/6-7)?
    const isTb1Scenario = (s1_1 === 6 && s1_2 === 6) || (s1_1 === 7 && s1_2 === 6) || (s1_1 === 6 && s1_2 === 7);
    // O TB do Set 1 está finalizado?
    const isTb1Finalizado = isTb1Scenario && tbTemVencedor(tb1_1, tb1_2);

    // SET 2: É tie-break?
    const isTb2Scenario = (s2_1 === 6 && s2_2 === 6) || (s2_1 === 7 && s2_2 === 6) || (s2_1 === 6 && s2_2 === 7);

    // --- DECISÃO DO QUE CARREGAR ---

    // 1. Se Set 1 é TB e NÃO acabou (está 6x6 ou 6x5 no TB), carrega Set 1.
    if (isTb1Scenario && !isTb1Finalizado) {
        estadoPontos.j1 = tb1_1;
        estadoPontos.j2 = tb1_2;
        estadoPontos.tiebreakMode = true;
    }
    // 2. Se Set 2 é TB (e Set 1 já passou), carrega Set 2.
    else if (isTb2Scenario) {
        estadoPontos.j1 = tb2_1;
        estadoPontos.j2 = tb2_2;
        estadoPontos.tiebreakMode = true; 
    }
    // 3. Se Set 3 existe, carrega Set 3.
    else if (s3_1 !== '' || s3_2 !== '') {
        estadoPontos.j1 = parseInt(s3_1) || 0;
        estadoPontos.j2 = parseInt(s3_2) || 0;
        estadoPontos.tiebreakMode = true;
    }
    // 4. Se não é nenhum TB, mantém 0x0 (Game Normal) ou carrega pontos do game se salvos (não implementado aqui para game normal, assume 0)
    
    // Atualiza visualmente os botões
    atualizarDisplayPontos();
}



// Copia: Arbitragem -> Súmula
function sincronizarParaSumula() {
    // Sets
    ['1', '2', '3'].forEach(n => {
        // Pega valor limpo (sem parênteses) da arbitragem
        const val1 = document.getElementById(`set${n}-j1`).value.toString().split('(')[0];
        const val2 = document.getElementById(`set${n}-j2`).value.toString().split('(')[0];
        
        document.getElementById(`simple-s${n}-j1`).value = val1;
        document.getElementById(`simple-s${n}-j2`).value = val2;
        
        // Roda a verificação para mostrar/esconder campos de TB na súmula
        if (n !== '3') verificarTieBreakManual(parseInt(n));
    });

    // Tie-breaks
    ['1', '2'].forEach(n => {
        // Pega dos inputs ocultos
        document.getElementById(`simple-tb${n}-j1`).value = document.getElementById(`tb${n}-j1`).value;
        document.getElementById(`simple-tb${n}-j2`).value = document.getElementById(`tb${n}-j2`).value;
    });
}


/**
 * Verifica se o jogo está empatado em 1 a 1 nos sets para exibir o 3º Set.
 */
function verificarNecessidadeSet3() {
    // Helper seguro para leitura
    const getVal = (id) => {
        const el = document.getElementById(id);
        if (!el || el.value.trim() === '') return NaN; 
        return parseInt(el.value);
    };

    // Leitura dos valores
    const s1j1 = getVal('simple-s1-j1');
    const s1j2 = getVal('simple-s1-j2');
    const tb1j1 = getVal('simple-tb1-j1') || 0;
    const tb1j2 = getVal('simple-tb1-j2') || 0;

    const s2j1 = getVal('simple-s2-j1');
    const s2j2 = getVal('simple-s2-j2');
    const tb2j1 = getVal('simple-tb2-j1') || 0;
    const tb2j2 = getVal('simple-tb2-j2') || 0;

    // Determina vencedores (retorna null se placar incompleto/0x0)
    const vencedor1 = determinarVencedorSet(s1j1, s1j2, tb1j1, tb1j2);
    const vencedor2 = determinarVencedorSet(s2j1, s2j2, tb2j1, tb2j2);

    // Regra: Mostra SÓ se ambos os sets tiverem vencedores E forem diferentes
    const precisaSet3 = (vencedor1 && vencedor2 && vencedor1 !== vencedor2);

    // Elementos do DOM
    const headerSet3 = document.getElementById('simple-header-set3');
    const groupJ1 = document.getElementById('simple-group-set3-j1');
    const groupJ2 = document.getElementById('simple-group-set3-j2');

    if (precisaSet3) {
        // MOSTRA
        if (headerSet3) headerSet3.style.display = 'block';
        if (groupJ1) groupJ1.style.display = 'flex';
        if (groupJ2) groupJ2.style.display = 'flex';

        // Se mostrou e está vazio, aí sim coloca "0" para facilitar
        const inpJ1 = document.getElementById('simple-s3-j1');
        const inpJ2 = document.getElementById('simple-s3-j2');
        if (inpJ1 && inpJ1.value === '') inpJ1.value = '0';
        if (inpJ2 && inpJ2.value === '') inpJ2.value = '0';

    } else {
        // ESCONDE (COM FORÇA)
        if (headerSet3) headerSet3.style.setProperty('display', 'none', 'important');
        if (groupJ1) groupJ1.style.setProperty('display', 'none', 'important');
        if (groupJ2) groupJ2.style.setProperty('display', 'none', 'important');

        // Limpa os valores para não salvar "0x0" no banco se o set não existiu
        const inpJ1 = document.getElementById('simple-s3-j1');
        const inpJ2 = document.getElementById('simple-s3-j2');
        if (inpJ1) inpJ1.value = '';
        if (inpJ2) inpJ2.value = '';
    }
}




/**
 * Ao clicar no campo: Salva o valor, limpa o campo e ESCONDE o tie-break visualmente (sem apagar os dados).
 */
function focarCampoSumula(el, setNum) {
    // 1. Salva o valor atual para restauração
    el.dataset.oldVal = el.value;
    
    // 2. Limpa o campo para digitação
    el.value = '';
    
    // 3. Esconde visualmente os campos de tie-break (mas mantém os valores dentro deles por enquanto)
    const tb1 = document.getElementById(`simple-tb${setNum}-j1`);
    const tb2 = document.getElementById(`simple-tb${setNum}-j2`);
    if (tb1) tb1.style.display = 'none';
    if (tb2) tb2.style.display = 'none';
}

/**
 * Ao sair do campo: Se estiver vazio, restaura o valor antigo. Depois verifica se o tie-break deve reaparecer.
 */
function desfocarCampoSumula(el, setNum) {
    // 1. Se o usuário saiu sem digitar nada, restaura o valor antigo
    if (el.value.trim() === '') {
        el.value = el.dataset.oldVal;
    }

    // 2. Roda as verificações padrões
    // Se o valor restaurado (ou o novo) formar 6x6 ou 7x6, o tie-break reaparece com os valores antigos intactos.
    // Se o novo valor for 6x3, a função 'verificarTieBreakManual' vai limpar os valores do tie-break definitivamente.
    verificarTieBreakManual(setNum);
    verificarNecessidadeSet3();
    calcularVencedorPiramide();
}

// --- FUNÇÕES DE FOCO/DESFOCO PARA O MODO ARBITRAGEM ---

function focarInputArbitragem(el) {
    // 1. Salva o valor atual na memória do elemento
    el.dataset.oldVal = el.value;
    
    // 2. Limpa o campo para permitir digitação imediata
    el.value = '';
}

function desfocarInputArbitragem(el) {
    // 1. Se o usuário saiu sem digitar nada (vazio), restaura o valor antigo
    if (el.value.trim() === '') {
        el.value = el.dataset.oldVal;
    }
    // 2. Se o valor restaurado (ou novo) for vazio por algum erro, garante '0'
    if (el.value.trim() === '') {
        el.value = '0';
    }

    // 3. Recalcula o vencedor/placar
    calcularVencedorPiramide();
}


// --- FUNÇÃO PARA ALTERNAR TELA CHEIA (VERSÃO LIMPA/PRODUÇÃO) ---
function alternarFullScreenManual() {
    const modal = document.getElementById('modalResultadoPiramide');
    const btn = document.getElementById('btn-fullscreen-toggle');
    const elemToFullscreen = document.documentElement; // Pede tela cheia para a página toda

    // 1. Alterna a classe MANUALMENTE (Isso ativa o CSS responsivo que criamos)
    modal.classList.toggle('modo-cheio');

    // 2. Definição dos Ícones
    const iconMaximize = `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="15" y1="3" x2="21" y2="3"></line><line x1="21" y1="3" x2="21" y2="9"></line><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="9" y2="21"></line><line x1="3" y1="21" x2="3" y2="15"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>`;
    const iconMinimize = `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="14" x2="10" y2="14"></line><line x1="10" y1="14" x2="10" y2="20"></line><line x1="3" y1="21" x2="10" y2="14"></line><line x1="20" y1="10" x2="14" y2="10"></line><line x1="14" y1="10" x2="14" y2="4"></line><line x1="21" y1="3" x2="14" y2="10"></line></svg>`;

    // 3. Tenta ativar o modo tela cheia do navegador (para sumir barra de endereço)
    if (!document.fullscreenElement) {
        // Entrar em tela cheia
        if (elemToFullscreen.requestFullscreen) {
            elemToFullscreen.requestFullscreen().then(() => { if(btn) btn.innerHTML = iconMinimize; });
        } else if (elemToFullscreen.webkitRequestFullscreen) {
            elemToFullscreen.webkitRequestFullscreen();
            if(btn) btn.innerHTML = iconMinimize;
        }
        // Garante a troca do ícone mesmo se a API falhar ou demorar
        if(btn) btn.innerHTML = iconMinimize; 
    } else {
        // Sair da tela cheia
        if (document.exitFullscreen) document.exitFullscreen();
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
        
        if(btn) btn.innerHTML = iconMaximize;
    }
}


// Garante sincronia se o usuário apertar "Voltar" ou "ESC"
document.addEventListener('fullscreenchange', () => {
    const modal = document.getElementById('modalResultadoPiramide');
    const btn = document.getElementById('btn-fullscreen-toggle');
    const iconMaximize = `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="15" y1="3" x2="21" y2="3"></line><line x1="21" y1="3" x2="21" y2="9"></line><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="9" y2="21"></line><line x1="3" y1="21" x2="3" y2="15"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>`;
    
    if (!document.fullscreenElement) {
        if(modal) modal.classList.remove('modo-cheio'); // Remove a classe se sair
        if(btn) btn.innerHTML = iconMaximize;
    }
});



// Listener para garantir que o ícone volte ao normal se sair com ESC
document.addEventListener('fullscreenchange', () => {
    const btn = document.getElementById('btn-fullscreen-toggle');
    const iconMaximize = `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="15" y1="3" x2="21" y2="3"></line><line x1="21" y1="3" x2="21" y2="9"></line><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="9" y2="21"></line><line x1="3" y1="21" x2="3" y2="15"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>`;
    
    if (!document.fullscreenElement && btn) {
        btn.innerHTML = iconMaximize;
    }
});


// =================================================================
// === AUTO-SAIR DA TELA CHEIA AO GIRAR PARA VERTICAL ===
// =================================================================
window.addEventListener('resize', function() {
    const modal = document.getElementById('modalResultadoPiramide');
    
    // Verifica se a tela está na Vertical (Altura maior que Largura)
    const isVertical = window.innerHeight > window.innerWidth;

    if (isVertical && modal && modal.classList.contains('modo-cheio')) {
        console.log("🔄 Rotação Vertical detectada: Restaurando layout padrão.");
        
        // 1. Remove a classe que força o layout esticado
        modal.classList.remove('modo-cheio');
        
        // 2. Sai do modo Fullscreen nativo do navegador (se estiver ativo)
        if (document.fullscreenElement) {
            sairDaTelaCheia();
        }

        // 3. Reseta o ícone do botão para "Maximizar"
        const btn = document.getElementById('btn-fullscreen-toggle');
        const iconMaximize = `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="15" y1="3" x2="21" y2="3"></line><line x1="21" y1="3" x2="21" y2="9"></line><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="9" y2="21"></line><line x1="3" y1="21" x2="3" y2="15"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>`;
        if (btn) btn.innerHTML = iconMaximize;
    }
});


// --- FUNÇÕES DA ETAPA 1: TOSS (SAQUE INICIAL) ---

/**
 * Abre o modal perguntando quem saca, populando os botões com os nomes atuais.
 */
function abrirModalToss() {
    // Pega os nomes que estão na tela (já formatados/capitalizados)
    const nomeJ1 = document.getElementById('apelido-j1').textContent;
    const nomeJ2 = document.getElementById('apelido-j2').textContent;

    const btnJ1 = document.getElementById('btnTossJ1');
    const btnJ2 = document.getElementById('btnTossJ2');

    // Configura os botões
    btnJ1.textContent = nomeJ1;
    btnJ1.onclick = () => confirmarToss('j1');

    btnJ2.textContent = nomeJ2;
    btnJ2.onclick = () => confirmarToss('j2');

    // Mostra o modal
    document.getElementById('modalToss').style.display = 'flex';
}

/**
 * Define o sacador inicial e libera o jogo.
 */
function confirmarToss(jogador) {
    if (navigator.vibrate) navigator.vibrate(50);
    
    // Define a bolinha visualmente
    // (A função toggleSacador já existe e limpa o outro lado automaticamente)
    toggleSacador(jogador);
    
    // Fecha o modal
    document.getElementById('modalToss').style.display = 'none';
    
    mostrarNotificacao("Sacador definido! O jogo está valendo.", 'success');
}


/**
 * Inverte o sacador automaticamente (J1 <-> J2).
 */
function inverterSacador() {
    // Verifica quem tem a bola agora
    const j1TemBola = document.getElementById('server-marker-j1').innerHTML.trim() !== '';
    
    // Inverte
    if (j1TemBola) {
        toggleSacador('j2');
    } else {
        toggleSacador('j1');
    }
}


/**
 * Salva o estado atual do jogo no Firebase silenciosamente.
 * ATUALIZADA: Mesma lógica de assinatura inteligente.
 */
async function executarSalvamentoSilencioso() {
    if (!reservaResultadoEmEdicao) return;

    const { key, quadra, reserva, jogador1, jogador2 } = reservaResultadoEmEdicao;
    
    // --- 1. Identifica o Sacador ---
    let sacadorAtual = null;
    const markerJ1 = document.getElementById('server-marker-j1');
    const markerJ2 = document.getElementById('server-marker-j2');
    if (markerJ1 && markerJ1.innerHTML.trim() !== '') sacadorAtual = 'j1';
    else if (markerJ2 && markerJ2.innerHTML.trim() !== '') sacadorAtual = 'j2';

    // --- 2. Identifica Quem está Informando (Assinatura Inteligente) ---
    const jogadorLogadoCompleto = localStorage.getItem('jogadorLogado');
    const jogadorLogadoApelido = Object.keys(jogadoresData).find(
        apelido => jogadoresData[apelido].nomeCompleto.toUpperCase() === jogadorLogadoCompleto.toUpperCase()
    ) || jogadorLogadoCompleto;

    // Lógica atualizada de assinatura
    const ehJogadorDaPartida = (jogadorLogadoApelido.toUpperCase() === jogador1.toUpperCase() || 
                                jogadorLogadoApelido.toUpperCase() === jogador2.toUpperCase());

    let informante = jogadorLogadoApelido;

    if (isUsuarioAdmin()) {
        informante = `Admin: ${jogadorLogadoApelido}`;
    } else if (ehJogadorDaPartida) {
        informante = `: ${jogadorLogadoApelido}`; // Jogador
    } else {
        informante = `Árbitro: ${jogadorLogadoApelido}`; // Delegado
    }

    const dataAgora = new Date().toISOString();

    // --- 3. Prepara os Dados Numéricos ---
    const getVal = (id) => document.getElementById(id) ? document.getElementById(id).value : "";
    const getNum = (id) => parseInt(getVal(id).toString().split('(')[0]) || 0;

    const s1_1 = getNum('set1-j1'); const s1_2 = getNum('set1-j2');
    const isTb1 = (s1_1 === 6 && s1_2 === 6) || (s1_1 === 7 && s1_2 === 6) || (s1_1 === 6 && s1_2 === 7);
    
    const s2_1 = getNum('set2-j1'); const s2_2 = getNum('set2-j2');
    const isTb2 = (s2_1 === 6 && s2_2 === 6) || (s2_1 === 7 && s2_2 === 6) || (s2_1 === 6 && s2_2 === 7);

    // --- 4. DETECÇÃO AUTOMÁTICA DE VENCEDOR ---
    const elVencedor = document.getElementById('resultado-vencedor');
    const nomeVencedor = elVencedor ? elVencedor.textContent.trim() : '';
    
    let novoStatus = 'em_andamento';
    let vencedorFinal = '';
    let perdedorFinal = '';

    if (nomeVencedor && nomeVencedor !== '') {
        novoStatus = 'finalizada'; 
        vencedorFinal = nomeVencedor;
        
        const j1NomeTela = document.getElementById('apelido-j1').textContent;
        if (nomeVencedor === j1NomeTela || nomeVencedor === jogador1) {
             perdedorFinal = jogador2;
             vencedorFinal = jogador1; 
        } else {
             vencedorFinal = jogador2;
             perdedorFinal = jogador1;
        }
    }

    // --- 5. Monta o Objeto de Resultado ---
    const resultadoData = {
        tipo: 'Placar Normal',
        vencedor: vencedorFinal,
        perdedor: perdedorFinal,
        sacador: sacadorAtual,
        isMatchPoint: verificarMatchPoint(),
        informadoPor: informante, // <-- Usa a nova variável formatada
        dataInformado: dataAgora,
        
        pontos: {
            j1: document.getElementById('pontos-j1').textContent,
            j2: document.getElementById('pontos-j2').textContent,
            isTieBreak: estadoPontos.tiebreakMode 
        },
        set1: {
            placar: `${getVal('set1-j1')}x${getVal('set1-j2')}`,
            tiebreak: (isTb1) ? `${getVal('tb1-j1')}-${getVal('tb1-j2')}` : ""
        },
        set2: {
            placar: `${getVal('set2-j1')}x${getVal('set2-j2')}`,
            tiebreak: (isTb2) ? `${getVal('tb2-j1')}-${getVal('tb2-j2')}` : ""
        },
        set3: (getVal('set3-j1') !== "" && getVal('set3-j2') !== "") ? `${getVal('set3-j1')}x${getVal('set3-j2')}` : ""
    };

    // --- 6. Prepara Updates do Firebase ---
    const updates = {};
    const path1 = `sistemas/reservas/${quadra}/${key}`;
    
    updates[`${path1}/status`] = novoStatus; 
    updates[`${path1}/resultado`] = resultadoData;

    if (reserva.duracao > 1) {
        const key2 = `${reserva.dia}_${reserva.hora + 1}`;
        updates[`sistemas/reservas/${quadra}/${key2}/status`] = novoStatus;
        updates[`sistemas/reservas/${quadra}/${key2}/resultado`] = resultadoData;
    }

    if (novoStatus === 'finalizada') {
        console.log("🏁 Jogo finalizado via Arbitragem. Processando ranking e notificações...");
        const tempReserva = { ...reserva, resultado: resultadoData };
        const rankUpdates = processarTrocaDeRanking(tempReserva);
        const textoDecisao = "finalizado pelo Árbitro de Cadeira";
        const notificacaoUpdates = enviarNotificacaoResultadoFinalizado(tempReserva, textoDecisao);
        Object.assign(updates, rankUpdates, notificacaoUpdates);
    }

    try {
        await database.ref().update(updates);
        
        if (novoStatus === 'em_andamento') {
             atualizarStatusSalvamento("Salvo ✅");
        } else {
             atualizarStatusSalvamento("Finalizado 🏆");
             atualizarIndicadorAba(quadra, false);
        }
        
    } catch (error) {
        atualizarStatusSalvamento("Erro ❌");
        console.error("Erro no salvamento automático:", error);
    }
}





/**
 * Função Gatilho (Debounce): Chama o salvamento após X segundos.
 * Controla o feedback visual do botão.
 */
function triggerAutoSave() {
    // --- TRAVA DE SEGURANÇA ---
    // Se estiver apenas visualizando (readOnly), cancela o salvamento imediatamente.
    if (reservaResultadoEmEdicao && reservaResultadoEmEdicao.readOnly) {
        return;
    }

    // Verifica se já existe um vencedor definido na tela (Jogo Acabou)
    const elVencedor = document.getElementById('resultado-vencedor');
    const jogoAcabou = elVencedor && elVencedor.textContent.trim() !== '';

    if (!verificarMatchPoint() && !jogoAcabou) {
        atualizarStatusSalvamento("Salvando...");
    }

    // Limpa o timer anterior
    if (debounceTimer) clearTimeout(debounceTimer);

    // Define novo timer curto (500ms) para salvar
    debounceTimer = setTimeout(() => {
        executarSalvamentoSilencioso();
    }, 500); 
}



// Atualiza o texto e a cor do botão durante o Auto-Save
function atualizarStatusSalvamento(texto) {
    const btnSalvar = document.getElementById('btnSalvarResultado');
    const containerSumula = document.getElementById('simple-score-container');
    const isModoSumula = containerSumula && containerSumula.style.display !== 'none';

    // Só aplica o efeito visual se estiver na Arbitragem
    if (btnSalvar && !isModoSumula) {
        
        // 1. BLINDAGEM DE MATCH POINT (AMARELO)
        // Se for Match Point, o botão deve permanecer Amarelo, a menos que estejamos finalizando
        // (A verificação de vencedor abaixo cuida da finalização)
        if (verificarMatchPoint()) {
            if (btnSalvar.textContent !== 'MATCH POINT') {
                btnSalvar.textContent = 'MATCH POINT';
                btnSalvar.className = 'btn-modern btn-status-matchpoint';
                btnSalvar.onclick = null;
            }
            // Se o sistema estiver tentando escrever "Salvo", ignoramos para manter o alerta.
            // Mas se estiver tentando escrever "Salvando...", permitimos para feedback.
            if (texto !== "Salvando...") return; 
        }

        // 2. LÓGICA DE VENCEDOR DEFINIDO
        const elVencedor = document.getElementById('resultado-vencedor');
        const temVencedor = elVencedor && elVencedor.textContent.trim() !== '';

        if (temVencedor) {
            // Se o jogo acabou e o sistema mandou "Salvo ✅", aplicamos o estilo final.
            if (texto.includes("Salvo")) {
                btnSalvar.textContent = "Salvo ✅";
                btnSalvar.className = 'btn-modern btn-status-saved';
                return;
            }
            // Se está "Salvando...", mostra o azul
            if (texto === "Salvando...") {
                btnSalvar.textContent = texto;
                btnSalvar.className = 'btn-modern btn-status-saving';
                return;
            }
            // Se não for nenhum status de salvamento, mantém o botão Verde ou Cinza
            return;
        }

        // 3. COMPORTAMENTO PADRÃO (Jogo rolando normal)
        btnSalvar.textContent = texto;
        btnSalvar.classList.remove('btn-status-saving', 'btn-status-saved', 'btn-status-matchpoint', 'btn-save');

        if (texto === "Salvando...") {
            btnSalvar.classList.add('btn-status-saving');
        } else if (texto.includes("Salvo")) {
            btnSalvar.classList.add('btn-status-saved');
        } else if (texto.includes("Erro")) {
            btnSalvar.style.backgroundColor = '#e74c3c';
        }
    }
}



/**
 * Função Auxiliar para detectar Match Point.
/**
 * Função Auxiliar para detectar Match Point.
 * CORRIGIDA: Não exibe Match Point se o jogo JÁ ACABOU (Vencedor definido).
 */
function verificarMatchPoint() {
    // 1. SAFETY CHECK (O PULO DO GATO): 
    // Se já tem um nome no campo de vencedor, o jogo acabou. 
    // Retorna false para liberar o botão Verde (Salvar).
    const elVencedor = document.getElementById('resultado-vencedor');
    if (elVencedor && elVencedor.textContent.trim() !== '') {
        return false; 
    }

    // 2. Identifica Pontos do Game Atual
    const elP1 = document.getElementById('pontos-j1');
    const elP2 = document.getElementById('pontos-j2');
    if (!elP1 || !elP2) return false;

    const txtP1 = elP1.textContent; 
    const txtP2 = elP2.textContent;
    
    // 3. Identifica Sets já vencidos
    const s1_1 = parseInt(document.getElementById('set1-j1').value) || 0;
    const s1_2 = parseInt(document.getElementById('set1-j2').value) || 0;
    
    let setsJ1 = 0;
    let setsJ2 = 0;
    
    const checarSet = (g1, g2) => {
        if ((g1 === 6 && g2 <= 4) || (g1 === 7 && g2 <= 5) || (g1 === 7 && g2 === 6)) return 'j1';
        if ((g2 === 6 && g1 <= 4) || (g2 === 7 && g1 <= 5) || (g2 === 7 && g1 === 6)) return 'j2';
        return null;
    };

    const v1 = checarSet(s1_1, s1_2);
    if (v1 === 'j1') setsJ1++;
    else if (v1 === 'j2') setsJ2++;

    const setAtivo = setEmEdicao || determinarSetAtivo();

    // === CENÁRIO A: SUPER TIE-BREAK (SET 3) ===
    if (setAtivo === 3) {
        const s3_1 = parseInt(document.getElementById('set3-j1').value) || 0;
        const s3_2 = parseInt(document.getElementById('set3-j2').value) || 0;
        
        // Regra: Alguém tem 9+ pontos E (diferença de 1 ou mais, mas ainda não ganhou)
        // Nota: A vitória (>=10 e dif>=2) já foi filtrada pelo SAFETY CHECK no início.
        if (s3_1 >= 9 && s3_1 > s3_2) return true;
        if (s3_2 >= 9 && s3_2 > s3_1) return true;
        return false;
    }

    // === CENÁRIO B: SETS NORMAIS (1 ou 2) ===
    const g1 = parseInt(document.getElementById(`set${setAtivo}-j1`).value) || 0;
    const g2 = parseInt(document.getElementById(`set${setAtivo}-j2`).value) || 0;

    let potencialVencedorGame = null;
    if ((txtP1 === '40' && txtP2 !== '40' && txtP2 !== 'Ad') || txtP1 === 'Ad') potencialVencedorGame = 'j1';
    else if ((txtP2 === '40' && txtP1 !== '40' && txtP1 !== 'Ad') || txtP2 === 'Ad') potencialVencedorGame = 'j2';

    if (!potencialVencedorGame) return false; 

    let ganhariaSet = false;
    const gFavorito = (potencialVencedorGame === 'j1') ? g1 : g2;
    const gOponente = (potencialVencedorGame === 'j1') ? g2 : g1;

    // Regras de Fechamento de Set
    if (gFavorito === 5 && gOponente <= 4) ganhariaSet = true;
    if (gFavorito === 6 && gOponente === 5) ganhariaSet = true;
    
    if (estadoPontos.tiebreakMode) {
        const tbFav = (potencialVencedorGame === 'j1') ? estadoPontos.j1 : estadoPontos.j2;
        const tbOp  = (potencialVencedorGame === 'j1') ? estadoPontos.j2 : estadoPontos.j1;
        if (tbFav >= 6 && tbFav > tbOp) ganhariaSet = true;
        else ganhariaSet = false; 
    }

    if (ganhariaSet) {
        if (potencialVencedorGame === 'j1' && setsJ1 === 1) return true;
        if (potencialVencedorGame === 'j2' && setsJ2 === 1) return true;
    }

    return false;
}


// --- FUNÇÃO VISUAL: Bloqueia horários fechados na tabela ---
function aplicarLimitesDeHorarioVisual() {
    const tabela = document.getElementById('tabelaCorpo');
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0);
    
    // Ajuste para o índice do sistema (0=Dom -> 7)
    const diaDaSemanaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay();

    // Itera sobre as colunas (dias) da tabela (de 1 a 7)
    for (let diaCol = 1; diaCol <= 7; diaCol++) {
        
        // --- 1. Descobre a Data Real desta coluna ---
        // A lógica é: Tabela começa sempre "hoje" ou na ordem fixa? 
        // Assumindo a lógica dinâmica do seu cabeçalho:
        const headerCell = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${diaCol})`);
        
        // Se não achou data no cabeçalho, pula
        if (!headerCell) continue;
        
        // Lê a data escrita lá (ex: "22/12/25")
        const textoData = headerCell.textContent.trim();
        const partes = textoData.split('/'); // ["22", "12", "25"]
        if (partes.length < 3) continue;

        // Cria o objeto Date (Mês no JS começa em 0)
        // Assume ano 20xx
        const anoCompleto = partes[2].length === 2 ? "20" + partes[2] : partes[2];
        const dataColuna = new Date(anoCompleto, parseInt(partes[1]) - 1, parseInt(partes[0]));

        // --- 2. Pergunta ao "Cérebro" (Passo 2) as regras deste dia ---
        const regras = obterRegrasDeHorario(dataColuna);

        // --- 3. Aplica na Coluna ---
        // Itera sobre as linhas (horários 06h a 22h)
        for (let i = 0; i < tabela.rows.length; i++) {
            const horaRow = i + 6; // Linha 0 = 06:00
            const cell = tabela.rows[i].cells[diaCol];

            if (!cell) continue;

            let bloquear = false;

            if (regras.status === 'fechado') {
                bloquear = true; // Dia todo fechado
            } else {
                // Bloqueia se for ANTES de abrir ou DEPOIS de fechar
                // Ex: Se abre as 8, bloqueia 6 e 7.
                if (horaRow < regras.inicio || horaRow >= regras.fim) {
                    bloquear = true;
                }
            }

            if (bloquear) {
                // APLICA O ESTILO CINZA (BLOQUEADO)
                cell.style.backgroundColor = '#f2f2f2'; 
                cell.style.pointerEvents = 'none'; // Não deixa clicar
                cell.style.cursor = 'not-allowed'; // Ícone de proibido
                cell.innerHTML = ""; // Limpa visualmente se não tiver reserva
            } 
            // Se estiver aberto, não fazemos nada (o carregarReservas pinta de branco ou verde depois)
        }
    }
}


// --- FUNÇÃO PARA ABRIR PELA TABELA (MODO CONTEXTUAL + REGRAS DE DURAÇÃO + AULAS) ---
// --- FUNÇÃO PARA ABRIR PELA TABELA (CORRIGIDA: FORMATAÇÃO DE HORA) ---
// --- FUNÇÃO PARA ABRIR PELA TABELA (CORRIGIDA PARA FUNCIONAR COM BOTÃO +) ---
async function abrirFormularioReserva(dia, hora) {
    if (navigator.vibrate) navigator.vibrate(50);
	
	// Garante que todas as quadras estejam visíveis ao abrir um jogo normal
    if (typeof liberarTodasQuadras === 'function') {
        liberarTodasQuadras();
    }

    // 1. Limpa sujeiras anteriores
    limparCampos(); 
    
    // --- SMART LOCK (Só ativa se vier da tabela com hora definida) ---
    if (hora !== undefined && hora !== null) {
        window.horarioBloqueadoPelaTabela = hora; 
    } else {
        window.horarioBloqueadoPelaTabela = null; // Destrava se veio do botão (+)
    }
    // ---------------------------------------------------------------

    // AGUARDA o carregamento dos jogadores para garantir que jogadoresData exista
    await carregarJogadores();

    // 2. Preenche com os dados do clique
    const campoQuadra = document.getElementById('quadra');
    const campoDia = document.getElementById('dia');
    const campoHora = document.getElementById('hora');
    const campoDuracao = document.getElementById('duracao'); 
    const campoJogador1 = document.getElementById('jogador1');

    if (typeof quadraSelecionada !== 'undefined') {
        campoQuadra.value = quadraSelecionada;
    }
    
    // Só preenche o dia se ele foi informado (clique na tabela)
    if (dia !== undefined) {
        campoDia.value = dia;
    }
    
    // Atualiza a lista de horários
    atualizarOpcoesHorario(); 
    
    // Preenchimento da hora
    if (hora !== undefined && hora !== null) {
        const horaFormatada = String(hora).padStart(2, '0') + ":00";
        campoHora.value = horaFormatada;
    }

    // 3. Preenche o Jogador Logado com Tratamento Especial para ADMIN
    try {
        const jogadorLogadoNome = localStorage.getItem('jogadorLogado');
        const isAdmin = typeof isUsuarioAdmin === 'function' && isUsuarioAdmin();

        if (jogadorLogadoNome && typeof jogadoresData !== 'undefined' && campoJogador1) {
            const apelidoDoLogado = Object.keys(jogadoresData).find(
                apelido => jogadoresData[apelido].nomeCompleto.toUpperCase() === jogadorLogadoNome.toUpperCase()
            );

            if (apelidoDoLogado) {
                campoJogador1.value = apelidoDoLogado;
            }

            // --- LÓGICA DE DESTRAVE E COR PARA ADMIN ---
            if (isAdmin) {
                campoJogador1.disabled = false;
                campoJogador1.readOnly = false;
                campoJogador1.removeAttribute('readonly');
                campoJogador1.style.pointerEvents = 'auto';
                campoJogador1.style.cursor = 'text';
                
                // AJUSTE DE COR: Força o padrão dos outros campos
                campoJogador1.style.backgroundColor = '#ffffff'; 
                campoJogador1.style.color = '#333';       // Cor padrão do sistema
                campoJogador1.style.opacity = '1';        // Garante que não esteja transparente
                campoJogador1.style.webkitTextFillColor = '#333'; // Força cor no Safari/iOS
            } else {
                // Comportamento normal para Sócios: Bloqueado e Cinza
                campoJogador1.disabled = true;
                campoJogador1.style.pointerEvents = 'none';
                campoJogador1.style.backgroundColor = '#f0f0f0';
                campoJogador1.style.color = '#666';
                campoJogador1.style.opacity = '0.8';
            }
        }
    } catch (e) {
        console.error("Erro ao preencher jogador logado:", e);
    }

    // =================================================================
    // === CÁLCULO INTELIGENTE DA DURAÇÃO (Só executa se vier da tabela) ===
    // =================================================================
    if (dia !== undefined && hora !== undefined) {
        const hoje = new Date();
        hoje.setHours(0, 0, 0, 0);
        const diaDaSemanaHoje = hoje.getDay() === 0 ? 7 : hoje.getDay();
        
        let diff = dia - diaDaSemanaHoje;
        if (diff < 0) diff += 7;
        
        const dataAlvo = new Date(hoje);
        dataAlvo.setDate(hoje.getDate() + diff);

        const regrasDoDia = obterRegrasDeHorario(dataAlvo);
        const horaFechamento = regrasDoDia.fim; 
        const slotsAteFechar = horaFechamento - hora;

        const proximaHora = parseInt(hora) + 1;
        const keyProximaHora = `${dia}_${proximaHora}`;
        
        const reservasDaQuadra = reservasPorQuadra[quadraSelecionada] || {};
        
        let temReservaNoBanco = false;
        const reservaProxima = reservasDaQuadra[keyProximaHora];
        
        if (reservaProxima && reservaProxima.status !== 'aula_cancelada') {
            temReservaNoBanco = true;
        }

        let temAulaFixa = false;
        let quadraKeySimple = "";
        if (quadraSelecionada.includes("1")) quadraKeySimple = "Quadra1";
        else if (quadraSelecionada.includes("2")) quadraKeySimple = "Quadra2";
        else if (quadraSelecionada.includes("3")) quadraKeySimple = "Quadra3";

        const configAula = configAulasGlobal[quadraKeySimple];
        
        if (configAula && configAula.Ativo && configAula.Grade) {
            if (configAula.Grade[keyProximaHora] === true) {
                if (reservaProxima && reservaProxima.status === 'aula_cancelada') {
                    temAulaFixa = false; 
                } else {
                    temAulaFixa = true; 
                }
            }
        }

        const bloquearLongaDuracao = (slotsAteFechar < 2) || temReservaNoBanco || temAulaFixa;
        const op2h = campoDuracao.querySelector('option[value="2"]');
        const opPiramide = campoDuracao.querySelector('option[value="3-piramide"]');

        if (bloquearLongaDuracao) {
            campoDuracao.value = "1";
            if (op2h) op2h.style.display = 'none';
            if (opPiramide) opPiramide.style.display = 'none';
        } else {
            if (op2h) op2h.style.display = 'block';
            if (opPiramide) opPiramide.style.display = piramideAtivaGlobal ? 'block' : 'none'; 
        }
    }

    // 4. TRAVA OS CAMPOS FIXOS (Apenas se veio da tabela)
    const veioDaTabela = (dia !== undefined && hora !== undefined);
    
    campoQuadra.disabled = veioDaTabela; 
    campoDia.disabled = veioDaTabela;
    campoHora.disabled = veioDaTabela; 
    
    campoQuadra.style.backgroundColor = veioDaTabela ? "#e9ecef" : "";
    campoDia.style.backgroundColor = veioDaTabela ? "#e9ecef" : "";
    campoHora.style.backgroundColor = veioDaTabela ? "#e9ecef" : "";
	

    // 5. Abre a janela
    document.querySelector('.form-container').classList.add('visible');
    document.getElementById('formBackdrop').classList.add('visible');
    document.getElementById('fab-toggle-form').classList.add('active');
}




/**
 * Verifica se o usuário logado tem uma permissão específica.
 * Lógica 100% baseada em Perfis (com Safety Net para o Dono).
 */
function verificarPermissao(permissaoAlvo) {
    const nomeLogado = localStorage.getItem('jogadorLogado');
    if (!nomeLogado) return false;

    // 1. SAFETY NET (REDE DE SEGURANÇA)
    // Garante acesso total ao Dono do Sistema, independente de banco de dados ou perfis.
    if (nomeLogado.toUpperCase() === "RONALDO TABORDA") {
        return true; 
    }

    // 2. BUSCA DADOS DO JOGADOR
    const apelidoLogado = Object.keys(jogadoresData).find(
        a => jogadoresData[a].nomeCompleto.toUpperCase() === nomeLogado.toUpperCase()
    );

    if (!apelidoLogado) return false;
    const dadosJogador = jogadoresData[apelidoLogado];

    // 3. LÓGICA DE PERFIS (A NOVA LEI)
    if (dadosJogador && dadosJogador.perfis) {
        for (const nomePerfil in dadosJogador.perfis) {
            // Se o jogador possui esse perfil ativo (true)
            if (dadosJogador.perfis[nomePerfil] === true) {
                // Pega as regras desse perfil na configuração global
                const regrasPerfil = perfisConfigGlobal[nomePerfil];
                
                if (regrasPerfil && regrasPerfil.permissoes) {
                    // Se o perfil tem 'super_admin', libera TUDO automaticamente
                    if (regrasPerfil.permissoes.super_admin === true) return true;

                    // Verifica a permissão específica solicitada
                    if (regrasPerfil.permissoes[permissaoAlvo] === true) return true;
                }
            }
        }
    }

    return false;
}







/**
 * Grava uma aula extra diretamente no banco de dados.
 */
// SUBSTITUA SUA FUNÇÃO EXISTENTE POR ESTA
// SUBSTITUA A FUNÇÃO executarAgendamentoAulaExtra POR ESTA VERSÃO AJUSTADA
// SUBSTITUA A FUNÇÃO executarAgendamentoAulaExtra POR ESTA VERSÃO FINAL
// SUBSTITUA POR ESTA VERSÃO (PADRÃO MANUTENÇÃO)
// SUBSTITUA A FUNÇÃO executarAgendamentoAulaExtra INTEIRA POR ESTA
async function executarAgendamentoAulaExtra(dia, hora, quadra) {
    // Se for pelo botão (+), abre form
    if (!dia || !hora || !quadra) {
        abrirFormularioReserva(); 
        const btnAgendar = document.getElementById('botaoAgendar');
        if (btnAgendar) {
             const novoBtn = btnAgendar.cloneNode(true);
             btnAgendar.parentNode.replaceChild(novoBtn, btnAgendar);
             novoBtn.id = 'botaoAgendar'; novoBtn.textContent = 'Confirmar';
             novoBtn.onclick = salvarAulaPeloForm; 
        }
        return; 
    }
    // Clique Direto na Célula
    const key = `${dia}_${hora}`;
    const reservasRef = database.ref(`sistemas/reservas/${quadra}/${key}`);
    try {
        const snapshot = await reservasRef.once('value');
        if (snapshot.exists() && snapshot.val().status !== 'aula_cancelada') {
            mostrarNotificacao("Horário ocupado!", 'error'); return;
        }
        // --- USA A NOVA FUNÇÃO AUXILIAR ---
        const dataCompletaParaGravar = calcularDataDoDiaSelecionado(dia);

        const apelidoLogado = localStorage.getItem('jogadorLogado');
        const dadosAula = {
            jogadores: "Aula", jogadores_completo: "Aula", 
            dia: dia, hora: hora, duracao: 1, borda: '1h', status: 'confirmada',
            organizador: apelidoLogado || 'Professor', tipo: 'aula_extra',
            dataCompleta: dataCompletaParaGravar, // <--- GARANTIDO
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        await reservasRef.set(dadosAula);
        mostrarNotificacao("Aula agendada!", "success");
    } catch (erro) { console.error(erro); mostrarNotificacao("Erro: " + erro.message, "error"); }
}


/**
 * VERSÃO FINAL E LIMPA: abrirAgendamentoPelaCelula
 * Lógica validada:
 * 1. Verifica permissão de Lazer (Sócio).
 * 2. Verifica permissões Técnicas (Admin, Manut, Prof da Quadra).
 * 3. Decide se abre formulário, executa direto ou abre menu Admin.
 */
function abrirAgendamentoPelaCelula(dia, hora) {
    // 1. Contexto
    const quadra = quadraSelecionada; 
    const apelidoLogado = localStorage.getItem('jogadorLogado');

    // --- A. LEVANTAMENTO DE PERMISSÕES (INVENTÁRIO) ---
    
    // 1. Verifica se pode JOGAR (Lazer)
    let dadosUser = null;
    if (typeof jogadoresData !== 'undefined') {
        if (jogadoresData[apelidoLogado]) {
            dadosUser = jogadoresData[apelidoLogado];
        } else {
            const chave = Object.keys(jogadoresData).find(k => 
                jogadoresData[k].nomeCompleto === apelidoLogado
            );
            if (chave) dadosUser = jogadoresData[chave];
        }
    }

    const vinculo = dadosUser && dadosUser.socio ? String(dadosUser.socio).toLowerCase().trim() : '';
    const podeJogar = (vinculo === 'titular' || vinculo === 'dependente');

    // 2. Verifica as Permissões TÉCNICAS (Trabalho)
    const opcoesTecnicas = [];

    const isAdmin = typeof isUsuarioAdmin === 'function' ? isUsuarioAdmin() : false;
    const isManut = typeof isUsuarioManutencao === 'function' ? isUsuarioManutencao() : false;
    // Verifica professor especificamente para ESTA quadra
    const isProf = typeof isUsuarioProfessor === 'function' ? isUsuarioProfessor(quadra) : false;

    // Se for ADMIN, tem acesso total
    if (isAdmin) {
        opcoesTecnicas.push({ id: 'aula', label: '🏃 Aula', func: 'executarAgendamentoAulaExtra' });
        opcoesTecnicas.push({ id: 'manutencao', label: '💦 Manutenção', func: 'executarAgendamentoManutencao' });
    } else {
        // Se não for Admin, verifica permissões específicas
        if (isProf) {
            opcoesTecnicas.push({ id: 'aula', label: '🏃 Aula', func: 'executarAgendamentoAulaExtra' });
        }
        if (isManut) {
            opcoesTecnicas.push({ id: 'manutencao', label: '💦 Manutenção', func: 'executarAgendamentoManutencao' });
        }
    }

    // --- B. ROTEADOR DE DECISÃO (LÓGICA) ---

    // CASO 1: Staff Mono-Tarefa (Não joga e só tem 1 função técnica)
    // Ex: Zelador ou Professor que não é sócio. Executa a função direto.
    if (!podeJogar && opcoesTecnicas.length === 1) {
        const item = opcoesTecnicas[0];
        if (typeof window[item.func] === 'function') {
            window[item.func](dia, hora, quadra);
        }
        return;
    }

    // CASO 2: Sócio Comum (Joga e não tem função técnica nesta quadra)
    if (podeJogar && opcoesTecnicas.length === 0) {
        abrirFormularioReserva(dia, hora);
        return;
    }

    // CASO 3: Multi-Função (Admin) ou Híbrido (Staff + Sócio)
    // Abre a janela de decisão (com botão Admin se tiver >1 opção técnica)
    exibirModalAgendamentoDinamico(dia, hora, quadra, podeJogar, opcoesTecnicas);
}




/**
 * ITEM 2: Construtor da Janela de Agendamento (Visual)
 * Ajuste: Botão Aula agora usa a cor 'lightcoral' (igual da planilha)
 */
/**
 * ITEM 2: Construtor da Janela de Agendamento (Visual)
 * Ajuste: Botão Admin abre um MENU FLUTUANTE (Popover) vertical abaixo dele.
 */
/**
 * ITEM 2: Construtor da Janela de Agendamento (Visual)
 * Ajuste Final: Menu Flutuante com espaçamento simétrico (padding vertical).
 */
/**
 * ITEM 2: Construtor da Janela de Agendamento (Visual)
 * Ajuste: Menu Flutuante com espaçamento interno (padding) e separação entre botões (gap).
 */
function exibirModalAgendamentoDinamico(dia, hora, quadra, podeJogar, opcoesTecnicas) {
    const modalOverlay = document.getElementById('modalConfirmacaoOverlay');
    const modalMensagem = document.getElementById('modalConfirmacaoMensagem');
    const btnContainer = document.querySelector('#modalConfirmacaoOverlay .modal-botoes-container');

    if (!modalOverlay || !btnContainer) return;

    // --- MUDANÇA AQUI: Título Inteligente ---
    if (hora) {
        modalMensagem.innerHTML = `O que deseja agendar às ${hora}:00?`;
    } else {
        modalMensagem.innerHTML = `O que deseja agendar?`;
    }
    // ----------------------------------------

    btnContainer.innerHTML = ''; 
    btnContainer.className = 'modal-botoes-container';
    btnContainer.style.display = 'flex';
    btnContainer.style.gap = '10px';
    btnContainer.style.justifyContent = 'center';
    btnContainer.style.flexWrap = 'wrap';

    const isDark = document.body.classList.contains('dark-mode');

    const getEstilosBotao = (id) => {
        if (id === 'aula') {
            return { bg: isDark ? '#CD5C5C' : 'lightcoral', color: 'black', border: 'none' };
        } else if (id === 'manutencao') {
            return { bg: isDark ? '#252525' : '#e9ecef', color: isDark ? '#999' : '#555', border: isDark ? '1px solid #555' : '1px solid #ccc' };
        } else {
            return { bg: '#007bff', color: 'white', border: 'none' };
        }
    };

    const criarBotaoBase = (texto, estiloCustom = {}) => {
        const btn = document.createElement('button');
        btn.innerHTML = texto;
        btn.style.flex = '1';
        btn.style.padding = '12px 0';
        btn.style.borderRadius = '6px';
        btn.style.cursor = 'pointer';
        btn.style.fontWeight = 'bold';
        btn.style.fontSize = '15px';
        btn.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
        Object.assign(btn.style, estiloCustom);
        return btn;
    };

    // 1. BOTÃO JOGO
    if (podeJogar) {
        const btnJogo = criarBotaoBase('🎾 Jogo', { backgroundColor: '#28a745', color: 'white', border: 'none' });
        btnJogo.onclick = () => {
		modalOverlay.style.display = 'none';
		
		// Se tiver dia e hora (veio da tabela), chama com parâmetros
		if (dia !== undefined && hora !== undefined) {
			abrirFormularioReserva(dia, hora);
		} else {
			// --- CORREÇÃO AQUI ---
			// Se veio do botão (+), chama a função SEM parâmetros
			// Isso garante que a função limpe os campos e verifique o Admin
			abrirFormularioReserva();
		}
	};
        btnContainer.appendChild(btnJogo);
    }

    // 2. BOTÕES TÉCNICOS
    const deveAgrupar = (podeJogar && opcoesTecnicas.length > 1);

    if (!deveAgrupar) {
        opcoesTecnicas.forEach(opcao => {
            const style = getEstilosBotao(opcao.id);
            const btn = criarBotaoBase(opcao.label, { backgroundColor: style.bg, color: style.color, border: style.border });
            btn.onclick = () => {
                modalOverlay.style.display = 'none';
                if (typeof window[opcao.func] === 'function') {
                    window[opcao.func](dia, hora, quadra);
                }
            };
            btnContainer.appendChild(btn);
        });
    } else {
        // MODO POPOVER (Admin)
        const wrapperAdmin = document.createElement('div');
        wrapperAdmin.style.position = 'relative'; 
        wrapperAdmin.style.flex = '1';
        wrapperAdmin.style.display = 'flex'; 
        
        const btnAdmin = criarBotaoBase('⚙️ Admin', { backgroundColor: '#6c757d', color: 'white', border: 'none' });

        btnAdmin.onclick = (e) => {
            e.stopPropagation(); 
            const menuExistente = wrapperAdmin.querySelector('.menu-flutuante-admin');
            if (menuExistente) { menuExistente.remove(); return; }

            const menu = document.createElement('div');
            menu.className = 'menu-flutuante-admin';
            menu.style.position = 'absolute';
            menu.style.top = '110%'; 
            menu.style.left = '0';
            menu.style.width = '100%'; 
            menu.style.boxSizing = 'border-box'; 
            menu.style.padding = '0px 5px 15px 5px';
            menu.style.backgroundColor = isDark ? '#333' : 'white';
            menu.style.border = isDark ? '1px solid #555' : '1px solid #ccc';
            menu.style.borderRadius = '6px';
            menu.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
            menu.style.zIndex = '1000'; 
            menu.style.display = 'flex';
            menu.style.flexDirection = 'column'; 
            menu.style.gap = '5px'; 
            menu.style.animation = 'fadeIn 0.2s ease-out';

            opcoesTecnicas.forEach((opcao, index) => {
                const item = document.createElement('button');
                item.innerHTML = opcao.label;
                item.style.width = '100%'; item.style.padding = '10px'; item.style.border = 'none';
                item.style.cursor = 'pointer'; item.style.textAlign = 'left'; item.style.fontWeight = 'bold';
                item.style.fontSize = '14px'; item.style.borderRadius = '4px'; 
                item.style.display = 'flex'; item.style.alignItems = 'center'; item.style.justifyContent = 'flex-start';

                const styleItem = getEstilosBotao(opcao.id);
                item.style.backgroundColor = styleItem.bg; item.style.color = styleItem.color;
                
                item.onmouseenter = () => { item.style.filter = 'brightness(90%)'; };
                item.onmouseleave = () => { item.style.filter = 'brightness(100%)'; };

                item.onclick = () => {
                    modalOverlay.style.display = 'none'; 
                    if (typeof window[opcao.func] === 'function') {
                        window[opcao.func](dia, hora, quadra);
                    }
                };
                menu.appendChild(item);
            });

            wrapperAdmin.appendChild(menu);
            const fecharAoClicarFora = (event) => {
                if (!wrapperAdmin.contains(event.target)) { menu.remove(); document.removeEventListener('click', fecharAoClicarFora); }
            };
            setTimeout(() => { document.addEventListener('click', fecharAoClicarFora); }, 0);
        };
        wrapperAdmin.appendChild(btnAdmin);
        btnContainer.appendChild(wrapperAdmin);
    }

    const divCancelar = document.createElement('div');
    divCancelar.style.width = '100%';
    divCancelar.style.marginTop = '10px';
    divCancelar.innerHTML = `<button onclick="document.getElementById('modalConfirmacaoOverlay').style.display='none'" style="width:100%; padding:10px; background:#e2e6ea; border:none; border-radius:6px; cursor:pointer; font-weight:bold; color:#555;">Cancelar</button>`;
    btnContainer.appendChild(divCancelar);

    modalOverlay.style.display = 'flex';
}





/**
 * Grava uma manutenção diretamente no banco de dados.
 */
// --- FUNÇÃO DE MANUTENÇÃO HÍBRIDA (Célula e Botão +) ---
// --- FUNÇÃO DE MANUTENÇÃO (HÍBRIDA) ---
// --- FUNÇÃO DE MANUTENÇÃO (CORRIGIDA COM SELETORES REAIS) ---
// --- FUNÇÃO DE MANUTENÇÃO (CORRIGIDA E ALINHADA) ---
// --- FUNÇÃO DE MANUTENÇÃO (CORRIGIDA E ALINHADA) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO FINAL: DIA PREENCHIDO) ---
// --- FUNÇÃO DE MANUTENÇÃO (CORRIGIDA: ALINHAMENTO E BOTÃO +) ---
// --- FUNÇÃO DE MANUTENÇÃO (CORRIGIDA: FORÇA BRUTA NO CSS) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO FINAL: ALINHAMENTO PERFEITO) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO FINAL: ALINHAMENTO E LIMPEZA) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO FINAL: NIVELAMENTO 270PX) ---
// --- FUNÇÃO DE MANUTENÇÃO (MODO DEBUG / ARCO-ÍRIS) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO FINAL: NIVELAMENTO E REMOÇÃO DO BOTÃO) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO FINAL: TIMEOUT E ALINHAMENTO) ---
// --- FUNÇÃO DE MANUTENÇÃO: TESTE DO ARCO-ÍRIS 2.0 (DIAGNÓSTICO FINAL) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO FINAL LIMPA - VIA CLASSE CSS) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO FINAL: VIA CLASSE CSS) ---
// --- FUNÇÃO DE MANUTENÇÃO (VERSÃO DEFINITIVA VIA CSS CLASS) ---
// --- FUNÇÃO DE MANUTENÇÃO (COM TEXTO COMPLETO E ALINHADO) ---
// --- FUNÇÃO DE MANUTENÇÃO (HÍBRIDA: CÉLULA E BOTÃO +) ---
// --- FUNÇÃO DE MANUTENÇÃO (ATUALIZADA: DURAÇÃO FIXA) ---
// SUBSTITUA A FUNÇÃO executarAgendamentoManutencao INTEIRA POR ESTA
async function executarAgendamentoManutencao(dia, hora, quadra) {
    if (!dia || !hora || !quadra) {
        abrirFormularioReserva(); 
        const btnConfirmar = document.getElementById('botaoAgendar');
        if (btnConfirmar) {
            const novoBtn = btnConfirmar.cloneNode(true);
            btnConfirmar.parentNode.replaceChild(novoBtn, btnConfirmar);
            novoBtn.textContent = 'Confirmar';
            novoBtn.onclick = salvarManutencaoPeloForm;
        }
        return;
    }
    // Clique Direto
    const key = `${dia}_${hora}`;
    const reservasRef = database.ref(`sistemas/reservas/${quadra}/${key}`);
    
    const snapshot = await reservasRef.once('value');
    if (snapshot.exists() && snapshot.val().status !== 'aula_cancelada') {
        mostrarNotificacao("Horário ocupado!", 'error'); return;
    }
    // --- USA A NOVA FUNÇÃO AUXILIAR ---
    const dataCompletaParaGravar = calcularDataDoDiaSelecionado(dia);

    const dadosManutencao = {
        jogadores: "Manutencao", jogadores_completo: "Manutencao",
        dia: dia, hora: hora, duracao: 1, borda: '1h', status: 'confirmada',
        organizador: localStorage.getItem('jogadorLogado'), tipo: 'manutencao',
        dataCompleta: dataCompletaParaGravar // <--- GARANTIDO
    };
    try {
        await reservasRef.set(dadosManutencao);
        mostrarNotificacao("Manutenção agendada!", 'success');
    } catch (err) { console.error(err); mostrarNotificacao("Erro.", 'error'); }
}




/**
 * Exibe um modal especializado para professores com 3 opções: Aula, Jogo ou Cancelar.
 * CORREÇÃO VISUAL: Botões com largura idêntica.
 */
/**
 * Exibe um modal especializado para professores com 3 opções: Aula, Jogo ou Cancelar.
 * CORREÇÃO VISUAL: Botões com largura idêntica usando Flexbox.
 * ACEITA CALLBACKS: Para funcionar no botão Agendar também.
 */
function mostrarEscolhaAulaOuJogo(onAula, onJogo) {
    const modalOverlay = document.getElementById('modalConfirmacaoOverlay');
    const modalMensagem = document.getElementById('modalConfirmacaoMensagem');
    const btnContainer = document.querySelector('#modalConfirmacaoOverlay .modal-botoes-container');
    const btnConfirmar = document.getElementById('btnConfirmarAcao'); 
    const btnCancelar = document.getElementById('btnCancelarAcao');   

    if (!modalOverlay || !btnContainer) return;

    modalMensagem.innerHTML = "O que deseja agendar neste horário?";

    // --- FORÇA O LAYOUT FLEXBOX PARA OS 3 BOTÕES ---
    btnContainer.style.display = 'flex';
    btnContainer.style.justifyContent = 'space-between';
    btnContainer.style.gap = '10px'; // Espaço entre eles
    // ------------------------------------------------

    // Função auxiliar para garantir estilo idêntico
    const aplicarEstiloBotao = (btn, cor) => {
        btn.style.flex = '1';           // O SEGREDO: Todos crescem igual (33%)
        btn.style.width = '100%';       // Ocupa o espaço do flex
        btn.style.margin = '0';         // Sem margens externas
        btn.style.padding = '10px 0';   // Altura interna
        btn.style.textAlign = 'center';
        btn.style.backgroundColor = cor;
        btn.style.color = 'white';
        btn.style.border = 'none';
        btn.style.borderRadius = '5px';
        btn.style.cursor = 'pointer';
        btn.style.fontWeight = 'bold';
        btn.style.fontSize = '1rem';
    };

    // 1. Botão JOGO (Azul - Esquerda)
    // Usamos o slot do btnCancelar original
    const btnJogo = btnCancelar.cloneNode(true);
    btnCancelar.parentNode.replaceChild(btnJogo, btnCancelar);
    btnJogo.textContent = "Jogo";
    aplicarEstiloBotao(btnJogo, '#007bff');
    
    btnJogo.onclick = () => {
        restaurarModalOriginal();
        modalOverlay.style.display = 'none';
        if (onJogo) onJogo(); // Executa a ação de Jogo passada por parâmetro
    };

    // 2. Botão AULA (Vermelho - Meio)
    // Usamos o slot do btnConfirmar original
    const btnAula = btnConfirmar.cloneNode(true);
    btnConfirmar.parentNode.replaceChild(btnAula, btnConfirmar);
    btnAula.textContent = "Aula";
    aplicarEstiloBotao(btnAula, '#dc3545');

    btnAula.onclick = () => {
        restaurarModalOriginal();
        modalOverlay.style.display = 'none';
        if (onAula) onAula(); // Executa a ação de Aula passada por parâmetro
    };

    // 3. Botão CANCELAR (Cinza - Direita)
    let btnFechar = document.getElementById('btnTempCancelar');
    if (!btnFechar) {
        btnFechar = document.createElement('button');
        btnFechar.id = 'btnTempCancelar';
        btnContainer.appendChild(btnFechar);
    }
    btnFechar.textContent = "Cancelar";
    aplicarEstiloBotao(btnFechar, '#6c757d');

    btnFechar.onclick = () => {
        restaurarModalOriginal();
        modalOverlay.style.display = 'none';
    };

    // Abre o modal
    if (navigator.vibrate) navigator.vibrate(50);
    modalOverlay.style.display = 'flex';
}


/**
 * Função auxiliar para limpar a bagunça (remover o 3º botão e resetar estilos) ao fechar.
 */
function restaurarModalOriginal() {
    const btnContainer = document.querySelector('#modalConfirmacaoOverlay .modal-botoes-container');
    const btnTemp = document.getElementById('btnTempCancelar');
    
    if (btnTemp) btnTemp.remove();

    // Opcional: Resetar o estilo do container se ele afetar outros modais
    if (btnContainer) {
        btnContainer.style.gap = ''; 
        // Não removemos display:flex pois geralmente é o padrão, mas se quebrar outros modais, avise.
    }
}


/**
 * FASE 4: Libera um horário de GRADE FIXA criando um registro de exceção no banco.
 * E grava um log específico no padrão do sistema.
 */
/**
 * FASE 4: Libera um horário de GRADE FIXA criando um registro de exceção no banco.
 * E grava um log específico no padrão do sistema.
 */
async function liberarHorarioAula(dia, hora, quadra) {
    const key = `${dia}_${hora}`;
    const reservaRef = database.ref(`sistemas/reservas/${quadra}/${key}`);
    const jogadorLogado = localStorage.getItem('jogadorLogado');

    try {
        // 1. Cria o registro "invisível" que libera o horário
        await reservaRef.set({
            status: 'aula_cancelada',
            responsavel: jogadorLogado,
            dataCancelamento: new Date().toISOString(),
            dia: dia,
            hora: hora
        });

        // 2. Prepara os dados para o LOG
        let dataReserva = "Data indefinida";
        try {
             // Captura e formata a data (substitui barras por hifens para manter padrão)
             const elData = document.querySelector(`#tabelaQuadra tr:nth-child(2) td:nth-child(${dia})`);
             if (elData) {
                 dataReserva = elData.textContent.trim().replace(/\//g, '-');
             }
        } catch(e) { console.warn("Erro ao ler data", e); }

        const horarioFormatado = `${String(hora).padStart(2, '0')}:00 - ${String(hora + 1).padStart(2, '0')}:00`;

        // --- [AJUSTE] Identificar Professor da Grade Fixa ---
        let nomeProfessor = "Professor";
        let quadraKey = "";
        
        // Descobre a chave de configuração da quadra (Quadra1, Quadra2, etc)
        if (quadra.includes("1")) quadraKey = "Quadra1";
        else if (quadra.includes("2")) quadraKey = "Quadra2";
        else if (quadra.includes("3")) quadraKey = "Quadra3";

        // Acessa a config global para pegar o nome do professor fixo desta quadra
        if (typeof configAulasGlobal !== 'undefined' && configAulasGlobal[quadraKey]) {
            const profNome = configAulasGlobal[quadraKey].Professor;
            if (profNome) {
                // Tenta achar o apelido correspondente ao nome completo
                const apelidoEncontrado = Object.keys(jogadoresData).find(key => 
                    jogadoresData[key].nomeCompleto === profNome
                );
                nomeProfessor = apelidoEncontrado || profNome;
            }
        }
        
        const textoJogadores = `Aula Fixa - Prof. ${nomeProfessor}`;
        // ---------------------------------------------------
		
		// --- 1. LÓGICA DE ABREVIAÇÃO DE PERFIS (DINÂMICO DO FIREBASE) ---
            let sufixoPerfis = "";
            
            // Busca os dados do usuário logado na memória global
            const dadosUsuarioLogado = Object.values(jogadoresData).find(j => j.nomeCompleto === jogadorLogado);

            if (dadosUsuarioLogado && dadosUsuarioLogado.perfis) {
                // Filtra apenas os perfis ativos (true)
                const perfisAtivos = Object.keys(dadosUsuarioLogado.perfis).filter(k => dadosUsuarioLogado.perfis[k] === true);
                
                // Mapeia usando a configuração global carregada do Firebase (perfisConfigGlobal)
                const listaFormatada = perfisAtivos.map(nomePerfil => {
                    // Tenta pegar a abreviação salva no banco. Se não tiver (ex: Admin antigo), usa o próprio nome.
                    const configPerfil = perfisConfigGlobal[nomePerfil];
                    return (configPerfil && configPerfil.abreviacao) ? configPerfil.abreviacao : nomePerfil;
                });
                
                if (listaFormatada.length > 0) {
                    sufixoPerfis = ` (${listaFormatada.join(', ')})`;
                }
            }
            // Se por algum motivo não achar nada, usa um fallback genérico
            if (sufixoPerfis === "") sufixoPerfis = " (Prof)"; 
            // ----------------------------------------------------

            const logData = {
                quadra: quadra,
                horario: horarioFormatado,
                
                // Campo Jogadores com o nome do professor da aula
                jogadores: [{ apelido: textoJogadores, posicao: "0" }], 
                
                // Nome + Lista de Perfis Abreviada vinda do banco
                usuario: `${jogadorLogado}${sufixoPerfis}`,
                
                duracao: "1 Hora",
                data: dataReserva,
                
                motivo: "Aula de Grade Fixa liberada aos sócios"
            };

        // 3. Entrega para a função central de logs
        registrarExclusao(logData);

        mostrarNotificacao("Horário liberado para jogos!", 'success');
        fecharModalAcoes(); 

    } catch (error) {
        console.error(error);
        mostrarNotificacao("Erro ao liberar horário.", 'error');
    }
}



/**
 * Menu específico para gerenciar células de AULA (Vermelhas).
 */
/**
 * Menu específico para gerenciar células de AULA (Vermelhas).
 */
function mostrarOpcoesAula(tipoAula, dia, hora, quadra) {
    // 1. LIMPEZA E PREPARAÇÃO DO MODAL
    limparBotoesFantasmas();

    const modal = document.getElementById('modalAcoesReserva');
    const modalTitulo = modal.querySelector('h3');
    
    // Configura os Botões
    const btnAcao = document.getElementById('btnModalExcluir');
    const btnCancelar = document.getElementById('btnModalCancelar');

    // Garante visibilidade
    btnAcao.style.display = 'block';
    
    // ========================================================================
    // CENÁRIO 1: AULA FIXA (Grade) - Mantém lógica original
    // ========================================================================
    if (tipoAula === 'aula_fixa') {
        modalTitulo.textContent = "Gerenciar Grade Fixa";
        btnAcao.textContent = "Liberar Horário para Sócios";
        btnAcao.style.backgroundColor = "#28a745"; // Verde
        
        btnAcao.onclick = () => {
            fecharModalAcoes(); 
            const msg = "Deseja liberar este horário da sua grade para que sócios possam agendar?";
            mostrarConfirmacao(msg, () => liberarHorarioAula(dia, hora, quadra), null, 'success');
        };
    } 
    // ========================================================================
    // CENÁRIO 2: AULA EXTRA (Avulsa) - AQUI ESTÁ A MUDANÇA
    // ========================================================================
    else {
		modalTitulo.textContent = "Gerenciar Aula Extra";
		btnAcao.textContent = "Cancelar Aula";
		btnAcao.style.backgroundColor = "#dc3545"; // Vermelho
		
		btnAcao.onclick = () => {
			fecharModalAcoes(); 
			
			// --- 1. LÓGICA DE RECUO (BACKTRACKING) ---
			const reservas = reservasPorQuadra[quadra] || {};
			let horaInicio = hora;
			
			for (let h = hora - 1; h >= 6; h--) {
				const prevKey = `${dia}_${h}`;
				const prevR = reservas[prevKey];
				const nomeAnt = (prevR && prevR.jogadores) ? prevR.jogadores.toLowerCase().trim() : "";
				const tipoAnt = prevR ? prevR.tipo : "";
				
				if (nomeAnt === 'aula' || tipoAnt === 'aula_extra') {
					horaInicio = h; 
				} else {
					break; 
				}
			}

			// --- 2. LÓGICA DE AVANÇO (SCAN) ---
			let duracaoTotal = 0;
			for (let h = horaInicio; h <= 23; h++) {
				const nextKey = `${dia}_${h}`;
				const nextR = reservas[nextKey];
				const nomeNext = (nextR && nextR.jogadores) ? nextR.jogadores.toLowerCase().trim() : "";
				const tipoNext = nextR ? nextR.tipo : "";
				
				if (nomeNext === 'aula' || tipoNext === 'aula_extra') {
					duracaoTotal++;
				} else {
					break;
				}
			}
			if (duracaoTotal < 1) duracaoTotal = 1;

			// --- 3. PREPARAÇÃO DE DADOS PARA O LOG ---
			
			// A. Captura a Data
			let dataReservaTexto = "Data indefinida";
			try {
				const celulaData = document.getElementById('tabelaQuadra').rows[1].cells[dia - 1];
				if (celulaData) {
					dataReservaTexto = celulaData.textContent.trim().replace(/\//g, '-');
				}
			} catch (e) {
				console.error("Erro ao capturar data:", e);
			}

			// B. Captura o Apelido do Professor (AJUSTE SOLICITADO)
			const reservaAlvo = reservas[`${dia}_${horaInicio}`];
			let nomeProfessor = "Professor";

			if (reservaAlvo && reservaAlvo.organizador) {
				const nomeCompleto = reservaAlvo.organizador;
				// Procura na lista global 'jogadoresData' qual apelido corresponde a esse nome completo
				// (jogadoresData tem a estrutura: { "Apelido": { nomeCompleto: "Nome Completo" } })
				const apelidoEncontrado = Object.keys(jogadoresData).find(key => 
					jogadoresData[key].nomeCompleto === nomeCompleto
				);
				
				// Se achar o apelido, usa ele. Se não, usa o nome completo como fallback.
				nomeProfessor = apelidoEncontrado || nomeCompleto;
			}

			const textoJogadoresLog = `Aula Extra - Prof. ${nomeProfessor}`;

			const horaFim = horaInicio + duracaoTotal;
			const textoHorario = `${String(horaInicio).padStart(2, '0')}:00 às ${String(horaFim).padStart(2, '0')}:00`;
			
			const msg = `Deseja cancelar esta aula extra?<br><br><b>Data: ${dataReservaTexto.replace(/-/g, '/')}</b><br><b>Horário: ${textoHorario}</b>`;

			// --- 4. AÇÃO DE EXCLUSÃO ---
            const acaoExcluirAulaEmLote = async () => {
                const updates = {};
                
                for (let i = 0; i < duracaoTotal; i++) {
                    const hAtual = horaInicio + i;
                    const key = `${dia}_${hAtual}`;
                    updates[`sistemas/reservas/${quadra}/${key}`] = null;
                }

                // --- LÓGICA DE ABREVIAÇÃO DE PERFIS (IGUAL AULA FIXA) ---
                let sufixoPerfis = "";
                const jogadorLogado = localStorage.getItem('jogadorLogado') || "Sistema";
                
                // Busca os dados do usuário logado na memória global
                const dadosUsuarioLogado = Object.values(jogadoresData).find(j => j.nomeCompleto === jogadorLogado);

                if (dadosUsuarioLogado && dadosUsuarioLogado.perfis) {
                    const perfisAtivos = Object.keys(dadosUsuarioLogado.perfis).filter(k => dadosUsuarioLogado.perfis[k] === true);
                    
                    // Mapeia usando a configuração global
                    const listaFormatada = perfisAtivos.map(nomePerfil => {
                        const configPerfil = perfisConfigGlobal[nomePerfil];
                        return (configPerfil && configPerfil.abreviacao) ? configPerfil.abreviacao : nomePerfil;
                    });
                    
                    if (listaFormatada.length > 0) {
                        sufixoPerfis = ` (${listaFormatada.join(', ')})`;
                    }
                }
                if (sufixoPerfis === "") sufixoPerfis = " (Prof/Admin)"; // Fallback padrão
                // --------------------------------------------------------

                const logData = {
                    quadra: quadra,
                    horario: textoHorario,
                    jogadores: [{ apelido: textoJogadoresLog, posicao: "0" }],
                    
                    // AQUI: Nome + Lista de Perfis Abreviada
                    usuario: `${jogadorLogado}${sufixoPerfis}`,
                    
                    duracao: `${duracaoTotal}h`,
                    
                    // AQUI: Motivo limpo (sem emoji)
                    motivo: "Aula Extra cancelada para uso dos sócios",
                    
                    data: dataReservaTexto 
                };
                
                registrarExclusao(logData); 

                try {
                    await database.ref().update(updates);
                    mostrarNotificacao('Aula cancelada com sucesso!', 'success');
                } catch (error) {
                    console.error(error);
                    mostrarNotificacao('Erro ao cancelar aula.', 'error');
                }
            };

			mostrarConfirmacao(msg, acaoExcluirAulaEmLote, null, 'danger');
		};
	}
	
	
    // Configura botão fechar/cancelar do modal
    btnCancelar.style.display = 'block';
    btnCancelar.textContent = "Cancelar";
    btnCancelar.onclick = fecharModalAcoes;

    // Exibe o modal
    modal.style.display = 'flex';
}





/**
 * Menu específico para gerenciar MANUTENÇÃO (Bloqueios Técnicos).
 */
function mostrarOpcoesManutencao(dia, hora, quadra) {
    // 1. Limpa botões antigos para evitar conflitos
    limparBotoesFantasmas();

    const modal = document.getElementById('modalAcoesReserva');
    const modalTitulo = modal.querySelector('h3');
    
    // Configura os Botões do Modal
    const btnAcao = document.getElementById('btnModalExcluir');
    const btnCancelar = document.getElementById('btnModalCancelar');

    if (!modal || !btnAcao || !btnCancelar) return;

    // Ajusta Título e Botão
    modalTitulo.textContent = "Gerenciar Manutenção";
    
    btnAcao.style.display = 'block';
    btnAcao.textContent = "Cancelar Manutenção";
    btnAcao.style.backgroundColor = "#dc3545"; // Vermelho
    
    // --- CORREÇÃO DA LÓGICA DO CLIQUE ---
    // --- CORREÇÃO DA LÓGICA DO CLIQUE ---
    btnAcao.onclick = () => {
        // Fecha o menu de ações primeiro
        fecharModalAcoes(); 
        
        // 1. Calcula a duração real do bloqueio para a mensagem e exclusão
        const reservas = reservasPorQuadra[quadra] || {};
        let duracao = 1;
        
        // Verifica quantas horas seguidas são de manutenção
        for (let h = hora + 1; h <= 23; h++) {
            const nextKey = `${dia}_${h}`;
            const nextR = reservas[nextKey];
            const nextNome = (nextR && nextR.jogadores) ? nextR.jogadores.toLowerCase().trim() : "";
            
            if (nextNome === 'manutencao') {
                duracao++;
            } else {
                break;
            }
        }
        
        const horaFim = hora + duracao;
        const textoHorario = `${String(hora).padStart(2, '0')}:00 às ${String(horaFim).padStart(2, '0')}:00`;
        
        // 2. Prepara a mensagem de confirmação
        const msg = `Deseja remover este bloqueio de manutenção?<br><br><b>Horário: ${textoHorario}</b>`;

        // 3. Define a ação de exclusão (Callback)
        const acaoExcluirBloco = async () => {
            const updates = {};
            
            // Marca como null todas as horas do bloco
            for (let i = 0; i < duracao; i++) {
                const hAtual = hora + i;
                const key = `${dia}_${hAtual}`;
                updates[`sistemas/reservas/${quadra}/${key}`] = null;
            }
            
            // --- NOVA LÓGICA DE IDENTIFICAÇÃO E MOTIVO ---
            const keyInicial = `${dia}_${hora}`;
            const reservaInicial = reservas[keyInicial];
            
            // Define o Responsável (se não tiver, assume "Erick")
            const responsavelOriginal = (reservaInicial && reservaInicial.organizador) ? reservaInicial.organizador : "Erick";
            const usuarioLogado = localStorage.getItem('jogadorLogado') || "Desconhecido";

         
            
            // --- LÓGICA DE ABREVIAÇÃO DE PERFIS (IGUAL AULA) ---
            let sufixoPerfis = "";
            // Usa o 'usuarioLogado' que já foi definido algumas linhas acima
            const dadosUsuarioLogado = Object.values(jogadoresData).find(j => j.nomeCompleto === usuarioLogado);

            if (dadosUsuarioLogado && dadosUsuarioLogado.perfis) {
                const perfisAtivos = Object.keys(dadosUsuarioLogado.perfis).filter(k => dadosUsuarioLogado.perfis[k] === true);
                
                const listaFormatada = perfisAtivos.map(nomePerfil => {
                    const configPerfil = perfisConfigGlobal[nomePerfil];
                    return (configPerfil && configPerfil.abreviacao) ? configPerfil.abreviacao : nomePerfil;
                });
                
                if (listaFormatada.length > 0) {
                    sufixoPerfis = ` (${listaFormatada.join(', ')})`; 
                }
            }
            if (sufixoPerfis === "") sufixoPerfis = " (Via Menu)"; // Fallback padrão
            // ---------------------------------------------------

            // Tenta pegar a data da tabela de forma segura
            let dataTexto = "Data desconhecida";
            try {
                const celulaData = document.getElementById('tabelaQuadra').rows[1].cells[dia-1];
                if (celulaData) dataTexto = celulaData.textContent.trim();
            } catch(e) {}

            const logData = {
                quadra: quadra,
                horario: textoHorario,
                jogadores: [{ apelido: "Manutençao - Resp. " + responsavelOriginal, posicao: "0" }],
                
                // AQUI: Nome + Lista de Perfis Abreviada
                usuario: `${usuarioLogado}${sufixoPerfis}`,
                
                duracao: `${duracao}h`,
                data: dataTexto,
                motivo: "Manutenção liberada para uso dos sócios" 
            };
            
            // Registra Log e Atualiza Banco
            registrarExclusao(logData);

            try {
                await database.ref().update(updates);
                mostrarNotificacao('Manutenção removida com sucesso!', 'success');
            } catch (error) {
                console.error(error);
                mostrarNotificacao('Erro ao remover manutenção.', 'error');
            }
        };

        // 4. Chama a confirmação (VERMELHA)
        mostrarConfirmacao(msg, acaoExcluirBloco, null, 'danger');
    }; 

    // Configura o botão Cancelar (apenas fecha o menu)
    btnCancelar.style.display = 'block';
    btnCancelar.textContent = "Cancelar";
    btnCancelar.onclick = fecharModalAcoes;

    // Exibe o modal inicial
    modal.style.display = 'flex';
}




/**
 * Verifica se um horário específico faz parte da Grade Fixa configurada.
 */
function verificarSeEhGradeFixa(quadraNome, dia, hora) {
    let quadraKey = "";
    if (quadraNome.includes("1")) quadraKey = "Quadra1";
    else if (quadraNome.includes("2")) quadraKey = "Quadra2";
    else if (quadraNome.includes("3")) quadraKey = "Quadra3";

    const config = configAulasGlobal[quadraKey];
    if (!config || !config.Ativo || !config.Grade) return false;

    const keyGrade = `${dia}_${hora}`;
    return config.Grade[keyGrade] === true;
}



// --- FUNÇÃO FAXINEIRA (RESOLVE O PROBLEMA DO MENU MISTURADO) ---
function limparBotoesFantasmas() {
    // 1. Remove fisicamente o botão da pirâmide se ele tiver sobrado
    const btnFantasma = document.getElementById('btnModalResultado');
    if (btnFantasma) btnFantasma.remove();
    
    // 2. Remove botão de duplas se houver
    const btnDuplas = document.getElementById('btnModalResultadoDuplas');
    if (btnDuplas) btnDuplas.remove();

    // 3. Reseta os botões padrão para garantir que sumam
    const idsPadrao = ['btnModalVer', 'btnModalEditar', 'btnModalExcluir', 'btnModalCancelar', 'btnModalDelegar'];
    idsPadrao.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.style.display = 'none';
    });
}




/**
 * Gera mensagem de erro formatada com HTML e Emojis.
 * @param {Object} dadosReserva - O objeto da reserva que causou conflito.
 * @param {boolean} foiConcorrencia - Se true = "Acabou de ser reservado" (Duelo). Se false = "Já existe" (Passado).
 */
function obterMensagemDeConflito(dadosReserva, foiConcorrencia) {
    const jogadoresStr = dadosReserva.jogadores_completo || dadosReserva.jogadores || "";
    const nomeNormalizado = jogadoresStr.toLowerCase().trim();
    const status = dadosReserva.status;
    
    // Títulos diferentes para cada situação
    const titulo = foiConcorrencia 
        ? "❌ <b>Tarde demais!</b>" 
        : "❌ <b>Horário Indisponível</b>";

    const acao = foiConcorrencia 
        ? "acabou de ser reservado" 
        : "já está reservado";

    // --- MANUTENÇÃO ---
    if (nomeNormalizado.includes('manutencao') || dadosReserva.tipo === 'manutencao') {
        const msgManutencao = foiConcorrencia 
            ? "Uma <b>Manutenção</b> acabou de ser agendada neste horário." 
            : "Já existe uma <b>Manutenção</b> programada para este horário.";
            
        return `${titulo}<br>${msgManutencao}`;
    } 
    
    // --- AULA ---
    else if (nomeNormalizado.includes('aula') || dadosReserva.tipo === 'aula_extra' || dadosReserva.tipo === 'aula_fixa') {
        const msgAula = foiConcorrencia 
            ? "Uma <b>Aula</b> acabou de ser confirmada neste horário." 
            : "Já existe uma <b>Aula</b> confirmada neste horário.";

        return `${titulo}<br>${msgAula}`;
    } 
    
    // --- PENDENTE ---
    else if (status === 'pendente') {
         return `⚠️ <b>Atenção:</b><br>O horário está pré-reservado por <b>${jogadoresStr}</b> e aguarda confirmação.`;
    }
    
    // --- RESERVA COMUM ---
    else {
        return `${titulo}<br>O horário ${acao} por:<br><b>${jogadoresStr}</b>`;
    }
}


/**
 * O PORTEIRO: Verifica quem é o usuário ao clicar no botão (+)
 * Retorna TRUE se deve seguir o fluxo normal (abrir form).
 * Retorna FALSE se deve parar (porque abriu o menu de opções).
 */
/**
 * O PORTEIRO DO BOTÃO (+): Decide se abre formulário direto ou menu de opções
 */
/**
 * O PORTEIRO DO BOTÃO (+): Decide se abre formulário direto ou menu de opções
 * CORREÇÃO: Agora verifica se o professor é dono da quadra atual antes de oferecer a opção "Aula".
 */
function verificarPermissoesBotaoMais() {
    const apelidoLogado = localStorage.getItem('jogadorLogado');
    
    // --- CORREÇÃO: LÊ A VARIÁVEL GLOBAL ---
    // Usa a variável que já sabemos que está correta ("Quadra 2 - Aberta")
    const quadra = typeof quadraSelecionada !== 'undefined' ? quadraSelecionada : 'Quadra 1 - Coberta';
    // --------------------------------------

    const dia = undefined; 
    const hora = undefined; 

    // 1. Verifica se pode JOGAR
    let dadosUser = null;
    if (typeof jogadoresData !== 'undefined') {
        // Tenta pegar direto (caso raro onde apelido == nome)
        if (jogadoresData[apelidoLogado]) {
            dadosUser = jogadoresData[apelidoLogado];
        } else {
            // Busca pelo nomeCompleto dentro dos valores
            const k = Object.keys(jogadoresData).find(x => jogadoresData[x].nomeCompleto === apelidoLogado);
            if (k) dadosUser = jogadoresData[k];
        }
    }
    const vinculo = dadosUser && dadosUser.socio ? String(dadosUser.socio).toLowerCase().trim() : '';
    const podeJogar = (vinculo === 'titular' || vinculo === 'dependente');

    // 2. Verifica Permissões TÉCNICAS
    const opcoesTecnicas = [];
    const isAdmin = typeof isUsuarioAdmin === 'function' ? isUsuarioAdmin() : false;
    const isManut = typeof isUsuarioManutencao === 'function' ? isUsuarioManutencao() : false;
    
    // Passa a quadra correta para a nova função corrigida
    const isProf = typeof isUsuarioProfessor === 'function' ? isUsuarioProfessor(quadra) : false;

    // 3. Monta o Menu
    if (isAdmin) {
        opcoesTecnicas.push({ id: 'aula', label: '🏃 Aula', func: 'executarAgendamentoAulaExtra' });
        opcoesTecnicas.push({ id: 'manutencao', label: '💦 Manutenção', func: 'executarAgendamentoManutencao' });
    } else {
        if (isProf) opcoesTecnicas.push({ id: 'aula', label: '🏃 Aula', func: 'executarAgendamentoAulaExtra' });
        if (isManut) opcoesTecnicas.push({ id: 'manutencao', label: '💦 Manutenção', func: 'executarAgendamentoManutencao' });
    }

    // 4. Decisão
    if (!podeJogar && opcoesTecnicas.length === 1) {
        if (typeof window[opcoesTecnicas[0].func] === 'function') window[opcoesTecnicas[0].func](dia, hora, quadra);
        return false; 
    }
    if (podeJogar && opcoesTecnicas.length === 0) {
        return true; 
    }
    if (opcoesTecnicas.length > 0) {
        exibirModalAgendamentoDinamico(dia, hora, quadra, podeJogar, opcoesTecnicas);
        return false; 
    }
    
    return true;
}








// --- FUNÇÃO CORRIGIDA: SALVAR MANUTENÇÃO PELO FORMULÁRIO ---
// --- FUNÇÃO CORRIGIDA: SALVAR MANUTENÇÃO (SEM CÓDIGO EXTRA) ---
// --- FUNÇÃO CORRIGIDA: SALVAR MANUTENÇÃO (SEM CHUTES) ---
// --- FUNÇÃO CORRIGIDA: SALVAR MANUTENÇÃO (PADRÃO ASYNC/AWAIT) ---
window.salvarManutencaoPeloForm = async function() {
    if (navigator.vibrate) { navigator.vibrate(50); }
    const inputHora = document.getElementById('hora');
    if (!inputHora || inputHora.value === "" || inputHora.value === "Sem horários") {
        mostrarNotificacao("Sem horários disponíveis.", 'warning'); return; 
    }
    const quadra = document.getElementById('quadra').value;
    const dia = parseInt(document.getElementById('dia').value, 10);
    const hora = parseInt(document.getElementById('hora').value, 10);
    
    if (!quadra || isNaN(dia) || isNaN(hora)) { mostrarNotificacao("Preencha corretamente.", "error"); return; }

    // --- USA A NOVA FUNÇÃO AUXILIAR ---
    const dataCompletaParaGravar = calcularDataDoDiaSelecionado(dia);

    const apelidoLogado = localStorage.getItem('jogadorLogado');
    const key = `${dia}_${hora}`;
    const reservasRef = database.ref(`sistemas/reservas/${quadra}/${key}`);

    try {
        const snapshot = await reservasRef.once('value');
        if (snapshot.exists() && snapshot.val().status !== 'aula_cancelada') {
            mostrarNotificacao("Horário ocupado!", "error"); return;
        }
        const dadosManutencao = {
            jogadores: "Manutencao", jogadores_completo: "Manutencao",
            dia: dia, hora: hora, duracao: 1, borda: '1h',
            status: 'confirmada', organizador: apelidoLogado || 'Staff', responsavel: apelidoLogado || 'Staff',
            tipo: 'manutencao',
            dataCompleta: dataCompletaParaGravar, // <--- GARANTIDO
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        await reservasRef.set(dadosManutencao);
        mostrarNotificacao("Manutenção agendada!", "success");
        if (typeof limparCampos === 'function') limparCampos();
        document.querySelector('.form-container').classList.remove('visible');
        document.getElementById('formBackdrop').classList.remove('visible');
        document.getElementById('fab-toggle-form').classList.remove('active');
    } catch (erro) { console.error(erro); mostrarNotificacao("Erro: " + erro.message, "error"); }
}





// --- NOVA FUNÇÃO EXCLUSIVA (ADICIONE NO SEU CÓDIGO) ---
// --- FUNÇÃO EXCLUSIVA DE AULA (PADRÃO VISUAL IGUAL MANUTENÇÃO) ---
window.salvarAulaPeloForm = async function() {
    if (navigator.vibrate) { navigator.vibrate(50); }
	const inputHora = document.getElementById('hora');
    if (!inputHora || inputHora.value === "" || inputHora.value === "Sem horários" || inputHora.value === "Fechado") {
        mostrarNotificacao("<b>⚠️ Atenção:</b><br>Não há horários disponíveis.", 'warning');
        return; 
    }
    const quadra = document.getElementById('quadra').value;
    const dia = parseInt(document.getElementById('dia').value, 10);
    const hora = parseInt(document.getElementById('hora').value, 10);
    
    if (!quadra || !dia || !hora) { mostrarNotificacao("Preencha todos os campos.", "error"); return; }

    // --- USA A NOVA FUNÇÃO AUXILIAR ---
    const dataCompletaParaGravar = calcularDataDoDiaSelecionado(dia);

    const apelidoLogado = localStorage.getItem('jogadorLogado');
    const dadosAula = {
        jogadores: "Aula", jogadores_completo: "Aula", 
        dia: dia, hora: hora, duracao: 1, borda: '1h',
        status: 'confirmada', organizador: apelidoLogado || 'Professor', responsavel: apelidoLogado,
        tipo: 'aula_extra',
        dataCompleta: dataCompletaParaGravar, // <--- GARANTIDO
        timestamp: firebase.database.ServerValue.TIMESTAMP
    };

    const key = `${dia}_${hora}`;
    const reservasRef = database.ref(`sistemas/reservas/${quadra}/${key}`);

    try {
        const snapshot = await reservasRef.once('value');
        if (snapshot.exists() && snapshot.val().status !== 'aula_cancelada') {
            mostrarNotificacao("Horário ocupado!", "error");
            if (typeof atualizarOpcoesHorario === 'function') atualizarOpcoesHorario();
            return;
        }
        await reservasRef.set(dadosAula);
        mostrarNotificacao("Aula agendada!", "success");
        limparCampos(); 
        document.querySelector('.form-container').classList.remove('visible');
        document.getElementById('formBackdrop').classList.remove('visible');
        document.getElementById('fab-toggle-form').classList.remove('active');
    } catch (erro) { console.error(erro); mostrarNotificacao("Erro: " + erro.message, "error"); }
};

// --- CONTROLE DINÂMICO DE QUADRAS (VIA FIREBASE) ---

// --- CONTROLE DINÂMICO DE QUADRAS (VIA FIREBASE) ---
// VERSÃO APRIMORADA: CORRIGE O ERRO DE NOMES COM SOBRENOME NO MEIO

function restringirQuadraPeloConfig() {
    // 1. Verifica se temos as configurações carregadas do banco
    if (typeof configAulasGlobal === 'undefined' || !configAulasGlobal) {
        console.warn("Configurações de aula não carregadas ainda.");
        return;
    }

    const elQuadra = document.getElementById('quadra');
    const jogadorLogado = localStorage.getItem('jogadorLogado'); // Ex: "ADRIANO GOMES FEITOSA"
    
    if (!elQuadra || !jogadorLogado) return;

    let quadraDoProfessor = null;
    const nomeLogadoUpper = jogadorLogado.toUpperCase();

    // 2. Varre a configuração vinda do Firebase (Quadra1, Quadra2, etc...)
    for (const keyQuadra in configAulasGlobal) {
        const config = configAulasGlobal[keyQuadra];
        
        if (config && config.Professor) {
            const nomeProfessorConfig = config.Professor.toUpperCase(); // Ex: "ADRIANO FEITOSA"

            // 3. LÓGICA DE COMPARAÇÃO ROBUSTA
            
            // A. Comparação Simples (Funciona para Vania e Rildo)
            const matchSimples = nomeLogadoUpper.includes(nomeProfessorConfig) || nomeProfessorConfig.includes(nomeLogadoUpper);

            // B. Comparação por Palavras (Funciona para Adriano Gomes Feitosa)
            // Quebra "ADRIANO FEITOSA" em ["ADRIANO", "FEITOSA"]
            const partesNomeConfig = nomeProfessorConfig.split(' ').filter(p => p.trim() !== "");
            
            // Verifica se TODAS as partes (Adriano E Feitosa) estão dentro de "ADRIANO GOMES FEITOSA"
            const matchPalavras = partesNomeConfig.length > 0 && partesNomeConfig.every(parte => nomeLogadoUpper.includes(parte));

            if (matchSimples || matchPalavras) {
                // Achamos! Este usuário é o professor desta quadra.
                quadraDoProfessor = keyQuadra.replace(/\D/g, ''); // Extrai o número ("2")
                break; 
            }
        }
    }

    // 4. Se encontrou uma quadra vinculada a este usuário:
    if (quadraDoProfessor) {
        console.log(`[Sistema] Usuário ${jogadorLogado} identificado como professor da Quadra ${quadraDoProfessor}`);
        
        let mudouSelecao = false;

        for (let i = 0; i < elQuadra.options.length; i++) {
            const opt = elQuadra.options[i];
            
            // Verifica se a opção do select corresponde à quadra do professor
            if (opt.text.includes(quadraDoProfessor) || opt.value.includes(quadraDoProfessor)) {
                opt.disabled = false;
                opt.hidden = false;
                
                // Força a seleção se já não estiver nela
                if (elQuadra.selectedIndex !== i) {
                    elQuadra.selectedIndex = i;
                    mudouSelecao = true;
                }
            } else {
                // Bloqueia as outras quadras
                opt.disabled = true;
                opt.hidden = true; 
            }
        }

        // 5. Atualiza horários se trocou a quadra forçadamente
        if (mudouSelecao && typeof atualizarOpcoesHorario === 'function') {
            atualizarOpcoesHorario();
        }
    }
}



function liberarTodasQuadras() {
    const elQuadra = document.getElementById('quadra'); 
    if (!elQuadra) return;

    // Destrava tudo para modo Jogo
    for (let i = 0; i < elQuadra.options.length; i++) {
        elQuadra.options[i].disabled = false;
        elQuadra.options[i].hidden = false;
    }
}


// --- FUNÇÃO AUXILIAR: Calcula a data exata (YYYY-MM-DD) baseada no dia da semana (1-7) ---
// --- FUNÇÃO AUXILIAR CORRIGIDA (SEM FUSO HORÁRIO) ---
function calcularDataDoDiaSelecionado(diaSelecionado) {
    const data = new Date(); // Pega a data/hora atual do seu computador
    
    // Descobre o índice de hoje (1=Segunda ... 7=Domingo)
    const diaHojeIndex = data.getDay() === 0 ? 7 : data.getDay();
    
    // Calcula quantos dias faltam para chegar no dia selecionado
    let diff = diaSelecionado - diaHojeIndex;
    
    // Se o dia selecionado já passou na semana (ex: Hoje é Sexta e escolheu Terça),
    // significa que é na próxima semana, então soma 7 dias.
    if (diff < 0) diff += 7;
    
    // Adiciona os dias à data de hoje
    data.setDate(data.getDate() + diff);
    
    // --- O SEGREDO ESTÁ AQUI ---
    // Não usamos toISOString(). Montamos a string manualmente com os dados locais.
    // Isso impede que 22:00 vire o dia seguinte.
    const yyyy = data.getFullYear();
    const mm = String(data.getMonth() + 1).padStart(2, '0'); // Meses começam em 0
    const dd = String(data.getDate()).padStart(2, '0');
    
    return `${yyyy}-${mm}-${dd}`;
}


// ==========================================================
// ==========================================================
    // --- FUNÇÃO DO CABEÇALHO (DADOS REAIS: NOME E APELIDO) ---
    // ==========================================================
// 1. Função Global para atualizar o nome (chamada no Login e no Carregamento)
    function atualizarCabecalhoUsuario() {
        var nomeLogado = localStorage.getItem("jogadorLogado");
        var elementoNome = document.getElementById("header-nome");
        
        if (nomeLogado && elementoNome) {
            // Formata Nome Completo para Título (PC)
            var nomePC = nomeLogado.toLowerCase().split(' ').map(function(palavra) {
                return palavra.charAt(0).toUpperCase() + palavra.slice(1);
            }).join(' ');

            // Tenta pegar o Apelido do Cache (Mobile)
            var apelidoMobile = nomePC.split(' ')[0]; 
            try {
                var cacheRaw = localStorage.getItem('jogadoresDataCache');
                if (cacheRaw) {
                    var dadosJogadores = JSON.parse(cacheRaw);
                    if (dadosJogadores[nomeLogado] && dadosJogadores[nomeLogado].apelido) {
                        apelidoMobile = dadosJogadores[nomeLogado].apelido;
                    }
                }
            } catch (e) { console.warn("Cache indisp."); }

            // Atualiza o HTML
            elementoNome.innerHTML = 'Olá, <span class="nome-desktop">' + nomePC + '</span><span class="nome-mobile">' + apelidoMobile + '</span>';
        }
    }

    // 2. Executa ao carregar a página
    document.addEventListener("DOMContentLoaded", function() {
        // Atualiza o nome assim que abre
        atualizarCabecalhoUsuario(); 
        
        // Reconecta o botão CONFIRMAR da janela de sair
        var btnConfirmar = document.getElementById("btn-confirmar-logout");
        if (btnConfirmar) {
            btnConfirmar.onclick = fazerLogout; 
        }

        // Reconecta o botão CANCELAR da janela de sair
        var btnCancelar = document.getElementById("btn-cancelar-logout");
        var modal = document.getElementById("modal-logout");
        if (btnCancelar && modal) {
            btnCancelar.onclick = function() { modal.style.display = "none"; };
        }
		
				
    }); 



// ==================================================
    // === LÓGICA DO TECLADO VIRTUAL (SOLUÇÃO DEFINITIVA) ===
    // ==================================================

    // Adiciona número ao visor
    window.teclar = function(numero) {
        var campo = document.getElementById('acesso_user');
        if (!campo) return;
        
        // Limite de 8 dígitos (data de nascimento)
        if (campo.value.length < 8) {
            campo.value += numero;
        }
    };

    // Apaga o último número (Backspace)
    window.apagarUltimo = function() {
        var campo = document.getElementById('acesso_user');
        if (!campo) return;
        
        campo.value = campo.value.slice(0, -1);
    };

    // Limpa tudo (C)
    window.limparSenha = function() {
        var campo = document.getElementById('acesso_user');
        if (!campo) return;
        
        campo.value = '';
    };
    
    // Pequeno ajuste para o botão "Olho" funcionar com input readonly
    // --- CORREÇÃO DO BOTÃO OLHO ---
    // --- LÓGICA DO BOTÃO OLHO (COM DIAGNÓSTICO) ---
    // --- LÓGICA DO BOTÃO OLHO (CORRIGIDA COM FORÇA BRUTA) ---
    document.addEventListener('DOMContentLoaded', function() {
        var toggleBtn = document.getElementById('toggleSenha');
        var campo = document.getElementById('acesso_user');

        if(toggleBtn && campo) {
            // Remove listeners antigos
            var novoBtn = toggleBtn.cloneNode(true);
            toggleBtn.parentNode.replaceChild(novoBtn, toggleBtn);
            
            // Garante estado inicial
            campo.style.setProperty('-webkit-text-security', 'disc', 'important');
            
            novoBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();

                // Verifica se está com bolinhas (disc)
                var estiloAtual = window.getComputedStyle(campo).webkitTextSecurity;
                var estaOculto = estiloAtual === 'disc' || estiloAtual === 'circle' || estiloAtual === 'square';
                
                if (estaOculto) {
                    // MOSTRAR: Remove as bolinhas com 'important' para vencer o CSS
                    campo.style.setProperty('-webkit-text-security', 'none', 'important');
                    novoBtn.textContent = '🙈'; // Ícone aberto
                } else {
                    // ESCONDER: Volta as bolinhas
                    campo.style.setProperty('-webkit-text-security', 'disc', 'important');
                    novoBtn.textContent = '👁️'; // Ícone fechado
                }
            });
        }
    });  


// ==================================================
    // === LÓGICA DO TECLADO SLIDE (FINAL + COMPORTAMENTO DA JANELA) ===
    // ==================================================
    
    // 1. Funções de Digitação
    window.teclar = function(numero) {
        var campo = document.getElementById('acesso_user');
        if (campo.value.length < 8) {
            campo.value += numero;
            if (navigator.vibrate) navigator.vibrate(10);
        }
    };
    
    window.apagarUltimo = function() {
        var campo = document.getElementById('acesso_user');
        campo.value = campo.value.slice(0, -1);
    };

    window.limparSenha = function() {
        var campo = document.getElementById('acesso_user');
        campo.value = '';
    };

    // 2. Controle de Abrir/Fechar a Gaveta e Foco Visual
    window.abrirTeclado = function() {
        if (window.innerWidth < 768) {
            // Abre a gaveta
            document.getElementById('teclado-overlay').classList.add('aberto');
            
            var header = document.getElementById('loginHeader');
            var telaLogin = document.getElementById('loginScreen');
            var campo = document.getElementById('acesso_user');

            if (header) header.style.display = 'none';
            
            // Sua altura preferida de 35%
            if (telaLogin) {
                // --- VERIFICAÇÃO DE TELA CHEIA (APP INSTALADO) ---
                // Detecta se está rodando como "App" (Standalone) no iOS ou Android
                var isStandalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;

                if (isStandalone) {
                    // MODO TELA CHEIA (Sem barra de endereço -> Mais espaço)
                    telaLogin.style.top = '40%'; // Desce um pouco mais
                } else {
                    // MODO NAVEGADOR (Com barras em cima/baixo -> Menos espaço)
                    telaLogin.style.top = '35%'; // Sobe para não cortar
                }
            } 

            // --- LÓGICA DE FOCO E CURSOR ---
            if (campo) {
                // 1. Simula o Foco (Borda Azul igual do iPhone/Android)
                campo.style.borderColor = "#007aff";
                campo.style.boxShadow = "0 0 0 2px rgba(0,122,255,0.3)";
                
                // 2. Garante que o cursor virtual vá para o final do texto
                // Isso impede que o texto fique "selecionado" (azul) parecendo que vai apagar
                var tamanhoTexto = campo.value.length;
                campo.setSelectionRange(tamanhoTexto, tamanhoTexto);
            }
        }
    };

    window.fecharTeclado = function() {
        document.getElementById('teclado-overlay').classList.remove('aberto');
        
        var header = document.getElementById('loginHeader');
        var telaLogin = document.getElementById('loginScreen');
        var campo = document.getElementById('acesso_user');

        if (header) header.style.display = 'block';
        if (telaLogin) telaLogin.style.top = '50%'; 
        
        // Remove o foco visual (Borda volta ao normal)
        if (campo) {
            campo.style.borderColor = ""; 
            campo.style.boxShadow = "";
        }
    };

    // 3. Configuração de Eventos
    document.addEventListener('DOMContentLoaded', function() {
        var campo = document.getElementById('acesso_user');
        
        if (campo) {
            function tentarAbrir(e) {
                if (window.innerWidth < 768) {
                    e.preventDefault(); // Impede teclado nativo
                    campo.blur();       // Tira foco nativo
                    abrirTeclado();     // Chama nossa função que arruma a tela
                }
            }

            campo.addEventListener('click', tentarAbrir);
            campo.addEventListener('touchstart', tentarAbrir, { passive: false });
        }

        // Ajuste PC vs Celular
        function ajustarInput() {
            if (window.innerWidth >= 768) {
                 campo.removeAttribute('readonly');
                 campo.style.pointerEvents = 'auto';
                 campo.style.cursor = 'text';
                 // Garante que o header esteja visível no PC
                 var header = document.getElementById('loginHeader');
                 if(header) header.style.display = 'block';
            } else {
                 campo.setAttribute('readonly', 'readonly');
                 campo.style.pointerEvents = 'auto';
                 campo.style.cursor = 'pointer';
            }
        }
        
        ajustarInput();
        window.addEventListener('resize', ajustarInput);
        
        // Fechar ao clicar fora
        document.addEventListener('click', function(event) {
            var teclado = document.getElementById('teclado-overlay');
            var campoAlvo = document.getElementById('acesso_user');
            
            // Se o clique NÃO foi no teclado E NÃO foi no campo de senha
            if (teclado && campoAlvo && !teclado.contains(event.target) && event.target !== campoAlvo) {
                // Verifica se o teclado está aberto antes de mandar fechar
                if (teclado.classList.contains('aberto')) {
                    fecharTeclado();
                }
            }
        });
    });
	


// ==================================================
    // === SISTEMA DE NOTIFICAÇÕES (MURAL DE AVISOS) ===
    // ==================================================

    // OBS: As variáveis globais 'ultimoSnapshotMsg' e 'totalMensagensAtivas' 
    // já foram criadas no topo do arquivo. Aqui apenas as usamos.

    // Espera a janela carregar TUDO (imagens, scripts) e espera mais 1 segundo
    // Isso garante que a tela "Carregando..." já sumiu antes de tentar buscar mensagens
    window.addEventListener('load', function() {
        setTimeout(function() {
            iniciarListenerMensagens();
        }, 1500); // 1.5 segundos de atraso proposital
    });

    function iniciarListenerMensagens() {
        var mensagensRef = database.ref('sistemas/mensagens');
        
        mensagensRef.on('value', function(snapshot) {
            // Salva os dados na variável global (criada no topo) e desenha a tela
            ultimoSnapshotMsg = snapshot;
            renderizarListaMensagens();
        });
    }

    // --- ABRIR MURAL ---
    window.abrirMuralMensagens = function() {
        var modal = document.getElementById('modal-mensagens');
        var areaAdmin = document.getElementById('admin-area-mensagens');
        var listaDiv = document.getElementById('lista-mensagens');
        
        var isUserAdmin = (typeof isUsuarioAdmin === 'function' && isUsuarioAdmin());

        // Trava: se não é admin e não tem msg, não abre
        if (!isUserAdmin && totalMensagensAtivas === 0) {
            mostrarNotificacao("⚠️ Não há novas notificações ou avisos no momento.", 'warning');
            return; 
        }

        if (!modal) return;
        
        modal.style.display = 'flex';
        
        // Ajustes de Admin (botões de excluir)
        if (isUserAdmin) {
            if (areaAdmin) areaAdmin.style.display = 'block';
            if (listaDiv) listaDiv.classList.add('modo-admin-ativo');
        } else {
            if (areaAdmin) areaAdmin.style.display = 'none';
            if (listaDiv) listaDiv.classList.remove('modo-admin-ativo');
        }

        // --- LÓGICA DO VISUAL "NOVO" ---
        // 1. Escondemos o BADGE (bolinha vermelha) para limpar a tela inicial.
        var badge = document.getElementById('notificacao-badge');
        if (badge) badge.style.display = 'none';

        // 2. NÃO salvamos a data no localStorage ainda!
        // Assim, a função renderizarListaMensagens() continua achando que é "novo" 
        // e mantém a tag vermelha enquanto você lê.
        renderizarListaMensagens();
    };

    // --- FECHAR MURAL ---
    window.fecharMuralMensagens = function() {
        document.getElementById('modal-mensagens').style.display = 'none';
        window.ocultarFormularioMensagem();

        // --- AGORA SIM: SALVAMOS A LEITURA ---
        // Quando o usuário fecha a janela, entendemos que ele terminou de ler.
        // Gravamos a hora atual. Na próxima vez que ele abrir, o (NOVO) terá sumido.
        var nomeLogado = localStorage.getItem('jogadorLogado') || 'anonimo';
        var storageKey = 'ultimo_acesso_msg_' + nomeLogado;
        localStorage.setItem(storageKey, Date.now());
        
        // Atualiza a lista em background para limpar o status para a próxima vez
        renderizarListaMensagens();
    };

    // --- FUNÇÕES DE ESCRITA (ADMIN) ---

    window.mostrarFormularioMensagem = function() {
        document.getElementById('form-nova-mensagem').style.display = 'block';
        document.getElementById('msg-titulo').focus();
    };

    window.ocultarFormularioMensagem = function() {
        document.getElementById('form-nova-mensagem').style.display = 'none';
        document.getElementById('msg-titulo').value = '';
        document.getElementById('msg-texto').value = '';
    };

    window.enviarMensagemFirebase = function() {
        var titulo = document.getElementById('msg-titulo').value.trim();
        var texto = document.getElementById('msg-texto').value.trim();
        
        if (!titulo || !texto) {
            mostrarNotificacao("Preencha título e mensagem antes de enviar!", 'warning');
            return;
        }

        var acaoEnviar = function() {
            var nomeLogado = localStorage.getItem('jogadorLogado') || "Admin";
            var nomeAutor = nomeLogado + " (Admin)";

            var novaMsgRef = database.ref('sistemas/mensagens').push();
            novaMsgRef.set({
                id: novaMsgRef.key,
                titulo: titulo,
                texto: texto,
                autor: nomeAutor,
                data_envio: firebase.database.ServerValue.TIMESTAMP,
                ativo: true
            }, function(error) {
                if (error) {
                    mostrarNotificacao("Erro ao enviar: " + error.message, 'error');
                } else {
                    mostrarNotificacao("Mensagem enviada com sucesso!", 'success');
                    window.ocultarFormularioMensagem();
                }
            });
        };

        mostrarConfirmacao(
            "Confirma o envio desta mensagem para <b>TODOS</b> os usuários?", 
            acaoEnviar, 
            null, 
            'primary'
        );

        setTimeout(function() {
            var modalConf = document.getElementById('modalConfirmacaoOverlay');
            if(modalConf) modalConf.style.zIndex = "99999";
        }, 50);
    };
    
    // --- FUNÇÃO PARA EXCLUIR MENSAGEM (ADMIN) ---
    window.excluirMensagem = function(idMensagem) {
        var acaoExcluir = function() {
            database.ref('sistemas/mensagens/' + idMensagem).remove()
            .then(function() {
                mostrarNotificacao("Mensagem excluída com sucesso!", 'success');
            })
            .catch(function(error) {
                mostrarNotificacao("Erro ao excluir: " + error.message, 'error');
            });
        };

        mostrarConfirmacao(
            "Tem certeza que deseja <b>EXCLUIR</b> este aviso permanentemente?",
            acaoExcluir,
            null, 
            'danger'
        );

        setTimeout(function() {
            var modalConf = document.getElementById('modalConfirmacaoOverlay');
            if(modalConf) modalConf.style.zIndex = "99999";
        }, 50);
    };

    // --- FUNÇÃO QUE DESENHA A LISTA NA TELA ---
    window.renderizarListaMensagens = function() {
        if (!ultimoSnapshotMsg) return;

        var listaDiv = document.getElementById('lista-mensagens');
        var badge = document.getElementById('notificacao-badge');
        
        if (!listaDiv) return;

        listaDiv.innerHTML = ''; 
        var htmlMensagens = '';
        var contadorNaoLidas = 0;
        
        // Pega data do último acesso (Que agora só atualiza no FECHAR)
        var nomeLogado = localStorage.getItem('jogadorLogado') || 'anonimo';
        var storageKey = 'ultimo_acesso_msg_' + nomeLogado;
        var ultimoAcesso = localStorage.getItem(storageKey) || 0;

        var mensagensArray = [];

        ultimoSnapshotMsg.forEach(function(childSnapshot) {
            var msg = childSnapshot.val();
            if (msg.ativo) { 
                mensagensArray.push(msg);
                if (msg.data_envio > ultimoAcesso) {
                    contadorNaoLidas++;
                }
            }
        });

        // Atualiza a variável GLOBAL que está no topo do arquivo
        totalMensagensAtivas = mensagensArray.length;

        mensagensArray.sort(function(a, b) {
            return b.data_envio - a.data_envio;
        });

        if (mensagensArray.length === 0) {
            htmlMensagens = '<p style="text-align:center; padding:20px; color:#999;">Nenhum aviso no momento.</p>';
        } else {
            mensagensArray.forEach(function(msg) {
                var dataObj = new Date(msg.data_envio);
                var dataFormatada = dataObj.toLocaleDateString('pt-BR') + ' às ' + dataObj.toLocaleTimeString('pt-BR', {hour: '2-digit', minute:'2-digit'});
                
                // Enquanto a janela está aberta, o ultimoAcesso é antigo, então mostra o NOVO
                var tagNovo = (msg.data_envio > ultimoAcesso) ? '<span style="color:#ff3b30; font-size:11px; font-weight:bold; margin-left:8px;">● NOVO</span>' : '';

                var btnExcluir = '<span class="btn-excluir-msg" onclick="excluirMensagem(\'' + msg.id + '\')" title="Excluir este aviso">&times;</span>';

                htmlMensagens += 
                    '<div class="card-mensagem">' +
                        btnExcluir + 
                        '<h3>' + msg.titulo + tagNovo + '</h3>' +
                        '<p>' + msg.texto + '</p>' +
                        '<div class="card-info-autor">' +
                            '<span>Por: ' + (msg.autor || 'Administração') + '</span>' +
                            '<span>' + dataFormatada + '</span>' +
                        '</div>' +
                    '</div>';
            });
        }

        listaDiv.innerHTML = htmlMensagens;

        if (contadorNaoLidas > 0) {
            badge.style.display = 'flex';
            badge.textContent = contadorNaoLidas > 9 ? '9+' : contadorNaoLidas;
            badge.style.transform = 'scale(1.2)';
            setTimeout(function(){ badge.style.transform = 'scale(1)'; }, 200);
        } else {
            badge.style.display = 'none';
        }
    };
	
	
</script>

<div id="versao-desatualizada-overlay">
    <div class="mensagem-overlay">
        <h1></h1> <p></p>   </div>
</div>

</body>
</html>
